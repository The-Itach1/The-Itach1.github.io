<!DOCTYPE html><html lang="zh-CH" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>win32编程学习笔记 | The_Itach1</title><meta name="author" content="The_Itach1"><meta name="copyright" content="The_Itach1"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="win32 API编程学习笔记win32的变量类型https:&#x2F;&#x2F;www.cnblogs.com&#x2F;happycat1988&#x2F;archive&#x2F;2013&#x2F;04&#x2F;14&#x2F;3020820.html win32中的宽字符视频主要讲了MessageBox()这个API函数吧 #include&lt;stdio.h&gt; #include&lt;windows.h&gt; int main() &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="win32编程学习笔记">
<meta property="og:url" content="http://example.com/2021/03/30/win32%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="The_Itach1">
<meta property="og:description" content="win32 API编程学习笔记win32的变量类型https:&#x2F;&#x2F;www.cnblogs.com&#x2F;happycat1988&#x2F;archive&#x2F;2013&#x2F;04&#x2F;14&#x2F;3020820.html win32中的宽字符视频主要讲了MessageBox()这个API函数吧 #include&lt;stdio.h&gt; #include&lt;windows.h&gt; int main() &amp;#123;">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="https://i.loli.net/2021/03/30/n7siDC4uFlg8SLv.jpg">
<meta property="article:published_time" content="2021-03-30T10:45:27.554Z">
<meta property="article:modified_time" content="2021-03-30T10:53:48.524Z">
<meta property="article:author" content="The_Itach1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/03/30/n7siDC4uFlg8SLv.jpg"><link rel="shortcut icon" href="/img/2.png"><link rel="canonical" href="http://example.com/2021/03/30/win32%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-30 18:53:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">23</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> music</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> movies</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2021/03/30/n7siDC4uFlg8SLv.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">The_Itach1</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> music</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> movies</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">win32编程学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-03-30T10:45:27.554Z" title="Created 2021-03-30 18:45:27">2021-03-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-03-30T10:53:48.524Z" title="Updated 2021-03-30 18:53:48">2021-03-30</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="win32-API编程学习笔记"><a href="#win32-API编程学习笔记" class="headerlink" title="win32 API编程学习笔记"></a>win32 API编程学习笔记</h2><h3 id="win32的变量类型"><a href="#win32的变量类型" class="headerlink" title="win32的变量类型"></a>win32的变量类型</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/happycat1988/archive/2013/04/14/3020820.html">https://www.cnblogs.com/happycat1988/archive/2013/04/14/3020820.html</a></p>
<h3 id="win32中的宽字符"><a href="#win32中的宽字符" class="headerlink" title="win32中的宽字符"></a>win32中的宽字符</h3><p>视频主要讲了MessageBox()这个API函数吧</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;
int main()
&#123;
    /*    int MessageBox(
        HWND hWND,   //handle to owner window   句柄 
        LPCSTR IpText,  //text in message box  内容 
        LPCSTR IpCption, //message box title  窗口的标题 
        UINT uType       //message box style  窗口的格式 
        )
      */

//    CHAR message[]=&quot;hellow world&quot;;
//    CHAR title[]=&quot;messagebox&quot;;
//    MessageBoxA(NULL,message,title,MB_OK);   /*ASCALL   单位为一个字节*/ 


//    WCHAR message[]=L&quot;hellow world&quot;;
//    WCHAR title[]=L&quot;messagebox&quot;;
//    MessageBoxW(NULL,message,title,MB_OK);   /*unicode  一个单位为两个字节*/

//    TCHAR message[]=TEXT(&quot;hellow world&quot;);
//    TCHAR title[]=TEXT(&quot;messagebox&quot;);
//    MessageBox(NULL,message,title,MB_OK);    /*可以根据项目的要求来决定是什么编码方式*/

    return 0;
&#125;</code></pre>
<h3 id="进程的创建过程"><a href="#进程的创建过程" class="headerlink" title="进程的创建过程"></a>进程的创建过程</h3><p><strong>1.什么是进程？</strong></p>
<p>进程提供程序所需的资源，如：数据，代码(dll文件这些)。需要注意的是只提供资源，而使用这些资源是线程做的事情，任何进程都是别的进程创建的，使用了CreateProcess()这个函数，然后第一个进程是内核创建的。</p>
<p><strong>2.进程内存空间的地址划分</strong></p>
<p>可以在调试器(od,xdbg)里面大致查看，下面是分区。</p>
<pre><code>空指针赋值区    0x00000000--0x0000FFFF   //就是全是空的，一般不会使用这一部分
用户模式区      0x00010000--0x7FFEFFFF   //我们使用的地方，加载exe，和dll的，这个过程应该发生了基地址重定位。
64kb禁入区      0x7FFF0000--0X7FFFFFFF   //也是空的，我们和系统都不会用的地方
内核            0x80000000--0xFFFFFFFF   //内核系统占用的地方，这些内核是不会变的</code></pre>
<p><strong>3.进程的创建过程</strong></p>
<pre><code>1.映射EXE文件
2.创建内核对象EPROCESS
3.映射系统Dll(ntdll.dll)  //映射的第一个dll
4.创建线程内核对象ETHREAD
5.系统启动线程
    映射DLL(ntdll.LdrlnitializeThunk)  //应该是加载其他的dll这些，然后有些dll也会加载它们需要的dll，这也是为什么进程里面有很多dll

    线程开始执行</code></pre>
<p><img src="https://i.loli.net/2021/03/03/6RJTyeML1xXn2b7.png"><br>如果熟悉这些过程，就可以较好的理解dll注入这些技术手段。</p>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>主要就是CreateProcess()这个API</p>
<pre><code>BOOL CreateProcess
(
    LPCTSTR lpApplicationName,  //指向一个NULL结尾的、用来指定可执行模块的字符串。
    LPTSTR lpCommandLine,  //指向一个以NULL结尾的字符串，该字符串指定要执行的命令行。
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCTSTR lpCurrentDirectory,
    LPSTARTUPINFO lpStartupInfo,  //STARTUPINFO，指定一个STARTUPINFO结构，其中包含了创建进程时使用的附加信息
    LPPROCESS_INFORMATIONlpProcessInformation   //PROCESS_INFORMATION，该结构用于容纳新进程的进程和线程标识符。大多数情况下，一旦这个函数返回，父应用程序都会关闭两个句柄。
);</code></pre>
<p>然后就是两个结构体</p>
<pre><code>  typedef struct _PROCESS_INFORMATION &#123;
    HANDLE hProcess;  //两个句柄
    HANDLE hThread;
    DWORD dwProcessId;   //两个id
    DWORD dwThreadId;
  &#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

  typedef struct _STARTUPINFOA &#123;
    DWORD cb;   //第一个是用来储存这个结构体的size的。
    LPSTR lpReserved;
    LPSTR lpDesktop;
    LPSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
  &#125; STARTUPINFOA, *LPSTARTUPINFOA;</code></pre>
<p>例子</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;
BOOL CreateChildProcess(PTCHAR szChildname,PTCHAR szCommandLine)
&#123;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&amp;pi,sizeof(pi));//用来将指定的内存块清零。
    ZeroMemory(&amp;si,sizeof(si));
    si.cb =sizeof(si);

    if(!CreateProcess(
        szChildname,
        szCommandLine,
        NULL,  //不继承进程句柄
        NULL,  //不继承线程句柄
        FALSE, //不继承句柄 
        0,     //没有创建标志，常用的有一个CREATE_SUSPENDED，立即挂起新进程。除非调用了ResumeThread函数函数，否则它不会恢复运行。可以用来干坏事。
        NULL,
        NULL,
        &amp;si,
        &amp;pi)
    )
    &#123;
        printf(&quot;CreateChildProcess Error%d&quot;,GetLastError());   //用来返回大概错误信息
        return FALSE;
    &#125;
    CloseHandle(pi.hProcess);   //关闭句柄
    CloseHandle(pi.hThread);
    return TRUE;
&#125;

int main(int argc,char*argv[])
&#123;
    TCHAR lpApplicationName[]=TEXT(&quot;C:/Program Files/Mozilla Firefox/firefox.exe&quot;);
    TCHAR lpCommandLine[]=TEXT(&quot; https://the_itach1.gitee.io/&quot;);

    CreateChildProcess(lpApplicationName,lpCommandLine);

    getchar();
    return 0;
&#125;</code></pre>
<p>其中一些函数的解释</p>
<p><strong>ZeroMemory()</strong></p>
<p>ZeroMemory只是将指定的内存块清零。<br>使用结构前清零，而不让结构的成员数值具有不确定性，是一个好的编程习惯。</p>
<pre><code>void ZeroMemory( PVOID Destination,SIZE_T Length );

Destination :指向一块准备用0来填充的内存区域的开始地址。
Length :准备用0来填充的内存区域的大小，按字节来计算。</code></pre>
<h3 id="句柄与id"><a href="#句柄与id" class="headerlink" title="句柄与id"></a>句柄与id</h3><p>内核对象</p>
<p>像进程，线程，文件，互斥体，事件等在内核都有一个对应的结构体，这些结构体由内核负责管理，我们管这样的对象叫做内核对象。<br><img src="https://i.loli.net/2021/03/04/N91iX5qbzGMSKjv.png"></p>
<p>句柄表</p>
<p>每个进程里面都有一个句柄表，根据索引可以找到像对应的内核对象(结构体)，比如说File，Process，Thread，Event….。句柄应该就指向对应的内核对象。</p>
<p>特别的是操作系统有一个特殊的句柄，叫做全局句柄表。<br><img src="https://i.loli.net/2021/03/04/NcJTGi67zhjDB9r.png"></p>
<p>ID</p>
<p>ID可以理解为就是每一个进程的编号，是不会变的。<br><img src="https://i.loli.net/2021/03/04/SQqh2uGOo3j7mTx.png"></p>
<h3 id="进程相关API"><a href="#进程相关API" class="headerlink" title="进程相关API"></a>进程相关API</h3><p><strong>SuspendThread()</strong></p>
<p>SuspendThread，暂停指定的线程。</p>
<pre><code>DWORD WINAPI SuspendThread(
　　_In_HANDLE hThread
　　);</code></pre>
<p><strong>ResumeThread()</strong></p>
<p>ResumeThread，启动指定的线程。</p>
<pre><code>DWORD WINAPI ResumeThread(
_In_ HANDLE hThread
);</code></pre>
<p><strong>TerminateProcess()</strong><br>终止指定进程及其所有的线程。</p>
<pre><code>BOOL TerminateProcess(
    HANDLE hProcess,  //进程句柄
    UINT uExitCode    //进程终止码
);</code></pre>
<p><strong>OpenProcess()</strong></p>
<p>OpenProcess 函数用来打开一个已存在的进程对象，并返回进程的句柄。</p>
<pre><code>HANDLE OpenProcess(
    DWORD dwDesiredAccess, //渴望得到的访问权限（标志），有很多种。
    BOOL bInheritHandle, // 是否继承句柄
    DWORD dwProcessId// 进程标示符
);</code></pre>
<p>例子</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;

int main()
&#123;
    HANDLE hProcess;
//    hProcess=(HANDLE)0x212;

    hProcess=OpenProcess(PROCESS_ALL_ACCESS,FALSE,19220);
    if(!TerminateProcess(hProcess,1))
    &#123;
        printf(&quot;无法终止进程&quot;); 
    &#125;

 &#125; </code></pre>
<p><strong>GetModuleFileName()</strong></p>
<p>获取当前进程已加载模块的文件的完整路径，该模块必须由当前进程加载。</p>
<pre><code>DWORDGetModuleFileName(
HMODULE  hModule,//装载一个程序实例的句柄。如果该参数为NULL，该函数返回该当前应用程序全路径。
LPTSTR  lpFilename,
DWORD  nSize
);</code></pre>
<p>例子</p>
<pre><code>TCHAR szPath[MAX_PATH];
if( !GetModuleFileName( NULL, szPath, MAX_PATH ) )
&#123;
    printf(&quot;GetModuleFileName failed (%d)\n&quot;, GetLastError());
    return FALSE;
&#125;
printf(&quot;%s&quot;,szPath);</code></pre>
<p><strong>GetCurrentDirectory()</strong></p>
<p>是一个系统参数，在一个缓冲区中装载当前目录，Long，装载到lpBuffer的字节数。如nBufferLength的长度不够，不足以容纳目录，则返回值是必要的缓冲区长度（要求至少这个长度），其中包括空中止字符。零表示失败。会设置GetLastError。</p>
<pre><code>DWORD GetCurrentDirectory(
DWORD nBufferLength,     //sizeofdirectorybuffer  缓冲区的长度
LPTSTR lpBuffer          //directorybuffer  指定一个预定义字串，用于装载当前目录
);</code></pre>
<p>例子</p>
<pre><code>TCHAR scPath[MAX_PATH];
if( !GetCurrentDirectory( MAX_PATH,scPath ) )
&#123;
    printf(&quot;GetCurrentDirectory failed (%d)\n&quot;, GetLastError());
    return FALSE;
&#125;
printf(&quot;%s&quot;,scPath); </code></pre>
<p><strong>GetCurrentProcessId()</strong></p>
<p>获取当前进程一个唯一的标识符(PID)。返回值 Long，当前进程的PID</p>
<p>例子</p>
<pre><code>long PID;
PID=GetCurrentProcessId(); 
printf(&quot;%d&quot;,PID);</code></pre>
<p><strong>GetCurrentProcess()</strong></p>
<p>获取当前进程的一个伪句柄，返回值 Long，当前进程的伪句柄 </p>
<p>例子</p>
<pre><code>HANDLE FAKEhProcess;
FAKEhProcess=GetCurrentProcess();
printf(&quot;%d&quot;,FAKEhProcess);</code></pre>
<p><strong>CreateToolhelp32Snapshot()</strong></p>
<p>CreateToolhelp32Snapshot可以通过获取进程信息为指定的进程、进程使用的堆[HEAP]、模块[MODULE]、线程建立一个快照。</p>
<pre><code>HANDLE WINAPI CreateToolhelp32Snapshot(
    DWORD dwFlags, //用来指定“快照”中需要返回的对象，可以是TH32CS_SNAPPROCESS等
    DWORD th32ProcessID //一个进程ID号，用来指定要获取哪一个进程的快照，当获取系统进程列表或获取 当前进程快照时可以设为0
);

TH32CS_SNAPPROCESS(0x00000002) - 在快照中包含系统中所有的进程。
调用成功，返回快照的句柄，调用失败，返回INVALID_HANDLE_VALUE 。</code></pre>
<p>例子，查找一个进程的PID</p>
<pre><code>#include &quot;windows.h&quot;
#include &quot;tlhelp32.h&quot;
#include &quot;tchar.h&quot;

DWORD FindProcessID(LPCTSTR szProcessName)
&#123;
    DWORD dwPID = 0xFFFFFFFF;
    HANDLE hSnapShot = INVALID_HANDLE_VALUE;   //定义了一个快照的句柄。
    PROCESSENTRY32 pe;  //tagPROCESSENTRY32结构体，下面会介绍。

    // Get the snapshot of the system
    pe.dwSize = sizeof(PROCESSENTRY32);
    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, NULL);  //获取快照句柄

    // find process
    Process32First(hSnapShot, &amp;pe);  //获得第一个进程的句柄。
    do
    &#123;
        if (!_tcsicmp(szProcessName, (LPCTSTR) pe.szExeFile))//比较当前进程和我们需要的进程的名称是否一样。
        &#123;
            dwPID = pe.th32ProcessID;
            break;
        &#125;
    &#125; while (Process32Next(hSnapShot, &amp;pe)); //获得下一个进程的句柄。

    CloseHandle(hSnapShot);  //关闭快照句柄

    return dwPID;
&#125;

int _tmain(int argc, TCHAR* argv[])
&#123;
    DWORD dwPID = 0xFFFFFFFF;

    // find process
    dwPID = FindProcessID(argv[1]);
    if (dwPID == 0xFFFFFFFF)
    &#123;
        _tprintf(L&quot;There is no &lt;%s&gt; process!\n&quot;, argv[1]);
        return 1;
    &#125;

    _tprintf(L&quot;PID of \&quot;%s\&quot; is %d\n&quot;, argv[1], dwPID);

&#125;</code></pre>
<p>tagPROCESSENTRY32结构体，快照的进程信息会保存在这个结构体内。</p>
<pre><code>typedef struct tagPROCESSENTRY32 &#123;
    DWORD dwSize; // 结构大小；
    DWORD cntUsage; // 此进程的引用计数；
    DWORD th32ProcessID; // 进程ID;
    DWORD th32DefaultHeapID; // 进程默认堆ID；
    DWORD th32ModuleID; // 进程模块ID；
    DWORD cntThreads; // 此进程开启的线程计数；
    DWORD th32ParentProcessID;// 父进程ID；
    LONG pcPriClassBase; // 线程优先权；
    DWORD dwFlags; // 保留；
    WCHAR szExeFile[MAX_PATH]; // 进程全名；
&#125; PROCESSENTRY32;</code></pre>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p><strong>1.什么是线程？</strong></p>
<p>(1)线程是附属在进程上的执行实体，是代码的执行流程。</p>
<p>(2)一个进程可以包含多个线程，但一个进程至少要包含一个线程。</p>
<p><strong>CreateThread()</strong></p>
<pre><code>HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,//SD
    SIZE_T dwStackSize,//initialstacksize   初始堆栈大小
    LPTHREAD_START_ROUTINE lpStartAddress,//threadfunction 
    LPVOID lpParameter,//threadargument   线程参数
    DWORD dwCreationFlags,//creationoption   创建选项
    LPDWORD lpThreadId//threadidentifier   线程标识符
)</code></pre>
<p>第一个参数 lpThreadAttributes 表示线程内核对象的安全属性，一般传入NULL表示使用默认设置。</p>
<p>第二个参数 dwStackSize 表示线程栈空间大小。传入0表示使用默认大小（1MB）。</p>
<p>第三个参数 lpStartAddress 表示新线程所执行的线程函数地址，多个线程可以使用同一个函数地址。</p>
<p>第四个参数 lpParameter 是传给线程函数的参数。</p>
<p>第五个参数 dwCreationFlags 指定额外的标志来控制线程的创建，为0表示线程创建之后立即就可以进行调度，如果为CREATE_SUSPENDED则表示线程创建后暂停运行，这样它就无法调度，直到调用ResumeThread()。</p>
<p>第六个参数 lpThreadId 将返回线程的ID号，传入NULL表示不需要返回该线程ID号。</p>
<p><strong>ThreadProc()</strong></p>
<pre><code>DWORD WINAPI ThreadProc(
LPVOID lpParameter
);</code></pre>
<p>参数:<br>lpParameter<br>接收线程传递给函数使用的CreateThread函数lpParameter参数数据。</p>
<p>返回值:<br>函数应该返回一个值，表示线程函数返回退出码，一般使用0作为返回值。<br>线程创建成功,返回非零值,否则为0。</p>
<p>例子</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;

DWORD WINAPI ThreadProc(LPVOID lpParam)
&#123;
    printf(&quot;%d&quot;,*(int*)lpParam);
    int i;
    for(i=0;i&lt;=100;i++)
    &#123;
        Sleep(500);
        printf(&quot;+++++++++++%d\n&quot;,i);
    &#125;

    return 0;
&#125;

int main()
&#123;
    int i;
    int b=10;
    HANDLE hthread;
    LPVOID lpParam=&amp;b; 

    hthread=CreateThread(NULL,0,ThreadProc,lpParam,0,NULL);
    for(i=0;i&lt;=100;i++)
    &#123;
        Sleep(500);
        printf(&quot;------------%d\n&quot;,i);
    &#125;
&#125;</code></pre>
<h3 id="和线程相关的函数"><a href="#和线程相关的函数" class="headerlink" title="和线程相关的函数"></a>和线程相关的函数</h3><p><strong>Sleep()</strong></p>
<p>Sleep函数可以使计算机程序（进程，任务或线程）进入休眠，使其在一段时间内处于非活动状态。当函数设定的计时器到期，或者接收到信号、程序发生中断都会导致程序继续执行。</p>
<pre><code>Sleep(3000)//休眠3s</code></pre>
<p><strong>SuspendThread()</strong></p>
<p>SuspendThread，暂停指定的线程。</p>
<pre><code>DWORD WINAPI SuspendThread(
　　_In_HANDLE hThread  //进程句柄
);</code></pre>
<p><strong>ResumeThread()</strong></p>
<p>使线程的挂起时间计数减一。创建一个挂起的线程或者手动挂起一个线程后调用。调用该函数后线程不一定会立刻执行，而是由操作系统继续调度，直到计数为0，系统为其分配资源时才开始执行。</p>
<pre><code>DWORD WINAPI ResumeThread(
    _In_ HANDLE hThread  //进程句柄
);</code></pre>
<p><strong>WaitForSingleObject()</strong></p>
<pre><code>DWORD WINAPI WaitForSingleObject(
    __in HANDLE hHandle,
    __in DWORD dwMilliseconds
);
hHandle[in]:

对象句柄。可以指定一系列的对象，如Event、Job、Memory resource notification、Mutex、Process、Semaphore、Thread、Waitable timer等。

dwMilliseconds[in]:
定时时间间隔，单位为milliseconds（毫秒）.如果指定一个非零值，函数处于等待状态直到hHandle标记的对象被触发，或者时间到了。如果dwMilliseconds为0，对象没有被触发信号，函数不会进入一个等待状态，它总是立即返回。如果dwMilliseconds为INFINITE，对象被触发信号后，函数才会返回。</code></pre>
<p><strong>WaitForMultipleObjects()</strong></p>
<p>WaitForMultipleObjects是Windows中的一个功能非常强大的函数，几乎可以等待Windows中的所有的内核对象</p>
<pre><code>DWORD WaitForMultipleObjects(
    DWORD nCount,    //数组中的对象句柄数
    const HANDLE* lpHandles,   //[in]一组对象句柄。该数组可以包含不同类型对象的句柄。
    BOOL bWaitAll,   //[in] 如果此参数为TRUE，则在lpHandles数组中的所有对象的状态发出信号时，该函数返回。如果为FALSE，则当任何一个对象的状态设置为信号时，该函数返回。在后一种情况下，返回值表示其状态导致函数返回的对象。
    DWORD dwMilliseconds  //INFINITE
);</code></pre>
<p><strong>GetExitCodeThread()</strong></p>
<p>GetExitCodeThread，计算机用语，用于获取一个已中止线程的退出代码。</p>
<pre><code>BOOL GetExitCodeThread(
     HANDLE hThread,  //in，获取退出代码的一个线程的句柄
     LPDWORD lpExitCode   //out，存储线程结束代码,也就是线程的返回值
);</code></pre>
<p>例子</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;

DWORD WINAPI ThreadProc(LPVOID lpParam)
&#123;
    printf(&quot;this is a thread\n&quot;);
    return 5;
&#125;

int main()
&#123;
    HANDLE arrhtherd[2];
    DWORD  ExitCode1,ExitCode2;
    arrhtherd[0]=CreateThread(NULL,0,ThreadProc,NULL,0,NULL);
    //将线程1挂起2次，并睡眠5秒，然后恢复线程1 
    SuspendThread(arrhtherd[0]);
    SuspendThread(arrhtherd[0]);
    Sleep(5000);
    ResumeThread(arrhtherd[0]);
    ResumeThread(arrhtherd[0]);

    arrhtherd[1]=CreateThread(NULL,0,ThreadProc,NULL,0,NULL);
    //等待两线程都完成。 
    WaitForMultipleObjects(2,arrhtherd,TRUE,INFINITE);
    //获得线程1的返回值ExitCode1，然后输出 
    GetExitCodeThread(arrhtherd[0],&amp;ExitCode1);
    printf(&quot;%d&quot;,ExitCode1);

    CloseHandle(arrhtherd[0]);
    CloseHandle(arrhtherd[1]);
    getchar();
&#125;</code></pre>
<h3 id="临界区-多线程调用全局变量产生的问题"><a href="#临界区-多线程调用全局变量产生的问题" class="headerlink" title="临界区-多线程调用全局变量产生的问题"></a>临界区-多线程调用全局变量产生的问题</h3><p>当多个个线程同时调用一个全局变量时候会有线程安全问题，因为线程的进行时间的不定性，可能导致线程1执行到一半，然后又去执行线程2，又因为使用的是同一个全局变量，就会产生问题。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;

int number=10; 
DWORD WINAPI ThreadProc1(LPVOID lpParam)
&#123;
    while(number&gt;0)
    &#123;
        printf(&quot;当前number为%d\n&quot;,number);
        number--;
        printf(&quot; 减后number为%d\n&quot;,number);
    &#125;
    return 0;
&#125;

DWORD WINAPI ThreadProc2(LPVOID lpParam)
&#123;
    while(number&gt;0)
    &#123;
        printf(&quot;当前number为%d\n&quot;,number);
        number--;
        printf(&quot; 减后number为%d\n&quot;,number);
    &#125;
    return 0;
&#125;

int main()
&#123;
    HANDLE arrhtherd[2];

    arrhtherd[0]=CreateThread(NULL,0,ThreadProc1,NULL,0,NULL);
    arrhtherd[1]=CreateThread(NULL,0,ThreadProc2,NULL,0,NULL);

    WaitForMultipleObjects(2,arrhtherd,TRUE,INFINITE);

    CloseHandle(arrhtherd[0]);
    CloseHandle(arrhtherd[1]);
    getchar();
&#125;</code></pre>
<p>执行会看到结果如下，存在一些问题<br><img src="https://i.loli.net/2021/03/10/i29n7yI4hj5MOcW.png"></p>
<p>所以这时候我们需要设置临界区，也就是线程锁，让线程1在执行的时候，不会跳到线程2。但是设置临界区要注意保证线程中和全局变量相关的逻辑代码都要报包含在临界区内</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;

int number=10; 
//创建全局变量 
CRITICAL_SECTION cs;

DWORD WINAPI ThreadProc1(LPVOID lpParam)
&#123;
    //实现临界区 
    EnterCriticalSection(&amp;cs);
    while(number&gt;0)
    &#123;
        printf(&quot;当前number为%d\n&quot;,number);
        number--;
        printf(&quot; 减后number为%d\n&quot;,number);
    &#125;
    LeaveCriticalSection(&amp;cs);
    return 0;
&#125;

DWORD WINAPI ThreadProc2(LPVOID lpParam)
&#123;
    EnterCriticalSection(&amp;cs);
    while(number&gt;0)
    &#123;
        printf(&quot;当前number为%d\n&quot;,number);
        number--;
        printf(&quot; 减后number为%d\n&quot;,number);
    &#125;
    LeaveCriticalSection(&amp;cs);
    return 0;
&#125;

int main()
&#123;
    HANDLE arrhtherd[2];
    //初始化全局变量 
    InitializeCriticalSection(&amp;cs);

    arrhtherd[0]=CreateThread(NULL,0,ThreadProc1,NULL,0,NULL);
    arrhtherd[1]=CreateThread(NULL,0,ThreadProc2,NULL,0,NULL);

    WaitForMultipleObjects(2,arrhtherd,TRUE,INFINITE);

    CloseHandle(arrhtherd[0]);
    CloseHandle(arrhtherd[1]);
    getchar();
&#125; </code></pre>
<p>执行后会发现没有问题，就不贴图了。</p>
<h3 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h3><p><strong>CreateMutex</strong></p>
<p>CreateMutex是一个计算机函数，作用是找出当前系统是否已经存在指定进程的实例。如果没有则创建一个互斥体。</p>
<pre><code>HANDLE CreateMutex(
    LPSECURITY_ATTRIBUTES lpMutexAttributes, // 指向安全属性的指针，一般设置为NULL
    BOOL bInitialOwner, // 初始化互斥对象的所有者，如创建进程希望立即拥有互斥体，则设为TRUE。一个互斥体同时只能由一个线程拥有。
    LPCTSTR lpName // 指向互斥对象名的指针
);

BOOL bInitialOwner TRUE代表就是当前线程的，FALSE代表这个互斥体不是当前线程只是将他创建出来</code></pre>
<p>例子，自己过改TRUE和FLASE来理解。</p>
<p>进程1</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;

int main()
&#123;
    int i;
    //创建一个互斥体 
    HANDLE g_hMutex=CreateMutex(NULL,TRUE,&quot;name&quot;);
    //获取令牌：有信号 或者线程的拥有者(TRUE)
    WaitForSingleObject(g_hMutex,INFINITE);
    for(i=0;i&lt;10;i++)
    &#123;
        Sleep(1000);
        printf(&quot;hellow world\n&quot;);
    &#125;
    //释放令牌 
    ReleaseMutex(g_hMutex);
    getchar(); 
    return 0;
 &#125; </code></pre>
<p>进程2</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;

int main()
&#123;
    int i;
    //创建一个互斥体 
    HANDLE g_hMutex=CreateMutex(NULL,TRUE,&quot;name&quot;);
    //获取令牌：有信号 或者线程的拥有者(TRUE)
    WaitForSingleObject(g_hMutex,INFINITE);
    for(i=0;i&lt;10;i++)
    &#123;
        Sleep(1000);
        printf(&quot;hellow world\n&quot;);
    &#125;
    //释放令牌 
    ReleaseMutex(g_hMutex);
    getchar(); 
    return 0;
 &#125; </code></pre>
<p>我自己得出的结论就是：互斥体只会存在于其所在的线程，如果这个互斥体被其拥有者线程占用了，那么其线程将无法使用该互斥体。</p>
<p>例子</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;
HANDLE g_hSet1;

DWORD WINAPI ThreadProc1(LPVOID lpParam)
&#123;
    WaitForSingleObject(g_hSet1,INFINITE);
    printf(&quot;++++++++++++\n&quot;);
    ReleaseMutex(g_hSet1);
    return 0;
&#125;

DWORD WINAPI ThreadProc2(LPVOID lpParam)
&#123;

    WaitForSingleObject(g_hSet1,INFINITE);
    printf(&quot;-----------\n&quot;);
    SetEvent(g_hSet1);
    return 0;
&#125;

int main()
&#123;
    HANDLE arrhtherd[2];

    g_hSet1=CreateMutex(NULL,TRUE,NULL);
    ReleaseMutex(g_hSet1);//如果将这一句注释掉，那么线程1和线程2都无法执行。 

    arrhtherd[0]=CreateThread(NULL,0,ThreadProc1,NULL,0,NULL);
    arrhtherd[1]=CreateThread(NULL,0,ThreadProc2,NULL,0,NULL);

    WaitForMultipleObjects(2,arrhtherd,TRUE,INFINITE);

    CloseHandle(arrhtherd[0]);
    CloseHandle(arrhtherd[1]);
    getchar();
&#125; </code></pre>
<p><strong>互斥体和线程锁的区别</strong></p>
<ol>
<li>线程锁只能用于单个进程间的线程控制</li>
<li>互斥体可以设定等待超时，但线程锁不能</li>
<li>线程意外终结时，Mutex可以避免无限等待</li>
<li>Mutex效率没有线程锁高</li>
</ol>
<p><strong>防多开</strong></p>
<p>CreateMutex函数的返回值</p>
<p>Long，如执行成功，就返回互斥体对象的句柄；零表示出错。会设置GetLastError。如果返回的是一个有效句柄，但指定的名字已经存在，GetLastError也会设为ERROR_ALREADY_EXISTS，bInitialOwner的值将会被忽略。如果调用者限制了权限，GetLastError将会返回ERROR_ACCESS_DENIED，这个时候应该使用OpenMutex函数。</p>
<pre><code>#include &lt;stdio.h&gt; 
#include &lt;windows.h&gt;
int main(int argc, char* argv[])
&#123;
    //创建令牌
    HANDLE g_mutex = CreateMutex(NULL,FALSE,&quot;防止多开&quot;);
    DWORD DwRet = GetLastError();
    //CreateMutex()执行成功 
    if(g_mutex)
    &#123;
        //否是互斥体的名字已经存在 
        if(DwRet == ERROR_ALREADY_EXISTS)
        &#123;
            CloseHandle(g_mutex);
            return 0;
        &#125;       
    &#125;
    //CreateMutex()执行出错了
    else
    &#123;
        printf(&quot;创建失败&quot;);
        CloseHandle(g_mutex);
        return 0;
    &#125;
    while(1)
    &#123;
        Sleep(1000);
        printf(&quot;程序执行中\n&quot;);
    &#125;   
    return 0;
&#125;</code></pre>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><strong>CreateEvent()</strong></p>
<p>CreateEvent是一个WindowsAPI函数。它用来创建或打开一个命名的或无名的事件对象。</p>
<pre><code>HANDLECreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes,// 安全属性
    BOOL bManualReset,// 复位方式，TRUE为通知类型，FALSE为互斥类型。
    BOOL bInitialState,// 初始状态，FALSE为无信号，TURE为有信号
    LPCTSTR lpName // 对象名称
);
bManualReset：指定将事件对象创建成手动复原还是自动复原。如果是TRUE，那么必须用ResetEvent函数来手工将事件的状态复原到无信号状态。如果设置为FALSE，当一个线程等待到事件信号后系统会自动将事件状态复原为无信号状态。</code></pre>
<p>实现同步，同步=互斥+有序</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;
HANDLE g_hSet1,g_hSet2;
int b=10;
DWORD WINAPI ThreadProc1(LPVOID lpParam)
&#123;
    int i;
    for(i=0;i&lt;b;i++)
    &#123;
        WaitForSingleObject(g_hSet1,INFINITE);
        printf(&quot;++++++++++++\n&quot;);
        SetEvent(g_hSet2);
    &#125;
    return 0;
&#125;

DWORD WINAPI ThreadProc2(LPVOID lpParam)
&#123;
    int i;
    for(i=0;i&lt;b;i++)
    &#123;
        WaitForSingleObject(g_hSet2,INFINITE);
        printf(&quot;-----------\n&quot;);
        SetEvent(g_hSet1);
    &#125;
    return 0;
&#125;

int main()
&#123;
    HANDLE arrhtherd[2];

    g_hSet1=CreateEvent(NULL,FALSE,TRUE,NULL);
    g_hSet2=CreateEvent(NULL,FALSE,FALSE,NULL);

    arrhtherd[0]=CreateThread(NULL,0,ThreadProc1,NULL,0,NULL);
    arrhtherd[1]=CreateThread(NULL,0,ThreadProc2,NULL,0,NULL);

    WaitForMultipleObjects(2,arrhtherd,TRUE,INFINITE);

    CloseHandle(arrhtherd[0]);
    CloseHandle(arrhtherd[1]);
    getchar();
&#125; </code></pre>
<h3 id="第一个windows程序"><a href="#第一个windows程序" class="headerlink" title="第一个windows程序"></a>第一个windows程序</h3><p><strong>WinMain()</strong></p>
<p>WinMain是一个函数，该函数的功能是被系统调用，作为一个32位应用程序的入口点。WinMain函数应初始化应用程序，显示主窗口，进入一个消息接收一发送循环，这个循环是应用程序执行的其余部分的顶级控制结构。</p>
<pre><code>int APIENTRY WinMain(
    HINSTANCE hInstance,  //模块句柄，应用程序当前实例的句柄。
    HINSTANCE hPrevInstance,  //Null
    LPSTR     lpCmdLine,  //指向应用程序命令行的字符串的指针
    int       nCmdShow) //指明窗口如何显示，例如最大化，最小化，具体请查阅。</code></pre>
<p><strong>sprintf()</strong></p>
<p>sprintf指的是字符串格式化命令，函数声明为 int sprintf(char *string, char *format [,argument,…]);，主要功能是把格式化的数据写入某个字符串中，即发送格式化输出到 string 所指向的字符串。</p>
<pre><code>int sprintf(char *string, char *format [,argument,...]);</code></pre>
<p><strong>WNDCLASS</strong></p>
<p>WNDCLASS是一个由系统支持的结构，用来储存某一类窗口的信息,如ClassStyle,消息处理函数，Icon,Cursor,背景Brush等。也就是说，CreateWindow只是将某个WNDCLASS定义的窗体变成实例。</p>
<pre><code>typedef struct _WNDCLASS &#123;
    UINT style;// 窗口类的风格
    WNDPROC lpfnWndProc;//窗口处理函数
    int cbClsExtra;//窗口扩展
    int cbWndExtra;//窗口实例扩展
    HINSTANCE hInstance;//实例句柄
    HICON hIcon;//窗口的最小化图标
    HCURSOR hCursor;//窗口鼠标光标
    HBRUSH hbrBackground;//窗口背景色
    LPCTSTR lpszMenuName;//窗口菜单
    LPCTSTR lpszClassName;// 窗口类名
&#125; WNDCLASS, *LPWNDCLASS;</code></pre>
<p><strong>CreateWindow()</strong></p>
<pre><code>HWND WINAPI CreateWindow(

  _In_opt_  LPCTSTR lpClassName,  // 窗口类名称    
  _In_opt_  LPCTSTR lpWindowName, // 窗口标题    
  _In_      DWORD dwStyle,        // 窗口风格，或称窗口格式    
  _In_      int x,                // 初始 x 坐标    
  _In_      int y,                // 初始 y 坐标    
  _In_      int nWidth,           // 初始 x 方向尺寸    
  _In_      int nHeight,          // 初始 y 方向尺寸
  _In_opt_  HWND hWndParent,      // 父窗口句柄
  _In_opt_  HMENU hMenu,          // 窗口菜单句柄
  _In_opt_  HINSTANCE hInstance,  // 程序实例句柄
  _In_opt_  LPVOID lpParam        // 创建参数
);</code></pre>
<p><strong>WndProc()</strong></p>
<p>Wndproc是Windows操作系统向应用程序发送一系列消息之一，每个窗口会有一个窗口过程的回调函数，分别是窗口句柄、消息ID、WPARAM、LPARAM。<br>    LRESULT CALLBACK WndProc( //WndProc名称可自由定义<br>        HWND hwnd,//窗口句柄<br>        UINT uMsg,//消息ID<br>        WPARAM wParam,//消息参数<br>        LPARAM lParam//消息参数<br>    )；<br><strong>ShowWindow()</strong><br>该函数设置指定窗口的显示状态。</p>
<pre><code>BOOL ShowWindow(
    HWND hWnd,//窗口句柄
    int nCmdShow//指定窗口如何显示
);</code></pre>
<p><strong>GetMessage()</strong> </p>
<p>GetMessage是从调用线程的消息队列里取得一个消息并将其放于指定的结构。</p>
<pre><code>GetMessage(
    LPMSG lpMsg，//指向MSG结构的指针，该结构从线程的消息队列里接收消息信息。
    HWND hWnd，//取得其消息的窗口的句柄。
    UINT wMsgFilterMin，
    UINT wMsgFilterMax
)
lpMsg：指向MSG结构的指针，该结构从线程的消息队列里接收消息信息。
hWnd：取得其消息的窗口的句柄。当其值取NULL时，GetMessage为任何属于调用线程的窗口检索消息，线程消息通过PostThreadMessage寄送给调用线程。
wMsgFilterMin：指定被检索的最小消息值的整数。
wMsgFilterMax：指定被检索的最大消息值的整数。
返回值：如果函数取得WM_QUIT之外的其他消息，返回非零值。如果函数取得WM_QUIT消息，返回值是零。如果出现了错误，返回值是-1。例如，当hWnd是无效的窗口句柄或lpMsg是无效的指针时。若想获得更多的错误信息，请调用GetLastError函数。</code></pre>
<p><strong>MSG</strong></p>
<p>用来储存消息的结构体。MSG是Windows程序中的结构体。在Windows程序中，消息是由MSG结构体来表示的。成员变量含义：第一个成员变量hwnd表示消息所属的窗口；第二个成员变量message指定了消息的标识符。第三、第四个成员变量wParam和lParam，用于指定消息的附加信息。最后两个变量分别表示消息投递到消息队列中的时间和鼠标的当前位置。</p>
<pre><code>typedef struct tagMSG &#123;
    HWND hwnd;//消息所属的窗口
    UINT message;//消息的标识符
    WPARAM wParam;//指定消息的附加信息
    LPARAM lParam;//指定消息的附加信息
    DWORD time;//投递到消息队列中的时间
    POINT pt;//当前鼠标位置
&#125; MSG;</code></pre>
<p><strong>DispatchMessage()</strong></p>
<p>函数功能：该函数分发一个消息给窗口程序。通常消息从GetMessage函数获得或者TranslateMessage函数传递的。消息被分发到回调函数（过程函数)，作用是消息传递给操作系统，然后操作系统去调用我们的回调函数，也就是说我们在窗体的过程函数中处理消息。</p>
<pre><code>LONG DispatchMessage（
    CONST MSG*lpmsg//指向含有消息的MSG结构的指针。
）;</code></pre>
<p><strong>DefWindowProc()</strong></p>
<p>DefWindowProc函数调用缺省的窗口过程来为应用程序没有处理的任何窗口消息提供缺省的处理。该函数确保每一个消息得到处理。</p>
<pre><code>LRESULT DefWindowProc(
    HWND hWnd，//指向接收消息的窗口过程的句柄。
    UINT Msg，//指定消息类型。
    WPARAM wParam，//指定其余的、消息特定的信息。该参数的内容与Msg参数值有关。
    LPARAM IParam  //指定其余的、消息特定的信息。该参数的内容与Msg参数值有关。
)；</code></pre>
<p>例子，在vc6++中编译</p>
<pre><code>// 第一个程序.cpp : Defines the entry point for the application.
//
#include &quot;stdafx.h&quot;

LRESULT CALLBACK WndProc( //WndProc名称可自由定义
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
&#123;
     // TODO: Place code here.
    //用这种方式来打印
    /*
    char str[50];
    DWORD dwAddr = (DWORD)hInstance;
    sprintf(str,&quot;模块地址：%x&quot;, dwAddr);
    OutputDebugString(str);
    */

    char szOutBuff[50];
    //1.第一步，定义你的窗口是怎么样的。
    TCHAR classname[]=TEXT(&quot;the_itach1&quot;);
    WNDCLASS wndclass = &#123;0&#125;;
    wndclass.hbrBackground=(HBRUSH)COLOR_BACKGROUND;//窗口背景色
    wndclass.lpszClassName=classname;// 窗口类名
    wndclass.hInstance=hInstance;//实例句柄
    wndclass.lpfnWndProc=WndProc;//窗口处理函数
    if(!RegisterClass(&amp;wndclass)) //注册一个窗口类，如果注册失败 发出警告
        &#123;MessageBeep(0); return FALSE;&#125;

    //2.第二步，创建并显示窗口
    HWND hWnd=CreateWindow(
        classname,
        TEXT(&quot;THE_ITACH1&quot;),
        WS_OVERLAPPEDWINDOW,
        100,
        100,
        300,
        150,
        NULL,
        NULL,
        hInstance,
        NULL);
    if(hWnd==NULL)//如果错误，返回错误参数。
    &#123;
        sprintf(szOutBuff,&quot;error: %d&quot;, GetLastError());
        OutputDebugString(szOutBuff);
    &#125;

    ShowWindow(hWnd,SW_SHOW);//显示这个窗口

    //3.第三步，接收消息并处理
    MSG msg;//定义MSG结构体，用来储存鼠标，键盘或者其他窗口产生的消息

    BOOL bRet;

    while((bRet=GetMessage(&amp;msg,hWnd,0,0))!=0)//用来接收鼠标，键盘或者其他窗口产生的消息，放到msg结构体里面
    &#123;
        if(bRet==-1)
        &#123;
            sprintf(szOutBuff,&quot;error: %d&quot;, GetLastError());
            OutputDebugString(szOutBuff);
        &#125;
        else
        &#123;
            TranslateMessage(&amp;msg);//将消息转换，例如键盘码转为字符型。
            DispatchMessage(&amp;msg);//将消息分发给内核，然后内核根据DefWindowProc来将消息传给应用程序进行处理。
        &#125;

    &#125;

    return 0;
&#125;

LRESULT CALLBACK WndProc( //WndProc名称可自由定义
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
&#123;
    return  DefWindowProc (hwnd, uMsg, wParam, lParam) ;//让系统来处理这些消息，下一节会讲自己来处理某些消息。
&#125;</code></pre>
<p>大致流程图<br><img src="https://i.loli.net/2021/03/16/ftYv7Cs8a3pBiqx.png"></p>
<h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>主要就讲键盘类的，也就是MSG那个结构体，下面是一个例子</p>
<pre><code>LRESULT CALLBACK WndProc( //WndProc名称可自由定义
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
&#123;
    //    sprintf(szOutBuff,&quot;消息: %x&quot;, uMsg);
    //    OutputDebugString(szOutBuff);

    switch (uMsg)
    &#123;
    case WM_DESTROY://点击关闭按钮时退出
        &#123;
            PostQuitMessage(0);
            return 0;
        &#125;

    case WM_KEYDOWN://当键盘按下
        &#123;

            return 0;
        &#125;

    case WM_CHAR://记录键盘按下的是什么
        &#123;
            char key[0x80];
            sprintf(key,&quot;消息: %c&quot;, wParam);
            OutputDebugString(key);
            return 0;
        &#125;

    &#125;
    return  DefWindowProc (hwnd, uMsg, wParam, lParam) ;
&#125;</code></pre>
<h3 id="子窗口"><a href="#子窗口" class="headerlink" title="子窗口"></a>子窗口</h3><p>利用window已有的一些窗口类来创建一些子窗口，例如文本框和按钮等</p>
<p>例子，加在相应位置就行了。</p>
<pre><code>//这3个是子窗口的编号，就相当于身份证一样
# define IDC_EDIT_1 0x100
# define IDC_BUTTON_1 0x101
# define IDC_BUTTON_2 0x102

char szOutBuff[50];
int i=0;
HINSTANCE g_hInstance;//由于hInstance在主函数是一个局部变量，而WndProc需要调用，所以设置为全局变量。

LRESULT CALLBACK WndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
&#123;
    switch (uMsg)
    &#123;
    case WM_DESTROY://点关闭键退出
        &#123;
            exit(0);
            return 0;
        &#125;

    case WM_COMMAND://这个是如果点击了窗口
        &#123;
            switch(LOWORD(wParam))//低16位就代表点击子窗口的编号。
            &#123;
            case IDC_BUTTON_1:
                &#123;
                    MessageBox(NULL,&quot;听说点1314次就会有flag&quot;,&quot;hint&quot;,MB_OK);
                    break;
                &#125;

            case IDC_BUTTON_2:
                &#123;
                    i++;
                    if(i==1314)
                    &#123;
                        sprintf(szOutBuff,&quot;flag&#123;love_you_%d&#125;&quot;,i);
                        SetDlgItemText(hwnd,IDC_EDIT_1,szOutBuff);
                    &#125;
                    break;
                &#125;
            &#125;

        &#125;

    case WM_CREATE:
        &#123;
            //创建一个文本框子窗口
            CreateWindow(
                &quot;EDIT&quot;,
                &quot;&quot;,
                WS_CHILD|WS_VISIBLE|ES_MULTILINE|WS_VSCROLL|WS_HSCROLL,
                0,
                0,
                500,
                360,
                hwnd,
                (HMENU)IDC_EDIT_1,
                g_hInstance,
                NULL);

            //创建两个按钮的子窗口
            CreateWindow(
                &quot;BUTTON&quot;,
                &quot;提示&quot;,
                WS_CHILD|WS_VISIBLE,
                510,
                200,
                40,
                30,
                hwnd,
                (HMENU)IDC_BUTTON_1,
                g_hInstance,
                NULL);

            CreateWindow(
                &quot;BUTTON&quot;,
                &quot;FLAG&quot;,
                WS_CHILD|WS_VISIBLE,
                510,
                250,
                40,
                30,
                hwnd,
                (HMENU)IDC_BUTTON_2,
                g_hInstance,
                NULL);
            break;
        &#125;

    &#125;
    return  DefWindowProc (hwnd, uMsg, wParam, lParam) ;
&#125;</code></pre>
<h3 id="虚拟内存与物理内存"><a href="#虚拟内存与物理内存" class="headerlink" title="虚拟内存与物理内存"></a>虚拟内存与物理内存</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lvyibin890/article/details/82217193">https://blog.csdn.net/lvyibin890/article/details/82217193</a></p>
<h3 id="私有内存的申请与释放"><a href="#私有内存的申请与释放" class="headerlink" title="私有内存的申请与释放"></a>私有内存的申请与释放</h3><p>之前我们用malloc申请的堆内存空间实际上是假申请，这些空间本来就已经申请好了的。而实际申请内存的方式有两种。</p>
<ol>
<li>通过VitualAlloc/通过VitualAllocEx申请的：Private Memory</li>
<li>通过CreateFileMapping映射的：Mapped Memory</li>
</ol>
<p>现在主要讲第一种，先来看看相关函数</p>
<p><strong>VirtualAlloc()</strong></p>
<p>该函数的功能是在调用进程的虚地址空间,预定或者提交一部分页。<br>简单点的意思就是申请内存空间</p>
<pre><code>LPVOID VirtualAlloc&#123;
    LPVOID lpAddress, // 要分配的内存区域的地址
    DWORD dwSize, // 分配的大小
    DWORD flAllocationType, // 分配的类型
    DWORD flProtect // 该内存的初始保护属性
&#125;;</code></pre>
<p><strong>VirtualAllocEx()API</strong></p>
<p>在<strong>指定进程</strong>的虚拟空间保留或提交内存区域</p>
<pre><code>LPVOID VirtualAllocEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
);
hProcess：申请内存所在的进程句柄。

lpAddress：保留页面的内存地址；一般用NULL自动分配 。

dwSize：欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍

flAllocationType
可取下列值：
MEM_COMMIT：为特定的页面区域分配内存中或磁盘的页面文件中的物理存储
MEM_PHYSICAL ：分配物理内存（仅用于地址窗口扩展内存）
MEM_RESERVE：保留进程的虚拟地址空间，而不分配任何物理存储。保留页面可通过继续调用VirtualAlloc（）而被占用
MEM_RESET ：指明在内存中由参数lpAddress和dwSize指定的数据无效
MEM_TOP_DOWN：在尽可能高的地址上分配内存（Windows 98忽略此标志）
MEM_WRITE_WATCH：必须与MEM_RESERVE一起指定，使系统跟踪那些被写入分配区域的页面（仅针对Windows 98）

flProtect
可取下列值：
PAGE_READONLY： 该区域为只读。如果应用程序试图访问区域中的页的时候，将会被拒绝访
PAGE_READWRITE 区域可被应用程序读写
PAGE_EXECUTE： 区域包含可被系统执行的代码。试图读写该区域的操作将被拒绝。
PAGE_EXECUTE_READ ：区域包含可执行代码，应用程序可以读该区域。
PAGE_EXECUTE_READWRITE： 区域包含可执行代码，应用程序可以读写该区域。
PAGE_GUARD： 区域第一次被访问时进入一个STATUS_GUARD_PAGE异常，这个标志要和其他保护标志合并使用，表明区域被第一次访问的权限
PAGE_NOACCESS： 任何访问该区域的操作将被拒绝
PAGE_NOCACHE： RAM中的页映射到该区域时将不会被微处理器缓存（cached)
注:PAGE_GUARD和PAGE_NOCHACHE标志可以和其他标志合并使用以进一步指定页的特征。PAGE_GUARD标志指定了一个防护页（guard page），即当一个页被提交时会因第一次被访问而产生一个one-shot异常，接着取得指定的访问权限。PAGE_NOCACHE防止当它映射到虚拟页的时候被微处理器缓存。这个标志方便设备驱动使用直接内存访问方式（DMA）来共享内存块。
返回值：
执行成功就返回分配内存的首地址，不成功就是NULL。</code></pre>
<p>例子可以参考DLL注入文章。</p>
<p><strong>VirtualFree()</strong><br>VirtualFree该函数的功能是取消或者释放调用进程的虚地址空间页的一个区域。</p>
<pre><code>BOOL VirtualFree(
    LPVOID lpAddress, // 区域地址
    SIZE_T dwSize，// 区域大小，字节
    DWORD dwFreeType // 类型
);</code></pre>
<p><strong>VirtualFreeEx()</strong></p>
<p>VirtualFreeEx即为目标进程的句柄，可在其它进程中释放申请的虚拟内存空间。</p>
<pre><code>BOOL VirtualFreeEx&#123;
HANDLE hProcess, // 要释放内存所在进程的句柄
LPVOID lpAddress, // 区域地址
DWORD dwSize, // 区域大小，字节
DWORD dwFreeType //类型
&#125;;
如果 dwFreeType 为 MEM_RELEASE，则 dwSize 必须为0 . 按 VirtualAllocEx申请时的大小全部释放。
如果dwFreeType 为 MEM_DECOMMIT, 则释放从lpAddress 开始的一个或多个字节 ，即 lpAddress +dwSize。</code></pre>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。</p>
<h4 id="卷相关API："><a href="#卷相关API：" class="headerlink" title="卷相关API："></a>卷相关API：</h4><p><strong>GetLogicalDrives()</strong></p>
<p>作用为判断系统中存在哪些逻辑驱动器字母。</p>
<pre><code>DWORD GetLogicalDrives(void);</code></pre>
<p>一般情况下DWORD的数据长度是32位，在这个DWORD中，每一位对应了一个逻辑驱动器是否存在。第二位如果是“1”则表示驱动器“B:”存在，第四位如果是“1”则表示驱动器“D:”存在，以此类推。例如44，换为二进制00101100，就代表有C,D,F盘。<br><strong>GetLogicalDriveStrings()</strong></p>
<p>GetLogicalDriveStrings，获取一个字串，其中包含了当前所有逻辑驱动器的根驱动器路径。</p>
<pre><code>DWORD GetLogicalDriveStrings(
    DWORD nBufferLength, // size of buffer
    LPTSTR lpBuffer // drive strings buffer
);
就是盘的字符串会存到lpBuffer里面，C:\ D:\ F:\</code></pre>
<p><strong>GetDriveType()</strong></p>
<p>GetDriveType是程序中的一种函数类型，这个GetDriveType函数是用来确定磁盘驱动器是可移动的、固定的、CD-ROM、RAM磁盘还是网络驱动器。</p>
<pre><code>UINT GetDriveType(
    LPCTSTR lpRootPathName //根目录路径的字符串指针
);
返回值,宏，是数字，对应下面的类型
DRIVE_UNKNOWN 未知的磁盘类型
DRIVE_NO_ROOT_DIR 说明lpRootPathName是无效的
DRIVE_REMOVABLE 可移动磁盘
DRIVE_FIXED 固定磁盘
DRIVE_REMOTE 网络磁盘
DRIVE_CDROM 光驱
DRIVE_RAMDISK 为RAM</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">The_Itach1</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/03/30/win32%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2021/03/30/win32%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/03/30/n7siDC4uFlg8SLv.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/09/%E8%99%8E%E7%AC%A6ctf&amp;%E7%BA%A2%E6%98%8E%E8%B0%B7%E7%9A%84wp/"><img class="prev-cover" src="https://i.loli.net/2021/04/09/vfNLV8F2DPyglKH.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">虎符ctf的wp&amp;红明谷杯的wp</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/27/nepctf&amp;dasctf/"><img class="next-cover" src="https://i.loli.net/2021/03/27/KyLuMPlxOjEU159.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">nepctf&amp;dasctf的wp</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/5.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">The_Itach1</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">23</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#win32-API%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">win32 API编程学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#win32%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">win32的变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#win32%E4%B8%AD%E7%9A%84%E5%AE%BD%E5%AD%97%E7%AC%A6"><span class="toc-number">1.2.</span> <span class="toc-text">win32中的宽字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">进程的创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">创建进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E4%B8%8Eid"><span class="toc-number">1.5.</span> <span class="toc-text">句柄与id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3API"><span class="toc-number">1.6.</span> <span class="toc-text">进程相关API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text">和线程相关的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.</span> <span class="toc-text">临界区-多线程调用全局变量产生的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93"><span class="toc-number">1.10.</span> <span class="toc-text">互斥体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.11.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAwindows%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.12.</span> <span class="toc-text">第一个windows程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.13.</span> <span class="toc-text">消息类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%AA%97%E5%8F%A3"><span class="toc-number">1.14.</span> <span class="toc-text">子窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-number">1.15.</span> <span class="toc-text">虚拟内存与物理内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-number">1.16.</span> <span class="toc-text">私有内存的申请与释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.17.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B7%E7%9B%B8%E5%85%B3API%EF%BC%9A"><span class="toc-number">1.17.1.</span> <span class="toc-text">卷相关API：</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/30/DASCTF%20X%20BUUOJ%20%E4%BA%94%E6%9C%88%20re%20wp/" title="DASCTF X BUUOJ 五月 re wp"><img src="https://i.loli.net/2021/05/30/LRWczkmhOyE7ToY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DASCTF X BUUOJ 五月 re wp"/></a><div class="content"><a class="title" href="/2021/05/30/DASCTF%20X%20BUUOJ%20%E4%BA%94%E6%9C%88%20re%20wp/" title="DASCTF X BUUOJ 五月 re wp">DASCTF X BUUOJ 五月 re wp</a><time datetime="2021-05-30T15:18:18.384Z" title="Created 2021-05-30 23:18:18">2021-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/27/%E5%B7%9D%E4%BC%A0ctf%E7%BA%BF%E4%B8%8A%20%20re%20wp/" title="川传ctf线上 re wp"><img src="https://i.loli.net/2021/05/27/s6n9tlUK7DhLd3P.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="川传ctf线上 re wp"/></a><div class="content"><a class="title" href="/2021/05/27/%E5%B7%9D%E4%BC%A0ctf%E7%BA%BF%E4%B8%8A%20%20re%20wp/" title="川传ctf线上 re wp">川传ctf线上 re wp</a><time datetime="2021-05-27T14:32:01.135Z" title="Created 2021-05-27 22:32:01">2021-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/25/Neepu%20ctf%20wp/" title="Neepu ctf wp"><img src="https://i.loli.net/2021/05/27/3FDLjRQNKbSsZHn.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Neepu ctf wp"/></a><div class="content"><a class="title" href="/2021/05/25/Neepu%20ctf%20wp/" title="Neepu ctf wp">Neepu ctf wp</a><time datetime="2021-05-25T08:22:44.360Z" title="Created 2021-05-25 16:22:44">2021-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/2021%20%E6%B4%A5%E9%97%A8%E6%9D%AF&amp;%E7%BA%A2%E5%B8%BD%E6%9D%AFre%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/" title="2021 津门杯&amp;红帽杯re部分复现"><img src="https://i.loli.net/2021/05/15/IC59wnV4hfQlcAD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021 津门杯&amp;红帽杯re部分复现"/></a><div class="content"><a class="title" href="/2021/05/15/2021%20%E6%B4%A5%E9%97%A8%E6%9D%AF&amp;%E7%BA%A2%E5%B8%BD%E6%9D%AFre%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/" title="2021 津门杯&amp;红帽杯re部分复现">2021 津门杯&amp;红帽杯re部分复现</a><time datetime="2021-05-15T13:17:33.813Z" title="Created 2021-05-15 21:17:33">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/20l21%E5%B9%B4%E5%9B%9B%E5%B7%9D%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%20%20writeup/" title="2021 四川省大学生大赛 wp"><img src="https://i.loli.net/2021/05/15/Eran1WOK8LZmQXw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021 四川省大学生大赛 wp"/></a><div class="content"><a class="title" href="/2021/05/15/20l21%E5%B9%B4%E5%9B%9B%E5%B7%9D%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%20%20writeup/" title="2021 四川省大学生大赛 wp">2021 四川省大学生大赛 wp</a><time datetime="2021-05-15T13:04:05.204Z" title="Created 2021-05-15 21:04:05">2021-05-15</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://i.loli.net/2021/03/30/n7siDC4uFlg8SLv.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By The_Itach1</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">木叶飞舞之处，火亦生生不息</div><div class="icp"><a><span></span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>