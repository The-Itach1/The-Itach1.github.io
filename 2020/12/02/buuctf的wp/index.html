<!DOCTYPE html><html lang="zh-CH" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>buuCTF的wp | The_Itach1</title><meta name="author" content="The_Itach1"><meta name="copyright" content="The_Itach1"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="buuCTF的wp前言，主要是re方向的题，应该会持续更新，更新时间不定 re方向1.easyre签到题，直接用ida打开，shift+12查看字符串，如下  得到flag：flag{this_Is_a_EaSyRe} 2.reverse1f5看关键代码如下   sub_1400111D1(&quot;input the flag:&quot;);   sub_14001128F(&quot;%2">
<meta property="og:type" content="article">
<meta property="og:title" content="buuCTF的wp">
<meta property="og:url" content="http://example.com/2020/12/02/buuctf%E7%9A%84wp/index.html">
<meta property="og:site_name" content="The_Itach1">
<meta property="og:description" content="buuCTF的wp前言，主要是re方向的题，应该会持续更新，更新时间不定 re方向1.easyre签到题，直接用ida打开，shift+12查看字符串，如下  得到flag：flag{this_Is_a_EaSyRe} 2.reverse1f5看关键代码如下   sub_1400111D1(&quot;input the flag:&quot;);   sub_14001128F(&quot;%2">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="https://i.loli.net/2020/12/02/GBH9cj7JztSasMh.jpg">
<meta property="article:published_time" content="2020-12-01T16:40:18.338Z">
<meta property="article:modified_time" content="2021-03-02T16:29:53.481Z">
<meta property="article:author" content="The_Itach1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/12/02/GBH9cj7JztSasMh.jpg"><link rel="shortcut icon" href="/img/2.png"><link rel="canonical" href="http://example.com/2020/12/02/buuctf%E7%9A%84wp/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-03 00:29:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">44</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> music</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> movies</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/12/02/GBH9cj7JztSasMh.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">The_Itach1</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> music</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> movies</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">buuCTF的wp</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-12-01T16:40:18.338Z" title="Created 2020-12-02 00:40:18">2020-12-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-03-02T16:29:53.481Z" title="Updated 2021-03-03 00:29:53">2021-03-03</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="buuCTF的wp"><a href="#buuCTF的wp" class="headerlink" title="buuCTF的wp"></a>buuCTF的wp</h1><p>前言，主要是re方向的题，应该会持续更新，更新时间不定</p>
<h2 id="re方向"><a href="#re方向" class="headerlink" title="re方向"></a>re方向</h2><h3 id="1-easyre"><a href="#1-easyre" class="headerlink" title="1.easyre"></a>1.easyre</h3><p>签到题，直接用ida打开，shift+12查看字符串，如下</p>
<p><img src="https://i.loli.net/2020/12/01/qDwBnOEH59uTRzc.png"></p>
<p>得到flag：flag{this_Is_a_EaSyRe}</p>
<h3 id="2-reverse1"><a href="#2-reverse1" class="headerlink" title="2.reverse1"></a>2.reverse1</h3><p>f5看关键代码如下</p>
<pre><code>  sub_1400111D1(&quot;input the flag:&quot;);
  sub_14001128F(&quot;%20s&quot;, &amp;Str1);
  v3 = j_strlen(Str2);
  if ( !strncmp(&amp;Str1, Str2, v3) )//意思是输入的flag是str1，当str1和str2相等是就是正确的
    sub_1400111D1(&quot;this is the right flag!\n&quot;);
  else
    sub_1400111D1(&quot;wrong flag\n&quot;);
  sub_14001113B(&amp;v5, &amp;unk_140019D00);
  return 0i64;</code></pre>
<p>str2点开是{hello_world}，然后上面有个点是要把o改为0，所以flag：flag{hell0_w0rld}</p>
<h3 id="3-reverse2"><a href="#3-reverse2" class="headerlink" title="3.reverse2"></a>3.reverse2</h3><p>打开IDA，F5看关键代码。<br><img src="https://i.loli.net/2020/12/01/sm2Dlgq7XhEiAQT.png"><br>将圈出来的代码用R键，得到<br><img src="https://i.loli.net/2020/12/01/HydgV5OGMrB6a9i.png"><br>图片中说错了，应该是要把flag中的i和r改为1</p>
<p>点开&amp;flag，得到关键代码</p>
<pre><code>.data:0000000000601080 flag            db &#39;&#123;&#39;//这个&#123;也要用R键才看得到                  ; DATA XREF: main+34↑r
.data:0000000000601080                                         ; main+44↑r ...
.data:0000000000601081 aHackingForFun  db &#39;hacking_for_fun&#125;&#39;,0
.data:0000000000601081 _data           ends</code></pre>
<p>flag中的i和r改为1，最后得到flag：flag{hack1ng_fo1_fun}</p>
<h3 id="4-内涵的软件"><a href="#4-内涵的软件" class="headerlink" title="4.内涵的软件"></a>4.内涵的软件</h3><p>根据提示可能是一个upx加壳的软件，用PEID打开<br>直接IDA打开查看字符串，得到flag：flag{49d3c93df25caad81232130f3d2ebfad}</p>
<h3 id="5-新年快乐"><a href="#5-新年快乐" class="headerlink" title="5.新年快乐"></a>5.新年快乐</h3><p>用ida打开什么也没有，用PEID打开<br><img src="https://i.loli.net/2020/12/01/4OUJFh1BGS5xaXP.png"><br>发现是个upx加壳的东西，用upx解壳，将upx.exe和该文件一起放在D盘下，再在cmd里面执行命令。<br><img src="https://i.loli.net/2020/12/01/xRlQrDfWP3jB19N.png"><br>原来21kb的文件变成了28kb，再用ida打开，得到重要代码</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
&#123;
  int result; // eax
  char Str2; // [esp+12h] [ebp-3Ah]
  char Str1[2]; // [esp+20h] [ebp-2Ch]
  char v6; // [esp+22h] [ebp-2Ah]

  __main();
  strcpy(&amp;Str2, &quot;HappyNewYear!&quot;);
  *(_WORD *)Str1 = 0;
  memset(&amp;v6, 0, 0x1Eu);
  printf(&quot;please input the true flag:&quot;);
  scanf(&quot;%s&quot;, Str1);
  if ( !strncmp(Str1, &amp;Str2, strlen(&amp;Str2)) )//str1是输入的flag，这个str1要和str2相等
    result = puts(&quot;this is true flag!&quot;);
  else
    result = puts(&quot;wrong!&quot;);
  return result;
&#125;</code></pre>
<p>所以flag就是：flag{HappyNewYear!}</p>
<h3 id="6-BJDCTF-2nd-guessgame"><a href="#6-BJDCTF-2nd-guessgame" class="headerlink" title="6.[BJDCTF 2nd]guessgame"></a>6.[BJDCTF 2nd]guessgame</h3><p>ida打开，得到flag：BJD{S1mple_ReV3r5e_W1th_0D_0r_IDA}</p>
<h3 id="7-helloword"><a href="#7-helloword" class="headerlink" title="7.helloword"></a>7.helloword</h3><p>下载下来发现是个apk文件，直接解压，得到几个文件<br><img src="https://i.loli.net/2020/12/02/5SVUNYab2XzFgyp.png"><br>可以把那个文件后缀名直接改txt，然后搜索flag，也可以用jeb软件打开，然后搜索字符串得到<br>flag{7631a988259a00816deda84afb29430a}</p>
<h3 id="8-xor"><a href="#8-xor" class="headerlink" title="8.xor"></a>8.xor</h3><p>考点 数组内异或</p>
<p>ida打开，找到主要函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
&#123;
  char *v3; // rsi
  int result; // eax
  signed int i; // [rsp+2Ch] [rbp-124h]
  char v6[264]; // [rsp+40h] [rbp-110h]
  __int64 v7; // [rsp+148h] [rbp-8h]

  memset(v6, 0, 0x100uLL);
  v3 = (char *)256;
  printf(&quot;Input your flag:\n&quot;, 0LL);
  get_line(v6, 256LL);//v6是输入的flag
  if ( strlen(v6) != 33 )//输入的flag长度为33
    goto LABEL_12;
  for ( i = 1; i &lt; 33; ++i )
    v6[i] ^= v6[i - 1];         //数组异或，可以自己举三个数，然后进行异或，然后在看看怎么异或回去。
  v3 = global;
  if ( !strncmp(v6, global, 0x21uLL) ) //global要和异或v6相等，要自己去找global的值。
    printf(&quot;Success&quot;, v3);
  else
LABEL_12:
    printf(&quot;Failed&quot;, v3);
  result = __stack_chk_guard;
  if ( __stack_chk_guard == v7 )
    result = 0;
  return result;
&#125;</code></pre>
<p>global为f\nk\fw&amp;O.@\x11x\rZ;U\x11p\x19F\x1Fv&quot;M#D\x0Eg\x06h\x0FG2O，可以在Python中用list改善一下’f’, ‘\n’, ‘k’, ‘\x0c’, ‘w’, ‘&amp;’, ‘O’, ‘.’, ‘@’, ‘\x11’, ‘x’, ‘\r’, ‘Z’, ‘;’, ‘U’, ‘\x11’, ‘p’, ‘\x19’, ‘F’, ‘\x1f’, ‘v’, ‘“‘, ‘M’, ‘#’, ‘D’, ‘\x0e’, ‘g’, ‘\x06’, ‘h’, ‘\x0f’, ‘G’, ‘2’, ‘O’</p>
<p>开始写脚本</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int i;
    char a[]=&#123;&#39;f&#39;, &#39;\n&#39;, &#39;k&#39;, &#39;\x0c&#39;, &#39;w&#39;, &#39;&amp;&#39;, &#39;O&#39;, &#39;.&#39;, &#39;@&#39;, &#39;\x11&#39;, &#39;x&#39;, &#39;\r&#39;, &#39;Z&#39;, &#39;;&#39;, &#39;U&#39;, &#39;\x11&#39;, &#39;p&#39;, &#39;\x19&#39;, &#39;F&#39;, &#39;\x1f&#39;, &#39;v&#39;, &#39;&quot;&#39;, &#39;M&#39;, &#39;#&#39;, &#39;D&#39;, &#39;\x0e&#39;, &#39;g&#39;, &#39;\x06&#39;, &#39;h&#39;, &#39;\x0f&#39;, &#39;G&#39;, &#39;2&#39;, &#39;O&#39;&#125;;

    for(i=32;i!=0;i--)
    &#123;
        a[i]=a[i]^a[i-1];
     &#125; 

    for(i=0;i&lt;33;i++)
    &#123;
        printf(&quot;%c&quot;,a[i]);
    &#125;
 &#125; </code></pre>
<p>得到flag{QianQiuWanDai_YiTongJiangHu}</p>
<h3 id="9-reverse3"><a href="#9-reverse3" class="headerlink" title="9.reverse3"></a>9.reverse3</h3><p>用ida打开，找到主要函数</p>
<pre><code>  int v3; // edx
  __int64 v4; // ST08_8
  signed int j; // [esp+DCh] [ebp-ACh]
  signed int i; // [esp+E8h] [ebp-A0h]
  signed int v8; // [esp+E8h] [ebp-A0h]
  char Dest[108]; // [esp+F4h] [ebp-94h]
  char Str; // [esp+160h] [ebp-28h]
  char v11; // [esp+17Ch] [ebp-Ch]

  for ( i = 0; i &lt; 100; ++i )
  &#123;
    if ( (unsigned int)i &gt;= 0x64 )
      j____report_rangecheckfailure();
    Dest[i] = 0;
  &#125;
  sub_41132F(&quot;please enter the flag:&quot;);
  sub_411375(&quot;%20s&quot;, &amp;Str);//输入的flag
  v0 = j_strlen(&amp;Str);
  v1 = (const char *)sub_4110BE(&amp;Str, v0, &amp;v11);//对输入的flag进行了没有改表的base编码，可以直接用网上在线base64解码。
  strncpy(Dest, v1, 0x28u);//将v1给了Dest
  v8 = j_strlen(Dest);
  for ( j = 0; j &lt; v8; ++j )//对Dest进行了一个简单加密。
    Dest[j] += j;
  v2 = j_strlen(Dest);
  if ( !strncmp(Dest, Str2, v2) )//将Dest和str2比较，就是要一样
    sub_41132F(&quot;rigth flag!\n&quot;);
  else
    sub_41132F(&quot;wrong flag!\n&quot;);
  HIDWORD(v4) = v3;
  LODWORD(v4) = 0;
  return v4;
&#125;</code></pre>
<p>先找到str2=‘e3nifIH9b_C@n@dH’，用这个来得到，解密后的Dest，脚本如下</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    char a[]=&#123;&#39;e&#39;, &#39;3&#39;, &#39;n&#39;, &#39;i&#39;, &#39;f&#39;, &#39;I&#39;, &#39;H&#39;, &#39;9&#39;, &#39;b&#39;, &#39;_&#39;, &#39;C&#39;, &#39;@&#39;, &#39;n&#39;, &#39;@&#39;, &#39;d&#39;, &#39;H&#39;&#125;;
    int i;

    for(i=0;i&lt;16;i++)
    &#123;
        a[i]=a[i]-i;
     &#125; 
    for(i=0;i&lt;16;i++)
    &#123;
        printf(&quot;%c&quot;,a[i]);
    &#125;

&#125;</code></pre>
<p>得到Dest=‘e2lfbDB2ZV95b3V9’，由于是未改表的base编码，所以可以直接用网上在线解码，得到flag{i_l0ve_you}</p>
<h3 id="10-不一样的flag"><a href="#10-不一样的flag" class="headerlink" title="10.不一样的flag"></a>10.不一样的flag</h3><p>考点，迷宫题。</p>
<p>直接打开，叫你输入1，2,3,4，分别代表上下左右。<br><img src="https://i.loli.net/2020/12/02/nQgbhIyUVGR1aJH.png"><br>有耐心的话可以一次一次试，只要输入对了，就会继续你输入，直到无论你输入那个数都是直接退出，将输入的数组合起来就是flag。</p>
<p>用ida查看源代码。</p>
<pre><code>int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
&#123;
  char v3; // [esp+17h] [ebp-35h]
  int v4; // [esp+30h] [ebp-1Ch]
  int v5; // [esp+34h] [ebp-18h]
  int v6; // [esp+38h] [ebp-14h]
  int i; // [esp+3Ch] [ebp-10h]
  char v8[12]; // [esp+40h] [ebp-Ch]

  __main();
  v4 = 0;
  v5 = 0;
  qmemcpy(&amp;v3, _data_start__, 0x19u);
  while ( 1 )
  &#123;
    puts(&quot;you can choose one action to execute&quot;);
    puts(&quot;1 up&quot;);
    puts(&quot;2 down&quot;);
    puts(&quot;3 left&quot;);
    printf(&quot;4 right\n:&quot;);
    scanf(&quot;%d&quot;, &amp;v6);//你输入的数，也就是flag

    ————————————————————————————————————————————————
    if ( v6 == 2 )
    &#123;
      ++v4;
    &#125;
    else if ( v6 &gt; 2 )
    &#123;
      if ( v6 == 3 )
      &#123;
        --v5;
      &#125;
      else
      &#123;
        if ( v6 != 4 )
LABEL_13:
          exit(1);
        ++v5;
      &#125;
    &#125;
    else
    &#123;
      if ( v6 != 1 )
        goto LABEL_13;
      --v4;
    &#125;
    for ( i = 0; i &lt;= 1; ++i )
    &#123;
      if ( *(&amp;v4 + i) &lt; 0 || *(&amp;v4 + i) &gt; 4 )
        exit(1);
    &#125;
    if ( v8[5 * v4 - 41 + v5] == 49 )
      exit(1);
    if ( v8[5 * v4 - 41 + v5] == 35 )
    &#123;
      puts(&quot;\nok, the order you enter is the flag!&quot;);
      exit(0);
    &#125;//这一整段就是要通过你输入的一个个数字，使最后一个if调键满足，那个35实际上就是‘#’，也就是迷宫的终点，而49就是迷宫中的‘1’，不能碰到。
——————————————————————————————————————————————————————————
  &#125;
&#125;</code></pre>
<p>真正的迷宫在字符串中</p>
<pre><code>&#39;*11110100001010000101111#&#39;//25个数，盲猜5*5</code></pre>
<p>用脚本画出迷宫</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int a[5][5]=&#123;&#39;*&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;#&#39;&#125;;
    int i,j;

    for(i=0;i&lt;5;i++)
    &#123;
        for(j=0;j&lt;5;j++)
        &#123;
        printf(&quot;%c&quot;,a[i][j]);
        &#125;
        printf(&quot;\n&quot;);
    &#125;    
 &#125; </code></pre>
<p>得到迷宫</p>
<pre><code>*1111
01000
01010
00010
1111#</code></pre>
<p>根据1，2,3,4四个反向得到flag{222441144222}</p>
<h3 id="11-SimpleRev"><a href="#11-SimpleRev" class="headerlink" title="11.SimpleRev"></a>11.SimpleRev</h3><p>关键代码如下，要熟悉ascall码表中A<del>Z,a</del>z的十进制数</p>
<pre><code>unsigned __int64 Decry()
&#123;
  char v1; // [rsp+Fh] [rbp-51h]
  int v2; // [rsp+10h] [rbp-50h]
  int v3; // [rsp+14h] [rbp-4Ch]
  int i; // [rsp+18h] [rbp-48h]
  int v5; // [rsp+1Ch] [rbp-44h]
  char src[8]; // [rsp+20h] [rbp-40h]
  __int64 v7; // [rsp+28h] [rbp-38h]
  int v8; // [rsp+30h] [rbp-30h]
  __int64 v9; // [rsp+40h] [rbp-20h]
  __int64 v10; // [rsp+48h] [rbp-18h]
  int v11; // [rsp+50h] [rbp-10h]
  unsigned __int64 v12; // [rsp+58h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  *(_QWORD *)src = 357761762382LL;//src=&#39;SLCDN&#39;
  v7 = 0LL;
  v8 = 0;
  v9 = 512969957736LL;//v9=&#39;wodah&#39;
  v10 = 0LL;
  v11 = 0;
  text = (char *)join(key3, &amp;v9);// key3=&#39;kills&#39;    test=key3+v9=‘killshadow’  
  strcpy(key, key1);// Key1=&#39;ADSFK&#39;
  strcat(key, src);//Key=&#39;ADSFKNDCLS&#39;   注意要倒过来
  v2 = 0;
  v3 = 0;
  getchar();
  v5 = strlen(key);
  for ( i = 0; i &lt; v5; ++i )
  &#123;
    if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 )
      key[i] = key[v3 % v5] + 32;
    ++v3;
  &#125;//将key全部换为小写。
  printf(&quot;Please input your flag:&quot;, src);
  while ( 1 )
  &#123;
    v1 = getchar();//V1就是输入的flag，根据下面的if条件只能算出v1的范围为64~90,97~122，涉及到下面%求余的整数部分的问题。
    if ( v1 == 10 )
      break;
    if ( v1 == 32 )
    &#123;
      ++v2;
    &#125;
    else
    &#123;
      if ( v1 &lt;= 96 || v1 &gt; 122 )
      &#123;
        if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 )
          str2[v2] = (v1 - 39 - key[v3++ % v5] + 97) % 26 + 97;//加密语句
      &#125;
      else
      &#123;
        str2[v2] = (v1 - 39 - key[v3++ % v5] + 97) % 26 + 97;
      &#125;
      if ( !(v3 % v5) )
        putchar(32);
      ++v2;
    &#125;
  &#125;
  if ( !strcmp(text, str2) )//要求text=str2
    puts(&quot;Congratulation!\n&quot;);
  else
    puts(&quot;Try again!\n&quot;);
  return __readfsqword(0x28u) ^ v12;
&#125;</code></pre>
<p>感觉这道题有点问题，v1的范围有点没确定好，也可能是我忽略了某个地方。</p>
<p>脚本如下</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    char a[11]=&quot;ADSFKNDCLS&quot;;
    char b[11]=&quot;killshadow&quot;;
    char c[11]=&quot;\0&quot;;
    int i=0,j=0;

    for(i=0;i&lt;11;i++,j++)
    &#123;
        if( a[j % 11] &gt; 64 &amp;&amp; a[j % 11] &lt;= 90)
            a[i] = a[j % 10] + 32;//这个里面的j%11实际上就相当于i，只是在ida中打开变了样子。

        printf(&quot;%c&quot;,a[i]);
    &#125;
    printf(&quot;\n&quot;);
    for(i=0;i&lt;10;i++)
    &#123;
        c[i]=(b[i]-97)+26+39-97+a[i];//因为不知道原加密语句求余的那个整数是多少所以只加了一个26， 
        if(c[i]&gt;90)
        &#123;
            c[i]=c[i]-26;
        &#125;//加上这个主要是要所有字母都是大写的，不然会有乱码 
        printf(&quot;%c&quot;,c[i]);
    &#125;

&#125;</code></pre>
<h3 id="12-BJDCTF-2nd-8086"><a href="#12-BJDCTF-2nd-8086" class="headerlink" title="12.[BJDCTF 2nd]8086"></a>12.[BJDCTF 2nd]8086</h3><p>根据文件名字，得知应该这是8086的32位汇编。</p>
<p>用ida打开，shift+12打开字符串，发现只有一句点进去，得到<br><img src="https://i.loli.net/2020/12/04/8Y4HGznopkUrJ6N.png"><br>查看重要代码如下<br><img src="https://i.loli.net/2020/12/04/bCYGyJsphdlPa42.png"><br>根据这个分析开始写脚本，如下</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int i;
    char a[]=&#123;&#39;]&#39;, &#39;U&#39;, &#39;[&#39;, &#39;d&#39;, &#39;u&#39;, &#39;~&#39;, &#39;|&#39;, &#39;t&#39;, &#39;@&#39;, &#39;&#123;&#39;, &#39;z&#39;, &#39;@&#39;, &#39;w&#39;, &#39;j&#39;, &#39;.&#39;, &#39;&#125;&#39;, &#39;.&#39;, &#39;~&#39;, &#39;q&#39;, &#39;@&#39;, &#39;g&#39;, &#39;j&#39;, &#39;z&#39;, &#39;&#123;&#39;, &#39;z&#39;, &#39;@&#39;, &#39;w&#39;, &#39;z&#39;, &#39;q&#39;, &#39;W&#39;, &#39;~&#39;, &#39;/&#39;, &#39;b&#39;, &#39;;&#39;&#125;;

    for(i=0;i&lt;33;i++)
    &#123;
        a[i]=a[i]^0x1f;
        printf(&quot;%c&quot;,a[i]);
    &#125;
&#125; </code></pre>
<p>得到 flag：BJD{jack_de_hu1b1an_xuede_henHa0}</p>
<h3 id="13-GKCTF2020-Check-1n"><a href="#13-GKCTF2020-Check-1n" class="headerlink" title="13.[GKCTF2020]Check_1n"></a>13.[GKCTF2020]Check_1n</h3><p>这道题，首先明确一点，这是签到题，所以不会太难</p>
<p>先运行出来，发现是一个用c++写的一个代码电脑文件</p>
<pre><code>↑ ↓ ← → 空格    进行操作</code></pre>
<p>先开机，发现需要密码，打开ida，看字符串。<br><img src="https://i.loli.net/2020/12/04/EsDbhZI2LOXc9Yo.png"><br>开机后发现有几个文件，其中有一个叫flag，打开<br><img src="https://i.loli.net/2020/12/04/EC6vOHNWlI4Tgoj.png"><br>发现<br><img src="https://i.loli.net/2020/12/04/HVFQe5Yas9T7RjD.png"><br>解码内容为</p>
<pre><code>Why don&#39;t you try the magic brick game
你为什么不试试魔法砖游戏</code></pre>
<p>然后去玩魔法砖游戏<br><img src="https://i.loli.net/2020/12/04/p49BTOFKwjWnHCo.png"><br><img src="https://i.loli.net/2020/12/04/F9hGRyxNvgaOPuH.png"><br>得到flag{f5dfd0f5-0343-4642-8f28-9adbb74c4ede}回头看看这<br><img src="https://i.loli.net/2020/12/04/RBQA4PktCTzs1hb.png"></p>
<h3 id="14-findit"><a href="#14-findit" class="headerlink" title="14.findit"></a>14.findit</h3><p>下载下来发现是个apk文件，用jeb打开。<br><img src="https://i.loli.net/2020/12/04/zRdCLm1tkaNJTHr.png"><br>发现重要线索</p>
<pre><code> this.findViewById(0x7F05003D).setOnClickListener(new View$OnClickListener(new char[]&#123;&#39;T&#39;, &#39;h&#39;, &#39;i&#39;, &#39;s&#39;, &#39;I&#39;, &#39;s&#39;, &#39;T&#39;, &#39;h&#39;, &#39;e&#39;, &#39;F&#39;, &#39;l&#39;, &#39;a&#39;, &#39;g&#39;, &#39;H&#39;, &#39;o&#39;, &#39;m&#39;, &#39;e&#39;&#125;, this.findViewById(0x7F05003E), new char[]&#123;&#39;p&#39;, &#39;v&#39;, &#39;k&#39;, &#39;q&#39;, &#39;&#123;&#39;, &#39;m&#39;, &#39;1&#39;, &#39;6&#39;, &#39;4&#39;, &#39;6&#39;, &#39;7&#39;, &#39;5&#39;, &#39;2&#39;, &#39;6&#39;, &#39;2&#39;, &#39;0&#39;, &#39;3&#39;, &#39;3&#39;, &#39;l&#39;, &#39;4&#39;, &#39;m&#39;, &#39;4&#39;, &#39;9&#39;, &#39;l&#39;, &#39;n&#39;, &#39;p&#39;, &#39;7&#39;, &#39;p&#39;, &#39;9&#39;, &#39;m&#39;, &#39;n&#39;, &#39;k&#39;, &#39;2&#39;, &#39;8&#39;, &#39;k&#39;, &#39;7&#39;, &#39;5&#39;, &#39;&#125;&#39;&#125;, this.findViewById(0x7F05003F))</code></pre>
<p>提取有用信息</p>
<pre><code>p v k q &#123; m 1 6 4 6 7 5 2 6 2 0 3 3 l 4 m 4 9 l n p 7 p 9 m n k 2 8 k 7 5 &#125; //实际上将apk文件解压，然后将文件classes.dex后缀改为txt，搜索‘&#123;’也可以得到这个</code></pre>
<p>分析jeb代码，发现好像和凯撒加密有一些关系，直接暴力破解，脚本如下</p>
<pre><code>#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;stdio.h&gt;
int main(void)
&#123;
    char table1[27]=&quot;abcdefghijklmnopqrstuvwxyz&quot;;
    char table2[27]=&quot;ABCDEFJHIJKLMNOPQRSTUVWXYZ&quot;;
    char str1[100]=&quot;pvkq&#123;m164675262033l4m49lnp7p9mnk28k75&#125;&quot;;
    char str2[100]=&quot;&quot;;
    int i,k,len;

    len=strlen(str1);
    for(k=0;k&lt;26;k++)
    &#123;
        for(i=0;i&lt;len;i++)
        &#123;
            if(str1[i]&gt;=table1[k]&amp;&amp;str1[i]&lt;=&#39;z&#39;)
            &#123;
                str2[i]=str1[i]-k;
            &#125;
            else if(str1[i]&lt;table1[k]&amp;&amp;str1[i]&gt;=&#39;a&#39;)
            &#123;
                str2[i]=str1[i]+26-k;
            &#125;
            else if(str1[i]&gt;=table2[k]&amp;&amp;str1[i]&lt;=&#39;Z&#39;)
            &#123;
                str2[i]=str1[i]-k;
            &#125;
            else if(str1[i]&lt;table2[k]&amp;&amp;str1[i]&gt;=&#39;A&#39;)
            &#123;
                str2[i]=str1[i]+26-k;
            &#125;            
            else
            &#123;
                str2[i]=str1[i];
            &#125;
        &#125;
        printf(&quot;%s&quot;,str2);
        printf(&quot;\n&quot;);
    &#125;
 &#125; </code></pre>
<p>得到</p>
<pre><code>pvkq&#123;m164675262033l4m49lnp7p9mnk28k75&#125;
oujp&#123;l164675262033k4l49kmo7o9lmj28j75&#125;
ntio&#123;k164675262033j4k49jln7n9kli28i75&#125;
mshn&#123;j164675262033i4j49ikm7m9jkh28h75&#125;
lrgm&#123;i164675262033h4i49hjl7l9ijg28g75&#125;
kqfl&#123;h164675262033g4h49gik7k9hif28f75&#125;
jpek&#123;g164675262033f4g49fhj7j9ghe28e75&#125;
iodj&#123;f164675262033e4f49egi7i9fgd28d75&#125;
hnci&#123;e164675262033d4e49dfh7h9efc28c75&#125;
gmbh&#123;d164675262033c4d49ceg7g9deb28b75&#125;
flag&#123;c164675262033b4c49bdf7f9cda28a75&#125;//这个就是flag
ekzf&#123;b164675262033a4b49ace7e9bcz28z75&#125;
djye&#123;a164675262033z4a49zbd7d9aby28y75&#125;
cixd&#123;z164675262033y4z49yac7c9zax28x75&#125;
bhwc&#123;y164675262033x4y49xzb7b9yzw28w75&#125;
agvb&#123;x164675262033w4x49wya7a9xyv28v75&#125;
zfua&#123;w164675262033v4w49vxz7z9wxu28u75&#125;
yetz&#123;v164675262033u4v49uwy7y9vwt28t75&#125;
xdsy&#123;u164675262033t4u49tvx7x9uvs28s75&#125;
wcrx&#123;t164675262033s4t49suw7w9tur28r75&#125;
vbqw&#123;s164675262033r4s49rtv7v9stq28q75&#125;
uapv&#123;r164675262033q4r49qsu7u9rsp28p75&#125;
tzou&#123;q164675262033p4q49prt7t9qro28o75&#125;
synt&#123;p164675262033o4p49oqs7s9pqn28n75&#125;
rxms&#123;o164675262033n4o49npr7r9opm28m75&#125;
qwlr&#123;n164675262033m4n49moq7q9nol28l75&#125;</code></pre>
<p>也可以根据前几个字母，先算出位移量，到网上去在线解密。</p>
<h3 id="15-GXYCTF2019-luck-guy"><a href="#15-GXYCTF2019-luck-guy" class="headerlink" title="15.[GXYCTF2019]luck_guy"></a>15.[GXYCTF2019]luck_guy</h3><p>自己ida打开，找到关键代码，找的过程就不说了</p>
<pre><code>unsigned __int64 get_flag()
&#123;
  unsigned int v0; // eax
  char v1; // al
  signed int i; // [rsp+4h] [rbp-3Ch]
  signed int j; // [rsp+8h] [rbp-38h]
  __int64 s; // [rsp+10h] [rbp-30h]
  char v6; // [rsp+18h] [rbp-28h]
  unsigned __int64 v7; // [rsp+38h] [rbp-8h]

  v7 = __readfsqword(40u);
  v0 = time(0LL);
  srand(v0);
  for ( i = 0; i &lt;= 4; ++i )
  &#123;
    switch ( rand() % 200 )//就是随机取数了，所以叫luck_guy,实际上有用的case也就1，4，5。
    &#123;
      case 1:
        puts(&quot;OK, it&#39;s flag:&quot;);
        memset(&amp;s, 0, 0x28uLL);                 // 将s0清0
        strcat((char *)&amp;s, f1);                 // f1=&#39;GXY&#123;do_not_&#39;
        strcat((char *)&amp;s, &amp;f2);                // f2是剩下的那一半flag
        printf(&quot;%s&quot;, &amp;s);
        break;
      case 2:
        printf(&quot;Solar not like you&quot;);
        break;
      case 3:
        printf(&quot;Solar want a girlfriend&quot;);
        break;
      case 4:
        v6 = 0;
        s = &#39;fo`guci&#39;;
        strcat(&amp;f2, (const char *)&amp;s);//将s给f2，注意要反序。
        break;
      case 5://就一个将f2的加密过程，算出来的f2就是另一半flag。
        for ( j = 0; j &lt;= 7; ++j )
        &#123;
          if ( j % 2 == 1 )
            v1 = *(&amp;f2 + j) - 2;
          else
            v1 = *(&amp;f2 + j) - 1;
          *(&amp;f2 + j) = v1;
        &#125;
        break;
      default:
        puts(&quot;emmm,you can&#39;t find flag 23333&quot;);
        break;
    &#125;
  &#125;
  return __readfsqword(0x28u) ^ v7;
&#125;</code></pre>
<p>根据分析，写出脚本</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int i;
    char a[]=&#123;&#39;i&#39;, &#39;c&#39;, &#39;u&#39;, &#39;g&#39;, &#39;`&#39;, &#39;o&#39;, &#39;f&#39;, &#39;\x7f&#39;&#125;;

    for(i=0;i&lt;=7;i++)
    &#123;
        if (i%2==1)
            a[i]=a[i]-2;
        else
            a[i]=a[i]-1;
        printf(&quot;%c&quot;,a[i]);
     &#125; 
 &#125;</code></pre>
<p>得到f2：hate_me} 和f1拼起来，得到GXY{do_not_hate_me}</p>
<h3 id="16-简单注册器"><a href="#16-简单注册器" class="headerlink" title="16.简单注册器"></a>16.简单注册器</h3><p>下载下来是个apk文件，jeb打开，与14题一样操作，得到重要代码。<br><img src="https://i.loli.net/2020/12/04/EesntdU2ZrRpiLY.png"><br>根据分析写出脚本如下</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int m=0x1f,n=2,i=0,j;
    char a[33]=&quot;dd2940c04462b4dd7c450528835cca15&quot;;

    a[n] = ((char)(a[n] + a[3] - 50));
    a[4] = ((char)(a[n] + a[5] - 0x30));
    a[30] = ((char)(a[m] + a[9] - 0x30));
    a[14] = ((char)(a[27] + a[28] - 97));

    for(i=0;i&lt;16;i++)
    &#123;
        j=a[0x1f-i];
        a[0x1f-i]=a[i];
        a[i]=j;
    &#125;
    printf(&quot;%s&quot;,a);
 &#125; </code></pre>
<p>得到59acc538825054c7de4b26440c0999dd</p>
<p>所以flag{59acc538825054c7de4b26440c0999dd}</p>
<h3 id="17-GWCTF-2019-pyre"><a href="#17-GWCTF-2019-pyre" class="headerlink" title="17.[GWCTF 2019]pyre"></a>17.[GWCTF 2019]pyre</h3><p>看题目，pyre，说明是python文件，下载下来是pyc，先反编译为py文件，在cmd里面输入命令(我11届极客大挑战的文章中中有也有一道题是反编译pyc文件)</p>
<pre><code>C:\Users\hp&gt;uncompyle6 -o C:\Users\hp\Downloads\attachment.py C:\Users\hp\Downloads\attachment.pyc
C:\Users\hp\Downloads\attachment.pyc --
# Successfully decompiled file</code></pre>
<p>出现Successfully则表示成功。用python的IDLE打开这个py文件，得到源码，如下</p>
<pre><code>print &#39;Welcome to Re World!&#39;
print &#39;Your input1 is your flag~&#39;
l = len(input1)
for i in range(l)://第一次for循环加密，注意i和1的区别，我就是因为把i看作了1，做了很久。
    num = ((input1[i] + i) % 128 + 128) % 128
    code += num//注意这一句，和c不太一样，它的意思是用num的值来填充code。

for i in range(l - 1)://第二个加密，就是数组内异或。
    code[i] = code[i] ^ code[(i + 1)]

print code
code = [&#39;\x1f&#39;, &#39;\x12&#39;, &#39;\x1d&#39;, &#39;(&#39;, &#39;0&#39;, &#39;4&#39;, &#39;\x01&#39;, &#39;\x06&#39;, &#39;\x14&#39;, &#39;4&#39;, &#39;,&#39;, &#39;\x1b&#39;, &#39;U&#39;, &#39;?&#39;, &#39;o&#39;, &#39;6&#39;, &#39;*&#39;, &#39;:&#39;, &#39;\x01&#39;, &#39;D&#39;, &#39;;&#39;, &#39;%&#39;, &#39;\x13&#39;]</code></pre>
<p>写出脚本</p>
<pre><code>#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;stdio.h&gt;
int main(void)
&#123;
    int i,len;
    char code[23]=&#123;&#39;\x1f&#39;, &#39;\x12&#39;, &#39;\x1d&#39;, &#39;(&#39;, &#39;0&#39;, &#39;4&#39;, &#39;\x01&#39;, &#39;\x06&#39;, &#39;\x14&#39;, &#39;4&#39;, &#39;,&#39;, &#39;\x1b&#39;, &#39;U&#39;, &#39;?&#39;, &#39;o&#39;, &#39;6&#39;, &#39;*&#39;, &#39;:&#39;, &#39;\x01&#39;, &#39;D&#39;, &#39;;&#39;, &#39;%&#39;, &#39;\x13&#39;&#125;;
    len=strlen(code);
    printf(&quot;%d&quot;,len);
    printf(&quot;\n&quot;);
    for(i=len-2;i!=-1;i--)//数组内异或解密
    &#123;
        code[i]=code[i]^code[i+1];
    &#125;
    for(i=0;i!=len;i++)
    &#123;
        code[i]=code[i]-i;//这时候的一些code[i]的十进制值是负数
        if(code[i]&lt;0)//注意这个if条件，保证flag内字符的值在64~127内。
        &#123;
            code[i]+=128;
        &#125;
        printf(&quot;%c&quot;,code[i]);
    &#125;
 &#125; </code></pre>
<p>得到flag：GWHT{Just_Re_1s_Ha66y!}</p>
<h3 id="18-rsa"><a href="#18-rsa" class="headerlink" title="18.rsa"></a>18.rsa</h3><p>首先了解rsa是什么。<br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/44185847?utm_source=wechat_session">https://zhuanlan.zhihu.com/p/44185847?utm_source=wechat_session</a></p>
<p>下载下来得到两个文件，一个文件是flag，一个是公钥。</p>
<p>用公钥在线分析网站，分解公钥<br><a target="_blank" rel="noopener" href="http://tool.chacuo.net/cryptrsakeyparse/">http://tool.chacuo.net/cryptrsakeyparse/</a>，也可以用Linux的kali来分解公钥(某位大佬的博客<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jane315/p/13175850.html">https://www.cnblogs.com/jane315/p/13175850.html</a>)<br>得到</p>
<pre><code>n=C0332C5C64AE47182F6C1C876D42336910545A58F7EEFEFC0BCAAF5AF341CCDD
e=65537 (0x10001)</code></pre>
<p>用Python将n转化为十进制</p>
<pre><code>&gt;&gt;&gt; a=int(&#39;C0332C5C64AE47182F6C1C876D42336910545A58F7EEFEFC0BCAAF5AF341CCDD&#39;,16)
&gt;&gt;&gt; print(a)
86934482296048119190666062003494800588905656017203025617216654058378322103517

得到n=86934482296048119190666062003494800588905656017203025617216654058378322103517</code></pre>
<p>在继续分解n得到p，q。网站：<a target="_blank" rel="noopener" href="http://factordb.com/">http://factordb.com/</a>得到</p>
<pre><code>p=285960468890451637935629440372639283459
q=304008741604601924494328155975272418463</code></pre>
<p>然后写脚本，这里是直接用的别人的，需要注意的是需要安装两个库。</p>
<pre><code>import gmpy2
import rsa

e=65537
n=86934482296048119190666062003494800588905656017203025617216654058378322103517
p=285960468890451637935629440372639283459
q=304008741604601924494328155975272418463

phin = (p-1) * (q-1)
d=gmpy2.invert(e, phin)

key=rsa.PrivateKey(n,e,int(d),p,q)

with open(&quot;flag.enc&quot;,&quot;rb&quot;) as f://这里是打开那个flag.net文件
    f=f.read()
    print(rsa.decrypt(f,key))</code></pre>
<p>得到flag{decrypt_256}</p>
<h3 id="19-JustRE"><a href="#19-JustRE" class="headerlink" title="19.JustRE"></a>19.JustRE</h3><p>文件下载下来，打开发现<br><img src="https://i.loli.net/2020/12/11/6ultd1rOk4hs87B.png"><br>说是要你一直点就会出flag。不过它说的还真是真的。<br><img src="https://i.loli.net/2020/12/11/WA2Sbl9ajVodMJk.png"><br>正确解法，放到ida里面，shift +12。<br><img src="https://i.loli.net/2020/12/11/ob3J5ufAgTjIXvW.png"><br>找到其所在函数，f5看伪代码。<br><img src="https://i.loli.net/2020/12/11/8P7SMwOEnGHXzfo.png"><br>不知道sprintf的意思，网上搜一搜，<a target="_blank" rel="noopener" href="https://blog.csdn.net/wangkeyen/article/details/81942918">https://blog.csdn.net/wangkeyen/article/details/81942918</a></p>
<pre><code>aBjdDD2069a4579就是BJD&#123;%d%d2069a45792d233ac&#125;
而 sprintf(&amp;String, aBjdDD2069a4579, 19999, 0);就是要你把19999，0分别是那两个%d</code></pre>
<p>得到flag{1999902069a45792d233ac}</p>
<h3 id="20-2019红帽杯-easyRE"><a href="#20-2019红帽杯-easyRE" class="headerlink" title="20.[2019红帽杯]easyRE"></a>20.[2019红帽杯]easyRE</h3><p>下载文件用ida打开，shift+12；<br><img src="https://i.loli.net/2020/12/11/e1Zowna3kmUCTYL.png"><br>找到重要代码</p>
<pre><code>  unsigned __int64 v54; // [rsp+108h] [rbp-18h]

  v54 = __readfsqword(0x28u);
  v12 = 73;
  v13 = 111;
  v14 = 100;
  v15 = 108;
  v16 = 62;
  v17 = 81;
  v18 = 110;
  v19 = 98;
  v20 = 40;
  v21 = 111;
  v22 = 99;
  v23 = 121;
  v24 = 127;
  v25 = 121;
  v26 = 46;
  v27 = 105;
  v28 = 127;
  v29 = 100;
  v30 = 96;
  v31 = 51;
  v32 = 119;
  v33 = 125;
  v34 = 119;
  v35 = 101;
  v36 = 107;
  v37 = 57;
  v38 = 123;
  v39 = 105;
  v40 = 121;
  v41 = 61;
  v42 = 126;
  v43 = 121;
  v44 = 76;
  v45 = 64;
  v46 = 69;
  v47 = 67;
  memset(v48, 0, sizeof(v48));
  v49 = 0;
  v50 = 0;
  sub_4406E0(0LL, v48, 37LL);
  v50 = 0;
  if ( sub_424BA0(v48) == 36 )
  &#123;
    for ( i = 0; i &lt; (unsigned __int64)sub_424BA0(v48); ++i )
    &#123;
      if ( (unsigned __int8)(v48[i] ^ i) != *(&amp;v12 + i) )//v48是自己输入的，*(&amp;v12 + i)就相当于一个数组，从v12到v47，一共36个数。简单的异或。
      &#123;
        result = 4294967294LL;
        goto LABEL_13;
      &#125;
    &#125;
    sub_410CC0(&quot;continue!&quot;);
    memset(&amp;v51, 0, 0x40uLL);
    v53 = 0;
    sub_4406E0(0LL, &amp;v51, 64LL);
    v52 = 0;
    if ( sub_424BA0(&amp;v51) == 39 )
    &#123;
      v1 = sub_400E44(&amp;v51);
      v2 = sub_400E44(v1);
      v3 = sub_400E44(v2);
      v4 = sub_400E44(v3);
      v5 = sub_400E44(v4);
      v6 = sub_400E44(v5);
      v7 = sub_400E44(v6);
      v8 = sub_400E44(v7);
      v9 = sub_400E44(v8);
      v10 = sub_400E44(v9);
      if ( !(unsigned int)sub_400360(v10, off_6CC090) )
      &#123;
        sub_410CC0(&quot;You found me!!!&quot;);
        sub_410CC0(&quot;bye bye~&quot;);
      &#125;
      result = 0LL;
    &#125;
    else
    &#123;
      result = 4294967293LL;
    &#125;
  &#125;
  else
  &#123;
    result = 0xFFFFFFFFLL;
  &#125;
LABEL_13:
  if ( __readfsqword(0x28u) != v54 )
    sub_444020();
  return result;
&#125;</code></pre>
<p>先看这一部分</p>
<pre><code>if ( sub_424BA0(v48) == 36 )
  &#123;
    for ( i = 0; i &lt; (unsigned __int64)sub_424BA0(v48); ++i )
    &#123;
      if ( (unsigned __int8)(v48[i] ^ i) != *(&amp;v12 + i) )//v48是自己输入的，*(&amp;v12 + i)就相当于一个数组，从v12到v47，一共36个数。简单的异或。
      &#123;
        result = 4294967294LL;
        goto LABEL_13;
      &#125;
    &#125;</code></pre>
<p>写出脚本</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int a[36]=&#123;73,111,100,108,62,81,110,98,40,111,99,121,127,121,46,105,127,100,96,51,119,125,119,101,107,57,123,105,121,61,126,121,76,64,69,67&#125;;     
    int i;

    for(i=0;i&lt;36;i++)
    &#123;
        a[i]=a[i]^i;
        printf(&quot;%c&quot;,a[i]); 
    &#125;
 &#125; </code></pre>
<p>得到<br><img src="https://i.loli.net/2020/12/11/9zfNW3A4sLdRIbn.png"><br>它说：前四个字符是“flag”，现在还不知道意思。</p>
<p>继续看</p>
<pre><code>    memset(&amp;v51, 0, 0x40uLL);//定义了一个数组叫v51
    v53 = 0;
    sub_4406E0(0LL, &amp;v51, 64LL);
    v52 = 0;
    if ( sub_424BA0(&amp;v51) == 39 )//v61长度是39
    &#123;
      v1 = sub_400E44(&amp;v51);//对v51base64编码
      v2 = sub_400E44(v1);//对v1base64编码
      v3 = sub_400E44(v2);
      v4 = sub_400E44(v3);
      v5 = sub_400E44(v4);
      v6 = sub_400E44(v5);
      v7 = sub_400E44(v6);
      v8 = sub_400E44(v7);
      v9 = sub_400E44(v8);
      v10 = sub_400E44(v9);
      if ( !(unsigned int)sub_400360(v10, off_6CC090) )将v10和off_6CC090对比。
      &#123;
        sub_410CC0(&quot;You found me!!!&quot;);
        sub_410CC0(&quot;bye bye~&quot;);
      &#125;</code></pre>
<p>整个过程就是一个不断base64编码的过程，进行了10次，得到了off_6CC090，也就是</p>
<pre><code>Vm0wd2VHUXhTWGhpUm1SWVYwZDRWVll3Wkc5WFJsbDNXa1pPVlUxV2NIcFhhMk0xVmpKS1NHVkdXbFpOYmtKVVZtcEtTMUl5VGtsaVJtUk9ZV3hhZVZadGVHdFRNVTVYVW01T2FGSnRVbGhhVjNoaFZWWmtWMXBFVWxSTmJFcElWbTAxVDJGV1NuTlhia0pXWWxob1dGUnJXbXRXTVZaeVdrWm9hVlpyV1hwV1IzaGhXVmRHVjFOdVVsWmlhMHBZV1ZSR1lWZEdVbFZTYlhSWFRWWndNRlZ0TVc5VWJGcFZWbXR3VjJKSFVYZFdha1pXWlZaT2NtRkhhRk5pVjJoWVYxZDBhMVV3TlhOalJscFlZbGhTY1ZsclduZGxiR1J5VmxSR1ZXSlZjRWhaTUZKaFZqSktWVkZZYUZkV1JWcFlWV3BHYTFkWFRrZFRiV3hvVFVoQ1dsWXhaRFJpTWtsM1RVaG9hbEpYYUhOVmJUVkRZekZhY1ZKcmRGTk5Wa3A2VjJ0U1ExWlhTbFpqUldoYVRVWndkbFpxUmtwbGJVWklZVVprYUdFeGNHOVhXSEJIWkRGS2RGSnJhR2hTYXpWdlZGVm9RMlJzV25STldHUlZUVlpXTlZadE5VOVdiVXBJVld4c1dtSllUWGhXTUZwell6RmFkRkpzVWxOaVNFSktWa1phVTFFeFduUlRhMlJxVWxad1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ==</code></pre>
<p>直接网上解码10次，发现是<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-254172.htm">https://bbs.pediy.com/thread-254172.htm</a>，居然是一个网站。。。。无情被欺骗。最后通过看wp，发现真正的算法在<br><img src="https://i.loli.net/2020/12/11/8SeKL1W6wEzcDyo.png"><br>得到代码</p>
<pre><code>unsigned __int64 __fastcall sub_400D35(__int64 a1, __int64 a2)
&#123;
  __int64 v2; // rdx
  __int64 v3; // rdx
  __int64 v4; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rt1
  unsigned int v7; // [rsp+Ch] [rbp-24h]
  signed int i; // [rsp+10h] [rbp-20h]
  signed int j; // [rsp+14h] [rbp-1Ch]
  unsigned int v10; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v11; // [rsp+28h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  v7 = sub_43FD20() - qword_6CEE38;
  for ( i = 0; i &lt;= &#39;\x04�&#39;; ++i )
  &#123;
    sub_40F790(v7);
    sub_40FE60(v7, a2, v2);
    sub_40FE60(v7, a2, v3);
    v7 = (unsigned __int64)sub_40FE60(v7, a2, v4) ^ 2557891634;
  &#125;
  v10 = v7;
  if ( ((unsigned __int8)v7 ^ byte_6CC0A0[0]) == &#39;f&#39; &amp;&amp; (HIBYTE(v10) ^ (unsigned __int8)byte_6CC0A3) == &#39;g&#39; )//这里的f和g是不是有点熟悉，再联系一下前面的提示：前四个字符是“flag”，通过这个来求key。
  &#123;
    for ( j = 0; j &lt;= 24; ++j )
      sub_410E90((unsigned __int8)(byte_6CC0A0[j] ^ *((_BYTE *)&amp;v10 + j % 4)));//加密算法，key实际上就是那个v10，通过j % 4，又可以知道，v10只有4个。
  &#125;
  v6 = __readfsqword(0x28u);
  result = v6 ^ v11;
  if ( v6 != v11 )
    sub_444020();
  return result;
&#125;</code></pre>
<p>byte_6CC0A0[25]={0x40,0x35,0x20,0x56,0x5d,0x18,0x22,0x45,0x17,0x2f,0x24,0x6e,0x62,0x3c,0x27,0x54,0x48,0x6c,0x24,0x6e,0x72,0x3c,0x32,0x45,0x5b};</p>
<p>写出脚本</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int a[36]=&#123;73,111,100,108,62,81,110,98,40,111,99,121,127,121,46,105,127,100,96,51,119,125,119,101,107,57,123,105,121,61,126,121,76,64,69,67&#125;; 
    int key[4]=&#123;&#39;f&#39;,&#39;l&#39;,&#39;a&#39;,&#39;g&#39;&#125; ;
    int byte_6CC0A0[25]=&#123;0x40,0x35,0x20,0x56,0x5d,0x18,0x22,0x45,0x17,0x2f,0x24,0x6e,0x62,0x3c,0x27,0x54,0x48,0x6c,0x24,0x6e,0x72,0x3c,0x32,0x45,0x5b&#125;;
    int i,j;

    for(i=0;i&lt;36;i++)
    &#123;
        a[i]=a[i]^i;
        printf(&quot;%c&quot;,a[i]); 
    &#125;
    printf(&quot;\n&quot;); 
    for(i=0;i&lt;4;i++)//通过前4个字符，也就是flag，求出key。
    &#123;
        key[i]=key[i]^byte_6CC0A0[i];
    &#125;
    for(j=0;j&lt;25;j++)//用key来解密。
    &#123;
        byte_6CC0A0[j]=byte_6CC0A0[j]^key[j%4];
        printf(&quot;%c&quot;,byte_6CC0A0[j]);
    &#125;
 &#125; </code></pre>
<p>得到flag{Act1ve_Defen5e_Test}</p>
<h3 id="21-ACTF新生赛2020-easyre"><a href="#21-ACTF新生赛2020-easyre" class="headerlink" title="21.[ACTF新生赛2020]easyre"></a>21.[ACTF新生赛2020]easyre</h3><p>下载下来用PEID打开，发现是upx加壳的文件<br><img src="https://i.loli.net/2020/12/12/3FfUPVaYK1ke9ux.png"><br>由于前面已经介绍过upx解壳了，就不写过程了。</p>
<p>然后将文件拖入ida，shift+12，ctrl+x，一套操作。得到关键代码</p>
<pre><code>  __main();
  v4 = 42;
  v5 = 70;
  v6 = 39;
  v7 = 34;
  v8 = 78;
  v9 = 44;
  v10 = 34;
  v11 = 40;
  v12 = 73;
  v13 = 63;
  v14 = 43;
  v15 = 64;//一个长度为12的数组。
  printf(&quot;Please input:&quot;);
  scanf(&quot;%s&quot;, &amp;v19);
  if ( v19 != &#39;A&#39; || v20 != &#39;C&#39; || v21 != &#39;T&#39; || v22 != &#39;F&#39; || v23 != &#39;&#123;&#39; || v27 != &#39;&#125;&#39; )//这里是r键过后的，从这可以知道v24~v26是我们需要的东西
    return 0;
  v16 = v24;
  v17 = v25;
  v18 = v26;
  for ( i = 0; i &lt;= 11; ++i )
  &#123;
    if ( *(&amp;v4 + i) != _data_start__[*((char *)&amp;v16 + i) - 1] )// _data_start_是一个表，类似于base64编码表。*((char *)&amp;v16 + i)是ACTF&#123;&#125;大括号中的内容。只不过这里我也有点疑惑，不应该只有3个吗。
      return 0;
  &#125;
  printf(&quot;You are correct!&quot;);
  return 0;
&#125;</code></pre>
<p>写出脚本，这个脚本体现了一个从一个字符串中找某个字符的思想</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int a[120]=&#123;&#39;~&#39;, &#39;&#125;&#39;, &#39;|&#39;, &#39;&#123;&#39;, &#39;z&#39;, &#39;y&#39;, &#39;x&#39;, &#39;w&#39;, &#39;v&#39;, &#39;u&#39;, &#39;t&#39;, &#39;s&#39;, &#39;r&#39;, &#39;q&#39;, &#39;p&#39;, &#39;o&#39;, &#39;n&#39;, &#39;m&#39;, &#39;l&#39;, &#39;k&#39;, &#39;j&#39;, &#39;i&#39;, &#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;, &#39;`&#39;, &#39;_&#39;, &#39;^&#39;, &#39;]&#39;, &#39;\\&#39;, &#39;[&#39;, &#39;Z&#39;, &#39;Y&#39;, &#39;X&#39;, &#39;W&#39;, &#39;V&#39;, &#39;U&#39;, &#39;T&#39;, &#39;S&#39;, &#39;R&#39;, &#39;Q&#39;, &#39;P&#39;, &#39;O&#39;, &#39;N&#39;, &#39;M&#39;, &#39;L&#39;, &#39;K&#39;, &#39;J&#39;, &#39;I&#39;, &#39;H&#39;, &#39;G&#39;, &#39;F&#39;, &#39;E&#39;, &#39;D&#39;, &#39;C&#39;, &#39;B&#39;, &#39;A&#39;, &#39;@&#39;, &#39;?&#39;, &#39;&gt;&#39;, &#39;=&#39;, &#39;&lt;&#39;, &#39;;&#39;, &#39;:&#39;, &#39;9&#39;, &#39;8&#39;, &#39;7&#39;, &#39;6&#39;, &#39;5&#39;, &#39;4&#39;, &#39;3&#39;, &#39;2&#39;, &#39;1&#39;, &#39;0&#39;, &#39;/&#39;, &#39;.&#39;, &#39;-&#39;, &#39;,&#39;, &#39;+&#39;, &#39;*&#39;, &#39;)&#39;, &#39;(&#39;,0x27, &#39;&amp;&#39;, &#39;%&#39;, &#39;$&#39;, &#39;#&#39;, &#39; &#39;, &#39;!&#39;, &#39;&quot;&#39;&#125;;//a就是那个_data_start__
    int v4[12]=&#123;42,70,39,34,78,44,34,40,73,63,43,64&#125;;
    int i,j;

    for(i=0;i&lt;12;i++)
    &#123;
        for(j=0;j&lt;=120;j++)
        &#123;
            if(v4[i]==a[j])
            &#123;
                printf(&quot;%c&quot;,j+1);//这个j+1是因为_data_start__[*((char *)&amp;v16 + i) - 1]中的-1
                break;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>得到flag{U9X_1S_W6@T?}</p>
<h3 id="22-SUCTF2019-SignIn"><a href="#22-SUCTF2019-SignIn" class="headerlink" title="22.[SUCTF2019]SignIn"></a>22.[SUCTF2019]SignIn</h3><p>文件下载下来直接用ida打开，一套操作找到关键代码</p>
<pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)
&#123;
  char v4; // [rsp+0h] [rbp-4A0h]
  char v5; // [rsp+10h] [rbp-490h]
  char v6; // [rsp+20h] [rbp-480h]
  char v7; // [rsp+30h] [rbp-470h]
  char v8; // [rsp+40h] [rbp-460h]
  char v9; // [rsp+B0h] [rbp-3F0h]
  unsigned __int64 v10; // [rsp+498h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  puts(&quot;[sign in]&quot;);
  printf(&quot;[input your flag]: &quot;, a2);
  __isoc99_scanf(&quot;%99s&quot;, &amp;v8);
  sub_96A(&amp;v8, &amp;v9);
  __gmpz_init_set_str(&amp;v7, &quot;ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35&quot;, 16LL);
  __gmpz_init_set_str(&amp;v6, &amp;v9, 16LL);
  __gmpz_init_set_str(&amp;v4, &quot;103461035900816914121390101299049044413950405173712170434161686539878160984549&quot;, 10LL);
  __gmpz_init_set_str(&amp;v5, &quot;65537&quot;, 10LL);
  __gmpz_powm(&amp;v6, &amp;v6, &amp;v5, &amp;v4);
  if ( (unsigned int)__gmpz_cmp(&amp;v6, &amp;v7) )
    puts(&quot;GG!&quot;);
  else
    puts(&quot;TTTTTTTTTTql!&quot;);
  return 0LL;
&#125;</code></pre>
<p>发现是一个rsa加密， __gmpz_init_set_str 函数是GNU 高精度算法库。</p>
<pre><code>c=0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35//密文
n=103461035900816914121390101299049044413950405173712170434161686539878160984549
e=65537</code></pre>
<p>先得到q，p。</p>
<pre><code>q=282164587459512124844245113950593348271
p=366669102002966856876605669837014229419</code></pre>
<p>用脚本跑出来</p>
<pre><code>from Crypto.Util.number import *
import gmpy2

p = 282164587459512124844245113950593348271
q = 366669102002966856876605669837014229419
e = 65537
c = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35

n = q*p
phi = (q-1)*(p-1)
d = gmpy2.invert(e,phi)
m = gmpy2.powmod(c,d,n)
flag = long_to_bytes(m)

print(flag)</code></pre>
<p>得到flag{Pwn_@_hundred_years}</p>
<h3 id="23-Youngter-drive"><a href="#23-Youngter-drive" class="headerlink" title="23.Youngter-drive"></a>23.Youngter-drive</h3><p>首先文件下载下来，PEID打开，发现upx加壳了。<br><img src="https://i.loli.net/2020/12/15/rlauFxIbs9ShpXH.png"></p>
<p>解壳<br><img src="https://i.loli.net/2020/12/15/OrQd6A2vZnFxWMz.png"><br>再用ida打开，找到主函数main_0，一进去就看得到，点进去在f5。</p>
<pre><code>int __thiscall main_0(void *this)
&#123;
  HANDLE v2; // [esp+D0h] [ebp-14h]
  HANDLE hObject; // [esp+DCh] [ebp-8h]

  sub_4110FF(this);
  ::hObject = CreateMutexW(0, 0, 0);
  j_strcpy(Dest, &amp;Source);
  hObject = CreateThread(0, 0, StartAddress, 0, 0, 0);
  v2 = CreateThread(0, 0, sub_41119F, 0, 0, 0);
  CloseHandle(hObject);
  CloseHandle(v2);
  while ( dword_418008 != -1 )
    ;
  sub_411190();
  CloseHandle(::hObject);
  return 0;
&#125;</code></pre>
<p>这里是查阅的一些函数</p>
<pre><code>CreateThread和CloseHandle：CreateThread是一种微软在Windows API中提供了建立新的线程的函数，该函数在主线程的基础上创建一个新线程。线程终止运行后，线程对象仍然在系统中，必须通过CloseHandle函数来关闭该线程对象。

Sleep：Sleep函数可以使计算机程序（进程，任务或线程）进入休眠，使其在一段时间内处于非活动状态。当函数设定的计时器到期，或者接收到信号、程序发生中断都会导致程序继续执行。

本来线程是同时进行的，然而这一道题就是通过sleep这个函数让线程交替进行了，导致了偶数位没进行加密，奇数位进行了加密。</code></pre>
<p>下面来分析这个主函数<br><img src="https://i.loli.net/2020/12/15/yZUlpsqvwYDPWgf.png"><br>然后主要分析这两个线程<br><img src="https://i.loli.net/2020/12/15/J6WVmSgQB7qyRYu.png"><br>进入那个加密函数，报错无法看源代码。<br><img src="https://i.loli.net/2020/12/15/rTFhlV1C9Kij4ad.png"><br>说是栈顶sp有问题，然后找到该函数位置。<br><img src="https://i.loli.net/2020/12/15/PhO8GyxiUCe5d3s.png"><br>修改sp<br><img src="https://i.loli.net/2020/12/15/prDmANUXsjZ7Lqk.png"><br>然后得到加密函数。</p>
<pre><code>char *__cdecl sub_411940(int a1, int a2)//a1是那个source(你输入的flag)，a2是那个dword_418008(29)
&#123;
  char *result; // eax
  char v3; // [esp+D3h] [ebp-5h]

  v3 = *(_BYTE *)(a2 + a1);//相当与a[a2],source[a2]。
  if ( (v3 &lt; 97 || v3 &gt; 122) &amp;&amp; (v3 &lt; 65 || v3 &gt; 90) )
    exit(0);//这里是必须要你输入的flag是是A~Z,a~z。
  if ( v3 &lt; 97 || v3 &gt; 122 )//如果source[a2]是大写字母，就这样加密
  &#123;
    result = off_418000[0];
    *(_BYTE *)(a2 + a1) = off_418000[0][*(char *)(a2 + a1) - 38];
  &#125;
  else//如果source[a2]是小写字母，就这样加密
  &#123;
    result = off_418000[0];
    *(_BYTE *)(a2 + a1) = off_418000[0][*(char *)(a2 + a1) - 96];
  &#125;
  return result;
&#125;</code></pre>
<p>注意这一句</p>
<pre><code>off_418000[0][*(char *)(a2 + a1) - 96];等价于off_418000[*(a2 + a1) - 96]//这个*(a2+a1)是未加密的，也就是你要求的flag。</code></pre>
<p>一些数据</p>
<pre><code>off_418000[]=QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm
加密后的*(_BYTE *)(a2 + a1)=TOiZiZtOrYaToUwPnToBsOaOapsyS</code></pre>
<p>然后开始写脚本，</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    char str[30]=&quot;TOiZiZtOrYaToUwPnToBsOaOapsyS&quot;;//off_418004
    char str1[53]=&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;;//off_418000
    char flag[30];
    int a[30];
    int b[30];
    int i,j,m=0;

    for(i=0;i&lt;29;i++)
    &#123;
        if(i%2==0)
        flag[i]=str[i];
    &#125;
    for(i=0;i&lt;29;i++)
    &#123;
        for(j=0;j&lt;52;j++)
        &#123;    
            if(str[i]==str1[j])
            &#123;
//                printf(&quot;%d &quot;,j);
                if(j&lt;27)//这个27是算出来的，是决定是字母大写，字母小写的临界值 
                &#123;
                    flag[m]=j+96;
                    m++;
                &#125;
                else
                &#123;
                    flag[m]=j+38;
                    m++;
                &#125;
            &#125;    
        &#125;
    &#125;

    for(i=0;i&lt;29;i++)//这个for循环就是因为两个线程交替进行的原因，偶数位不加密，奇数位要加密 
    &#123;
        if(i%2==0)
        flag[i]=str[i];
    &#125;

    for(i=0;i&lt;29;i++)
    &#123;
        printf(&quot;%c&quot;,flag[i]);
    &#125;
 &#125; </code></pre>
<p>网上找的Python脚本如下</p>
<pre><code>str=&quot;0abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
text1=&#39;TOiZiZtOrYaToUwPnToBsOaOapsyS&#39;
text2=&#39;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#39;
flag=&#39;&#39;
s=0
for i in range(len(text1)):
    if(i%2==0):
        flag+=text1[i]
    else:
        s=text2.index(text1[i])
        flag+=str[s]
print(flag)</code></pre>
<p>得到ThisisthreadofwindowshahaIsES，但这不是flag，真正的flag还要在后面加一个E(我也不知道为什么)，得到flag{ThisisthreadofwindowshahaIsESE}</p>
<h3 id="24-GUET-CTF2019-re"><a href="#24-GUET-CTF2019-re" class="headerlink" title="24.[GUET-CTF2019]re"></a>24.[GUET-CTF2019]re</h3><p>文件下载下来用Exeinfo PE打开<br><img src="https://i.loli.net/2020/12/17/qw12XmRduUgZMKn.png"><br>发现是upx加壳，解壳<br><img src="https://i.loli.net/2020/12/17/9eusW1ftcB3mYiy.png"><br>IDA打开，找到关键代码<br><img src="https://i.loli.net/2020/12/17/c7AirZMUtqIBuwd.png"><br>去看看加密函数</p>
<pre><code>_BOOL8 __fastcall sub_4009AE(char *a1)
&#123;
  if ( 1629056 * *a1 != 166163712 )
    return 0LL;
  if ( 6771600 * a1[1] != 731332800 )
    return 0LL;
  if ( 3682944 * a1[2] != 357245568 )
    return 0LL;
  if ( 10431000 * a1[3] != 1074393000 )
    return 0LL;
  if ( 3977328 * a1[4] != 489211344 )
    return 0LL;
  if ( 5138336 * a1[5] != 518971936 )
    return 0LL;
  if ( 7532250 * a1[7] != 406741500 )
    return 0LL;
  if ( 5551632 * a1[8] != 294236496 )
    return 0LL;
  if ( 3409728 * a1[9] != 177305856 )
    return 0LL;
  if ( 13013670 * a1[10] != 650683500 )
    return 0LL;
  if ( 6088797 * a1[11] != 298351053 )
    return 0LL;
  if ( 7884663 * a1[12] != 386348487 )
    return 0LL;
  if ( 8944053 * a1[13] != 438258597 )
    return 0LL;
  if ( 5198490 * a1[14] != 249527520 )
    return 0LL;
  if ( 4544518 * a1[15] != 445362764 )
    return 0LL;
  if ( 3645600 * a1[17] != 174988800 )
    return 0LL;
  if ( 10115280 * a1[16] != 981182160 )
    return 0LL;
  if ( 9667504 * a1[18] != 493042704 )
    return 0LL;
  if ( 5364450 * a1[19] != 257493600 )
    return 0LL;
  if ( 13464540 * a1[20] != 767478780 )
    return 0LL;
  if ( 5488432 * a1[21] != 312840624 )
    return 0LL;
  if ( 14479500 * a1[22] != 1404511500 )
    return 0LL;
  if ( 6451830 * a1[23] != 316139670 )
    return 0LL;
  if ( 6252576 * a1[24] != 619005024 )
    return 0LL;
  if ( 7763364 * a1[25] != 372641472 )
    return 0LL;
  if ( 7327320 * a1[26] != 373693320 )
    return 0LL;
  if ( 8741520 * a1[27] != 498266640 )
    return 0LL;
  if ( 8871876 * a1[28] != 452465676 )
    return 0LL;
  if ( 4086720 * a1[29] != 208422720 )
    return 0LL;
  if ( 9374400 * a1[30] == 515592000 )
    return 5759124 * a1[31] == 719890500;
  return 0LL;
&#125;</code></pre>
<p>直接除过去就能得到flag，只不过题有点问题，没有a[6]，看了其他wp是1。<br>脚本如下，比较痛苦。</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void)
&#123;
    long long a1[33];
    int i;

    a1[0] = 166163712/1629056;   
    a1[1] = 731332800/6771600;
    a1[2] = 357245568/3682944; 
    a1[3] = 1074393000/10431000;
    a1[4] = 489211344/3977328;
    a1[5] = 518971936/5138336;
    a1[7] = 406741500/7532250;
    a1[8] = 294236496/5551632;
    a1[9] = 177305856/3409728;
    a1[10] = 650683500/13013670;
    a1[11] = 298351053/6088797;
    a1[12] = 386348487/7884663;
    a1[13] = 438258597/8944053;
    a1[14] = 249527520/5198490;
    a1[15] = 445362764/4544518; 
    a1[17] = 174988800/3645600;
    a1[16] = 981182160/10115280;
    a1[18] = 493042704/9667504;
    a1[19] = 257493600/5364450;
    a1[20] = 767478780/13464540;
    a1[21] = 312840624/5488432;
    a1[22] = 1404511500/14479500;
    a1[23] = 316139670/6451830;
    a1[24] = 619005024/6252576;
    a1[25] = 372641472/7763364;
    a1[26] = 373693320/7327320;
    a1[27] = 498266640/8741520;
    a1[28] = 452465676/8871876;
    a1[29] = 208422720/4086720;
    a1[30] =515592000/9374400;
    a1[31] =719890500/5759124;


    for(i=0;i&lt;33;i++)
    &#123;
        printf(&quot;%c&quot;,a1[i]);
    &#125;
    return 0;
&#125;</code></pre>
<p>得到flag{e165421110ba03099a1c039337}</p>
<h3 id="25-FlareOn4-login"><a href="#25-FlareOn4-login" class="headerlink" title="25.[FlareOn4]login"></a>25.[FlareOn4]login</h3><p>文件下载下来是一个html文件，打开看源代码</p>
<pre><code>&lt;!DOCTYPE Html /&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;FLARE On 2017&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;input type=&quot;text&quot; name=&quot;flag&quot; id=&quot;flag&quot; value=&quot;Enter the flag&quot; /&gt;
        &lt;input type=&quot;button&quot; id=&quot;prompt&quot; value=&quot;Click to check the flag&quot; /&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            document.getElementById(&quot;prompt&quot;).onclick = function () &#123;
                var flag = document.getElementById(&quot;flag&quot;).value;
                var rotFlag = flag.replace(/[a-zA-Z]/g, function(c)&#123;return String.fromCharCode((c &lt;= &quot;Z&quot; ? 90 : 122) &gt;= (c = c.charCodeAt(0) + 13) ? c : c - 26);&#125;);//这个就是加密过程。
                if (&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot; == rotFlag) &#123;
                    alert(&quot;Correct flag!&quot;);
                &#125; else &#123;
                    alert(&quot;Incorrect flag, rot again&quot;);
                &#125;
            &#125;
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>上面的加密过程由于没学JS有点看不懂，有点像C语言的简写条件(?:)<a target="_blank" rel="noopener" href="https://blog.csdn.net/whh4122/article/details/39271277?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">条件语句的简写</a>。但是看到了’a’,’z’,’A’,’Z’,就用凯撒脚本爆破了一下。</p>
<pre><code>#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;stdio.h&gt;
int main(void)
&#123;
    char table1[27]=&quot;abcdefghijklmnopqrstuvwxyz&quot;;
    char table2[27]=&quot;ABCDEFJHIJKLMNOPQRSTUVWXYZ&quot;;
    char str1[100]=&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot;;
    char str2[100]=&quot;&quot;;
    int i,k,len;

    len=strlen(str1);
    for(k=0;k&lt;26;k++)
    &#123;
        for(i=0;i&lt;len;i++)
        &#123;
            if(str1[i]&gt;=table1[k]&amp;&amp;str1[i]&lt;=&#39;z&#39;)
            &#123;
                str2[i]=str1[i]-k;
            &#125;
            else if(str1[i]&lt;table1[k]&amp;&amp;str1[i]&gt;=&#39;a&#39;)
            &#123;
                str2[i]=str1[i]+26-k;
            &#125;
            else if(str1[i]&gt;=table2[k]&amp;&amp;str1[i]&lt;=&#39;Z&#39;)
            &#123;
                str2[i]=str1[i]-k;
            &#125;
            else if(str1[i]&lt;table2[k]&amp;&amp;str1[i]&gt;=&#39;A&#39;)
            &#123;
                str2[i]=str1[i]+26-k;
            &#125;            
            else
            &#123;
                str2[i]=str1[i];
            &#125;
        &#125;
        printf(&quot;%s&quot;,str2);
        printf(&quot;\n&quot;);
    &#125;
 &#125; </code></pre>
<p>得到</p>
<pre><code>PyvragFvqrYbtvafNerRnfl@syner-ba.pbz
OxuqzfEupqXasuzeMdqQmek@rxmdq-az.oay
NwtpyeDtopWzrtydLcpPldj@qwlcp-zy.nzx
MvsoxdCsnoVyqsxcKboOkci@pvkbo-yx.myw
LurnwcBrmnUxprwbJanNjbh@oujan-xw.lxv
KtqmvbAqlmTwoqvaIzmMiag@ntizm-wv.kwu
JspluaZpklSvnpuzHylLhzf@mshyl-vu.jvt
IroktzYojkRumotyGxkKgye@lrgxk-ut.ius
HqnjsyXnijQtlnsxFwjJfxd@kqfwj-ts.htr
GpmirxWmhiPskmrwEviIewc@jpevi-sr.gsq
FolhqwVlghOrjlqvDuhHdvb@ioduh-rq.frp
EnkgpvUkfgNqikpuCtgGcua@hnctg-qp.eqo
DmjfouTjefMphjotBsfFbtz@gmbsf-po.dpn
ClientSideLoginsAreEasy@flare-on.com//flag
BkhdmsRhcdKnfhmrZqdDzrx@ekzqd-nm.bnl
AjgclrQgbcJmeglqYpcCyqw@djypc-ml.amk
ZifbkqPfabIldfkpXobBxpv@cixob-lk.zlj
YheajpOezaHkcejoWnaAwou@bhwna-kj.yki
XgdzioNdyzGjbdinVmzZvnt@agvmz-ji.xjh
WfcyhnMcxyFiachmUlyYums@zfuly-ih.wig
VebxgmLbwxEhzbglTkxXtlr@yetkx-hg.vhf
UdawflKavwDgyafkSjwWskq@xdsjw-gf.uge
TczvekJzuvCfxzejRivVrjp@wcriv-fe.tfd
SbyudjIytuBewydiQhuUqio@vbqhu-ed.sec
RaxtciHxstAdvxchPgtTphn@uapgt-dc.rdb
QzwsbhGwrsZcuwbgOfsSogm@tzofs-cb.qca</code></pre>
<p>感觉实际上那个加密就是位移为13的凯撒加密。得到flag{ClientSideLoginsAreEasy@flare-on.com}</p>
<h3 id="26-ACTF新生赛2020-usualCrypt"><a href="#26-ACTF新生赛2020-usualCrypt" class="headerlink" title="26.[ACTF新生赛2020]usualCrypt"></a>26.[ACTF新生赛2020]usualCrypt</h3><p>文件直接用IDA打开，然后找到关键代码部分<br><img src="https://i.loli.net/2020/12/17/7eZFq198vSUlnCH.png"><br>然后看加密函数</p>
<p>换表函数<br><img src="https://i.loli.net/2020/12/17/dlFEjnHMB97XpRs.png"><br>大写字母转小写字母，小写字母转大写字母函数。<br><img src="https://i.loli.net/2020/12/17/nkP5d6sLJxCzbUc.png"><br>写出脚本</p>
<p>脚本1，大写字母转小写字母，小写字母转大写字母</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    char a[37]=&quot;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&quot;;
    int i;

    for(i=0;i&lt;36;i++)
    &#123; 
        if(a[i]&gt;=&#39;a&#39;&amp;&amp;a[i]&lt;=&#39;z&#39;)
        &#123;
            a[i]=a[i]-32;
        &#125;
        else if(a[i]&gt;=&#39;A&#39;&amp;&amp;a[i]&lt;=&#39;Z&#39;)
        &#123;
            a[i]=a[i]+32;
        &#125;
        else
        &#123;
            a[i]=a[i];
        &#125;
        printf(&quot;%c&quot;,a[i]);
    &#125;
 &#125; </code></pre>
<p>得到ZmxhZ3tiGNXlXjHfaDTzN2FfK3LycRTpc2L9，由于不想去改表了所以弄了个Python的脚本。</p>
<pre><code>import base64
import string

str1 = &quot;ZmxhZ3tiGNXlXjHfaDTzN2FfK3LycRTpc2L9&quot;

string1 = &quot;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;
string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;

print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))</code></pre>
<p>得到flag{bAse64_h2s_a_Surprise}</p>
<h3 id="27-GWCTF-2019-xxor"><a href="#27-GWCTF-2019-xxor" class="headerlink" title="27.[GWCTF 2019]xxor"></a>27.[GWCTF 2019]xxor</h3><p>直接IDA打开，找到关键代码，分析过程也在里面了。<br><img src="https://i.loli.net/2020/12/17/2yhf3F4iGJUnvrK.png"><br>一些资料</p>
<pre><code>#define LOWORD(l) ((WORD)((DWORD_PTR)(l) &amp; 0xffff))
#define HIWORD(l) ((WORD)((DWORD_PTR)(l) &gt;&gt; 16))
这是baiwindef.h头文件中对宏LOWORD和HIWORD的定义。du
作用分别是取出无符号长整型zhi参数dao的高16位和低16位。
因为一zhuan个长整型占32位，其中高低16位的值可能有不同的意义，需要通过这2个宏分别取出来使用。取出来的结果是一个无符号短整型的值。
其原理正如定义那样，取低16位的宏LOWORD使用按位与操作符与数字0xffff运算，而数字0xffff是一个低16位全为1的数字，那么对其位与操作可以得到参数的低16位。
而取高16位的宏HIWORD则更简单，只需将参数右移16位，剩下的就是原高16位的值了。</code></pre>
<p>脚本如下</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    unsigned int v7[6];
    unsigned int a2[4]=&#123;2,2,3,4&#125;;
    unsigned int i,j,v5=0,v4,v3;//注意，这里必须是unsigned int代表无符号整型。
    int v6[6];

    v7[0]=3746099070;
    v7[1]=550153460;
//    V7[3]+V7[4]=4201428739;
//    V7[3]-V7[4]=-1103824215;
//    V7[2]-V7[3]=2225223423;
    v7[2]=3774025685;
    v7[3]=1548802262;
    v7[4]=2652626477;
    v7[5]=2230518816;

    for(i=0;i&lt;6;i++)
    &#123;
        printf(&quot;%#x &quot;,v7[i]);
    &#125;

    for(j=0;j&lt;5;j+=2)
    &#123;
        v3=v7[j];
        v4=v7[j+1];
        v5 = 1166789954*0x40;
        for(i=0;i&lt;=63;i++)
        &#123;
            v4 -=(v3 + v5 + 20) ^ ((v3 &lt;&lt; 6) + a2[2]) ^ ((v3 &gt;&gt; 9) + a2[3]) ^ 0x10;
            v3 -= (v4 + v5 + 11) ^ ((v4 &lt;&lt; 6) + a2[0]) ^ ((v4 &gt;&gt; 9) + a2[1]) ^ 0x20;
            v5 -= 1166789954;
        &#125;
        v7[j]=v3;
        v7[j+1]=v4;
    &#125;
    printf(&quot;\n&quot;);
    for(i=0;i&lt;6;i++)
    &#123;
        printf(&quot;%x&quot;,v7[i]); 
    &#125;

    printf(&quot;\n&quot;);
     for (int i = 0; i &lt; 6; ++i) 
        /*将整型数组作为字符输出，注意计算机小端排序*/
        printf(&quot;%c%c%c&quot;, *((char*)&amp;v7[i] + 2), *((char*)&amp;v7[i] + 1), *(char*)&amp;v7[i]);

 &#125; </code></pre>
<p>得到</p>
<p><img src="https://i.loli.net/2020/12/17/lWt63zh2K1p5qTm.png"><br>然后脚本提到的小端排序是指</p>
<p><img src="https://i.loli.net/2020/12/17/EstajDBAwHKguvQ.png"><br>flag{re_is_great!}</p>
<h3 id="28-HDCTF2019-Maze"><a href="#28-HDCTF2019-Maze" class="headerlink" title="28.[HDCTF2019]Maze"></a>28.[HDCTF2019]Maze</h3><p>文件下载下来用Exeinfo PE打开</p>
<p><img src="https://i.loli.net/2020/12/17/nI1zFZEpqGxYKod.png"></p>
<p>解壳过程因为前面题已经有了，所以略过，解壳后的程序用IDA打开，然后发现有一个花指令<br><img src="https://i.loli.net/2020/12/17/TEc4uSCInV3JNzU.png"><br>去花(怎么去花指令可以看看我那篇关于花指令的文章)<br><img src="https://i.loli.net/2020/12/17/2aq83VcfQmzxbWk.png"><br>改E8为90<br><img src="https://i.loli.net/2020/12/17/RUYSBZGnm5QalEf.png"><br>然后p键<br><img src="https://i.loli.net/2020/12/17/gVSRmAnDd5N1KCp.png"><br>f5看伪代码</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
&#123;
  int i; // [esp+10h] [ebp-14h]
  char v5[16]; // [esp+14h] [ebp-10h] BYREF

  sub_401140(aGoThroughTheMa);
  scanf(&quot;%14s&quot;, v5);
  for ( i = 0; i &lt;= 13; ++i )
  &#123;
    switch ( v5[i] )//上下左右键分别为wsad。
    &#123;
      case &#39;a&#39;:
        --*(_DWORD *)asc_408078;
        break;
      case &#39;d&#39;:
        ++*(_DWORD *)asc_408078;
        break;
      case &#39;s&#39;:
        --dword_40807C;
        break;
      case &#39;w&#39;:
        ++dword_40807C;
        break;
      default:
        continue;
    &#125;
  &#125;
  if ( *(_DWORD *)asc_408078 == 5 &amp;&amp; dword_40807C == -4 )//这里是通过你的移动然后改变了asc_408078(初始值是7)，dword_40807C，然后如果这两个值满足这个条件，就是说明到了终点
  &#123;
    sub_401140(aCongratulation);
    sub_401140(aHereIsTheFlagF);
  &#125;
  else
  &#123;
    sub_401140(aTryAgain);
  &#125;
  return 0;
&#125;</code></pre>
<p>shift+12，shift+e，得到地图，<br><img src="https://i.loli.net/2020/12/17/jknacGyVAE5pPrs.png"><br>脚本画出地图</p>
<pre><code>#include&lt;stdio.h&gt;
//ssaaasaassdddw
int main(void)
&#123;
    int a[7][10]=&#123;42,  42,  42,  42,  42,  42,  42,  43,  42,  42, 
   42,  42,  42,  42,  42,  42,  42,  32,  42,  42, 
   42,  42,  42,  42,  32,  32,  32,  32,  42,  42, 
   42,  42,  32,  32,  32,  42,  42,  42,  42,  42, 
   42,  42,  32,  42,  42,  70,  42,  42,  42,  42, 
   42,  42,  32,  32,  32,  32,  42,  42,  42,  42, 
   42,  42,  42,  42,  42,  42,  42,  42,  42,  42, &#125;;
   int i,j;

   for(i=0;i&lt;7;i++)
   &#123;
           for(j=0;j&lt;10;j++)
           &#123;
               printf(&quot;%c&quot;,a[i][j]);
        &#125;
        printf(&quot;\n&quot;);
   &#125;
&#125; </code></pre>
<p>地图7*10的地图</p>
<pre><code>*******+**
******* **
****    **
**   *****
** **F****
**    ****
**********</code></pre>
<p>得到flag{ssaaasaassdddw}</p>
<h3 id="29-WUSTCTF2020-level1"><a href="#29-WUSTCTF2020-level1" class="headerlink" title="29.[WUSTCTF2020]level1"></a>29.[WUSTCTF2020]level1</h3><p>文件下载下来有两个，用IDA打开level1，找到关键代码。<br><img src="https://i.loli.net/2020/12/19/NO97HQij5UrZLwV.png"><br>开始写脚本</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int a[20]=&#123;0,198,232,816,200,1536,300,6144,984,51200,570,92160,1200,565248,756,1474560,800,6291456,1782,65536000&#125;;//注意a[0]设置的值为0；
    int i;

    for(i=1;i&lt;20;i++)
    &#123;
        if(i%2==0)
            a[i]=a[i]/i;
        else
            a[i]=a[i]&gt;&gt;i;
    &#125;
    for(i=1;i&lt;20;i++)
    &#123;
        printf(&quot;%c&quot;,a[i]);
    &#125;
&#125; </code></pre>
<p>得到flag{d9-dE6-20c}</p>
<h3 id="30-WUSTCTF2020-level2"><a href="#30-WUSTCTF2020-level2" class="headerlink" title="30.[WUSTCTF2020]level2"></a>30.[WUSTCTF2020]level2</h3><p>文件下载下来用Exeinfo PE打开，发现是upx加壳<br><img src="https://i.loli.net/2020/12/19/lYVONL5iFDs1fyJ.png"><br>然后解壳<br><img src="https://i.loli.net/2020/12/19/M3QNbAvStiCKV6n.png"><br>再用IDA打开文件，直接就可以看到flag{Just_upx_-d}</p>
<h3 id="31-FlareOn4-IgniteMe"><a href="#31-FlareOn4-IgniteMe" class="headerlink" title="31.[FlareOn4]IgniteMe"></a>31.[FlareOn4]IgniteMe</h3><p>这道题需要IDA静态调试和x32dbg动态调试一起。</p>
<p>先放到IDA里面<br><img src="https://i.loli.net/2020/12/19/7BOHJDiIbowkVTR.png"><br>在继续到x32dbg里面看主函数框架。<br><img src="https://i.loli.net/2020/12/19/5rsFEleQfynDSXu.png"><br>然后进入那个比较函数。<br><img src="https://i.loli.net/2020/12/19/kuF9NYHnz2a5WZi.png"><br>现在就来动调找v4的值，在x32dbg里面进入那个比较函数之后。<br><img src="https://i.loli.net/2020/12/19/q8phQB2SJExDfYZ.png"><br>得到v4=4，现在开始写脚本，如下。</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int v4[40]=&#123; 0x0D, 0x26, 0x49, 0x45, 0x2A, 0x17, 0x78, 0x44, 0x2B, 0x6C, 
  0x5D, 0x5E, 0x45, 0x12, 0x2F, 0x17, 0x2B, 0x44, 0x6F, 0x6E, 
  0x56, 0x09, 0x5F, 0x45, 0x47, 0x73, 0x26, 0x0A, 0x0D, 0x13, 
  0x17, 0x48, 0x42, 0x01, 0x40, 0x4D, 0x0C, 0x02, 0x69&#125;;//byte_403000[]的内容。注意我设置v4的长度为40。
   int i;

   v4[39]=4; //v4的值
   for(i=38;i&gt;=0;i--)//得到flag的值
   &#123;
       v4[i]=v4[i]^v4[i+1];
       printf(&quot;%c &quot;,v4[i]);
   &#125;
   printf(&quot;\n&quot;);
   for(i=0;i&lt;39;i++)//正序输出
   &#123;
       printf(&quot;%c&quot;,v4[i]);
   &#125;
 &#125; </code></pre>
<h3 id="32-MRCTF2020-Xor"><a href="#32-MRCTF2020-Xor" class="headerlink" title="32.[MRCTF2020]Xor"></a>32.[MRCTF2020]Xor</h3><p>IDA打开<br><img src="https://i.loli.net/2020/12/19/7LTiMcHzV3pkSly.png"><br>然后f5，看关键代码。<br><img src="https://i.loli.net/2020/12/19/zNTCW7rw6kP5StB.png"><br>开始写脚本。</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int a[27]=&#123;&#39;M&#39;, &#39;S&#39;, &#39;A&#39;, &#39;W&#39;, &#39;B&#39;, &#39;~&#39;, &#39;F&#39;, &#39;X&#39;, &#39;Z&#39;, &#39;:&#39;, &#39;J&#39;, &#39;:&#39;, &#39;`&#39;, &#39;t&#39;, &#39;Q&#39;, &#39;J&#39;, &#39;&quot;&#39;, &#39;N&#39;, &#39;@&#39;, &#39; &#39;, &#39;b&#39;, &#39;p&#39;, &#39;d&#39;, &#39;d&#39;, &#39;&#125;&#39;, &#39;8&#39;, &#39;g&#39;&#125;;
    int i;

    for(i=0;i&lt;27;i++)
    &#123;
        a[i]=a[i]^i;
        printf(&quot;%c&quot;,a[i]);
    &#125;
 &#125; </code></pre>
<p>得到flag{@_R3@1ly_E2_R3verse!}</p>
<h3 id="33-GKCTF2020-BabyDriver"><a href="#33-GKCTF2020-BabyDriver" class="headerlink" title="33.[GKCTF2020]BabyDriver"></a>33.[GKCTF2020]BabyDriver</h3><p>迷宫题，IDA打开</p>
<pre><code>__int64 __fastcall sub_140001380(__int64 a1, __int64 a2)
&#123;
  __int64 v3; // rdi
  __int64 v4; // rax
  int v5; // ecx
  __int16 *v6; // rsi
  __int64 v7; // rbp
  __int16 v8; // dx
  char v9; // dl
  const CHAR *v10; // rcx

  if ( *(int *)(a2 + 48) &gt;= 0 )
  &#123;
    v3 = *(_QWORD *)(a2 + 24);
    v4 = *(_QWORD *)(a2 + 56) &gt;&gt; 3;
    if ( (_DWORD)v4 )
    &#123;
      v5 = dword_1400030E4;
      v6 = (__int16 *)(v3 + 2);
      v7 = (unsigned int)v4;
      while ( *(_WORD *)(v3 + 4) )
      &#123;
LABEL_28:
        v6 += 6;
        if ( !--v7 )
          goto LABEL_29;
      &#125;
      aO[v5] = 46;
      v8 = *v6;
      if ( *v6 == 23 )
      &#123;
        if ( (v5 &amp; 0xFFFFFFF0) != 0 )
        &#123;
          v5 -= 16;//可以知道宽度为16
          goto LABEL_21;
        &#125;
        v5 += 208;
        dword_1400030E4 = v5;
      &#125;
      if ( v8 == 37 )
      &#123;
        if ( (v5 &amp; 0xFFFFFFF0) != 208 )
        &#123;
          v5 += 16;
          goto LABEL_21;
        &#125;
        v5 -= 208;
        dword_1400030E4 = v5;
      &#125;
      if ( v8 == 36 )
      &#123;
        if ( (v5 &amp; 0xF) != 0 )
        &#123;
          --v5;
          goto LABEL_21;
        &#125;
        v5 += 15;
        dword_1400030E4 = v5;
      &#125;
      if ( v8 != 38 )
        goto LABEL_22;
      if ( (v5 &amp; 0xF) == 15 )
        v5 -= 15;
      else
        ++v5;
LABEL_21:
      dword_1400030E4 = v5;
LABEL_22:
      v9 = aO[v5];
      if ( v9 == 42 )//等于42(*)就不行。
      &#123;
        v10 = &quot;failed!\n&quot;;
      &#125;
      else
      &#123;
        if ( v9 != 35 )//35(#),结尾
        &#123;
LABEL_27:
          aO[v5] = 111;//111(o),开头
          goto LABEL_28;
        &#125;
        v10 = &quot;success! flag is flag&#123;md5(input)&#125;\n&quot;;//最后得到的移动字符串还要进行md5加密。
      &#125;
      dword_1400030E4 = 16;
      DbgPrint(v10);
      v5 = dword_1400030E4;
      goto LABEL_27;
    &#125;
  &#125;
LABEL_29:
  if ( *(_BYTE *)(a2 + 65) )
    *(_BYTE *)(*(_QWORD *)(a2 + 184) + 3i64) |= 1u;
  return *(unsigned int *)(a2 + 48);
&#125;</code></pre>
<p>大概分析一下就是a0[i]是迷宫是一个，14(行)*16(列)的迷宫，v5是到达的位置(也就是a0[i]中的i)，然后35(#)结尾，111(o)开头。上下左右分别是23，37，36,38。</p>
<p>shift+e提取迷宫<br><img src="https://i.loli.net/2020/12/19/blpFrxXDqvYza64.png"><br><img src="https://i.loli.net/2020/12/19/hOInAwMirtNuEoD.png"><br>开始走迷宫，得到38373737383837383737373838383737373838383838，然后进行md5加密，发现提交时不对，然后去看了wp，发现由于这是sys驱动文件，是由键盘过滤驱动获取键盘扫描码来控制上下左右，所以上下左右不是这几个值，而是IKJL。</p>
<p>键盘扫描码<br><img src="https://i.loli.net/2020/12/19/Z47irEXJHSOceTC.png"><br>最后得到flag{403950a6f64f7fc4b655dea696997851}</p>
<h3 id="34-MRCTF2020-hello-world-go"><a href="#34-MRCTF2020-hello-world-go" class="headerlink" title="34.[MRCTF2020]hello_world_go"></a>34.[MRCTF2020]hello_world_go</h3><p>文件下载下来，直接用ida打开，选到hex view的窗口，Alt+t，搜索flag，就行了。至于为什么这么做，是因为shift+12出来的字符串太多了。也可以直接改文件后缀名为.txt，然后记事本打开搜索flag。</p>
<p>最后得到flag{hello_world_gogogo}</p>
<h3 id="35-WUSTCTF2020-level3"><a href="#35-WUSTCTF2020-level3" class="headerlink" title="35.[WUSTCTF2020]level3"></a>35.[WUSTCTF2020]level3</h3><p>这是一道该base表的题。IDA打开<br><img src="https://i.loli.net/2020/12/24/7C6T1SJRyYwxuPr.png"><br>如果直接解的话，会是这个结果wa�f2�4�c�d4_is_p�e_stӲt�of_reverq�|，感觉有一点flag的影子，推测是变表的base编码。然后由于眼瞎找了半天才找到这个位置。<br><img src="https://i.loli.net/2020/12/24/wSiebnE5tok8Tr9.png"><br>开始写脚本</p>
<pre><code>import base64
import string

str1 = &quot;d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD==&quot;

string1 = &quot;TSRQPONMLKJIHGFEDCBAUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;
string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;

print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))</code></pre>
<p>得到flag{Base64_is_the_start_of_reverse}</p>
<h3 id="36-FlareOn6-Overlong"><a href="#36-FlareOn6-Overlong" class="headerlink" title="36.[FlareOn6]Overlong"></a>36.[FlareOn6]Overlong</h3><p>文件下载下来，还有提示，说是flag被以一种方式藏了起来，直接打开，会弹出一个窗口。<br><img src="https://i.loli.net/2020/12/24/cP2B4OVTRyC5ma8.png"></p>
<p>然后拖到IDA里面，代码很少。<br><img src="https://i.loli.net/2020/12/24/qDuIPERnAbB3Ygd.png"><br>然后通过动调来该那个28，将他改成&amp;unk_402008的长度B7-8。<br><img src="https://i.loli.net/2020/12/24/Nk57GtVsTcb4Z9C.png"><br>然后改1C为AF。<br><img src="https://i.loli.net/2020/12/24/kEH73LARtJ9uQzx.png"><br>得到flag<br><img src="https://i.loli.net/2020/12/24/IoWNlTjsA3BkYUg.png"></p>
<h3 id="37-WUSTCTF2020-Cr0ssfun"><a href="#37-WUSTCTF2020-Cr0ssfun" class="headerlink" title="37.[WUSTCTF2020]Cr0ssfun"></a>37.[WUSTCTF2020]Cr0ssfun</h3><p>IDA打开<br><img src="https://i.loli.net/2020/12/24/rTmFlns3vNyj6hW.png"><br>然后开始写脚本</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    puts(&quot; _    _ _   _ _____ _____   _____           &quot;);
      puts(&quot;| |  | | | | /  ___|_   _| /  ___|          &quot;);
      puts(&quot;| |  | | | | \\ `--.  | |   \\ `--.  ___  ___ &quot;);
      puts(&quot;| |/\\| | | | |`--. \\ | |    `--. \\/ _ \\/ __|&quot;);
      puts(&quot;\\  /\\  / |_| /\\__/ / | |   /\\__/ /  __/ (__ &quot;);
      puts(&quot; \\/  \\/ \\___/\\____/  \\_/   \\____/ \\___|\\___|&quot;);

      int a1[42];
      int i;
      printf(&quot;\n&quot;);
    a1[10] = 112;
    a1[13] = 64;
    a1[3] = 102;
    a1[26] = 114;
    a1[20] = 101;
    a1[7] =48;
       a1[16] =95;
       a1[11] = 112;
    a1[23] =101;
    a1[30] = 117;
    a1[0] = 119;
    a1[6] = 50;
    a1[22] = 115;
    a1[31] = 110;
    a1[12] = 95 ;
    a1[15] = 100;
    a1[8] = 123;
    a1[18] = 51;
    a1[28] = 95;
    a1[21] = 114;
    a1[2] = 116;
    a1[9] = 99;
    a1[32] = 125;
    a1[19] = 118;
    a1[5] = 48;
    a1[14] = 110;
    a1[4] = 50;
    a1[17] = 114;
    a1[29] = 102;
    a1[17] = 114;
    a1[24] = 95;
    a1[1] = 99;
    a1[25] = 64;
    a1[27] = 101;

    for(i=0;i&lt;42;i++)
    &#123;
        printf(&quot;%c&quot;,a1[i]);
    &#125;
 &#125; </code></pre>
<p>得到flag{cpp_@nd_r3verse_@re_fun}</p>
<h3 id="38-ACTF新生赛2020-Oruga"><a href="#38-ACTF新生赛2020-Oruga" class="headerlink" title="38.[ACTF新生赛2020]Oruga"></a>38.[ACTF新生赛2020]Oruga</h3><p>这道题类似于迷宫题，只不过走的方式有些特别。<br><img src="https://i.loli.net/2020/12/24/RecB9yZq1oaXv5O.png"><br>下面来分析如何走的迷宫。<br><img src="https://i.loli.net/2020/12/24/SenlCgwKvuP6TyO.png"><br>得到flag{MEWEMEWJMEWJM}</p>
<h3 id="39-MRCTF2020-Transform"><a href="#39-MRCTF2020-Transform" class="headerlink" title="39.[MRCTF2020]Transform"></a>39.[MRCTF2020]Transform</h3><p>IDA打开，找到关键代码<br><img src="https://i.loli.net/2020/12/24/df4E7X5C2V63kYh.png"><br>开始写脚本</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int a[33]=&#123;  103, 121, 123, 127, 117,  43,  60,  82,  83, 121, 
   87,  94,  93,  66, 123,  45,  42, 102,  66, 126, 
   76,  87, 121,  65, 107, 126, 101,  60,  92,  69, 
  111,  98,  77&#125;;
      int b[33]=&#123;9,0x0a,0x0f,0x17,7,0x18,0x0c,6,1,0x10,3,0x11,0x20,0x1d,0x0b,0x1e,0x1b,0x16,4,0x0d,0x13,0x14,0x15,2,0x19,5,0x1f,8,0x12,0x1a,0x1c,0x0e,0&#125;;
      int flag[33];
      int i,j;

      for(i=0;i&lt;33;i++)
      &#123;
          flag[i]=a[i]^b[i];
          printf(&quot;%c&quot;,flag[i]);
    &#125;
    printf(&quot;\n&quot;);
    for(i=0;i&lt;33;i++)
    &#123;
        for(j=0;j&lt;33;j++)
        &#123;
            if(b[j]==i)
            printf(&quot;%c&quot;,flag[j]);
        &#125;
    &#125;
 &#125; </code></pre>
<p>得到flag{Tr4nsp0sltiON_Clph3r_1s_3z}</p>
<h3 id="40-Java逆向解密"><a href="#40-Java逆向解密" class="headerlink" title="40.Java逆向解密"></a>40.Java逆向解密</h3><p>.class文件，用jd-gui打开，得到代码</p>
<pre><code>import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Scanner;

public class Reverse
&#123;
  public static void main(String[] args)
  &#123;
    Scanner s = new Scanner(System.in);
    System.out.println(&quot;Please input the flag ��&quot;);
    String str = s.next();
    System.out.println(&quot;Your input is ��&quot;);
    System.out.println(str);
    char[] stringArr = str.toCharArray();
    Encrypt(stringArr);
  &#125;

  public static void Encrypt(char[] arr)
  &#123;
    ArrayList&lt;Integer&gt; Resultlist = new ArrayList();
    for (int i = 0; i &lt; arr.length; i++)
    &#123;
      int result = arr[i] + &#39;@&#39; ^ 0x20;
      Resultlist.add(Integer.valueOf(result));
    &#125;
    int[] KEY = &#123; 180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65 &#125;;
    ArrayList&lt;Integer&gt; KEYList = new ArrayList();
    for (int j = 0; j &lt; KEY.length; j++) &#123;
      KEYList.add(Integer.valueOf(KEY[j]));
    &#125;
    System.out.println(&quot;Result:&quot;);
    if (Resultlist.equals(KEYList)) &#123;
      System.out.println(&quot;Congratulations��&quot;);
    &#125; else &#123;
      System.err.println(&quot;Error��&quot;);
    &#125;
  &#125;
&#125;</code></pre>
<p>中间就只有一个result = arr[i] + ‘@’ ^ 0x20;的处理，开始写脚本</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int a[]=&#123;180,136,137,147,191,137,147,191,148,136,133,191,134,140,129,135,191,65&#125;;
    int i;

    for(i=0;i&lt;18;i++)
    &#123;
        a[i]=a[i]-&#39;@&#39;^0x20;
        printf(&quot;%c&quot;,a[i]);
    &#125;
&#125;</code></pre>
<p>得到flag{This_is_the_flag_!}</p>
<h3 id="41-crackMe"><a href="#41-crackMe" class="headerlink" title="41.crackMe"></a>41.crackMe</h3><p>IDA打开，找到主函数。</p>
<pre><code>int wmain()
&#123;
  FILE *v0; // eax
  FILE *v1; // eax
  char v3; // [esp+3h] [ebp-405h]
  char v4; // [esp+4h] [ebp-404h] BYREF
  char v5[255]; // [esp+5h] [ebp-403h] BYREF
  char Format; // [esp+104h] [ebp-304h] BYREF
  char v7[255]; // [esp+105h] [ebp-303h] BYREF
  char v8; // [esp+204h] [ebp-204h] BYREF
  char v9[255]; // [esp+205h] [ebp-203h] BYREF
  char v10; // [esp+304h] [ebp-104h] BYREF
  char v11[255]; // [esp+305h] [ebp-103h] BYREF

  printf(&quot;Come one! Crack Me~~~\n&quot;);
  v10 = 0;
  memset(v11, 0, sizeof(v11));
  v8 = 0;
  memset(v9, 0, sizeof(v9));
  while ( 1 )
  &#123;
    do
    &#123;
      do
      &#123;
        printf(&quot;user(6-16 letters or numbers):&quot;);
        scanf(&quot;%s&quot;, &amp;v10);  //这里是输入的用户名
        v0 = (FILE *)sub_4024BE();
        fflush(v0);
      &#125;
      while ( !(unsigned __int8)sub_401000(&amp;v10) );
      printf(&quot;password(6-16 letters or numbers):&quot;);
      scanf(&quot;%s&quot;, &amp;v8);  //输入的密码，注意这里输入的是字符。
      v1 = (FILE *)sub_4024BE();
      fflush(v1);
    &#125;
    while ( !(unsigned __int8)sub_401000(&amp;v8) );
    sub_401090(&amp;v10); //对用户名进行了一个操作，这个函数没有什么用。
    Format = 0;
    memset(v7, 0, sizeof(v7));
    v4 = 0;
    memset(v5, 0, sizeof(v5));
    v3 = ((int (__cdecl *)(char *, char *))loc_4011A0)(&amp;Format, &amp;v4);  //这里要去花，最后得到Format=congratulation   v4=Please try again
    if ( sub_401830((int)&amp;v10, &amp;v8) )//这里是关于用户名和密码的一个函数
    &#123;
      if ( v3 )//v3肯定会等于1。
        break;
    &#125;
    printf(&amp;v4);
  &#125;
  printf(&amp;Format);
  return 0;
&#125;</code></pre>
<p>分析sub_401830函数。</p>
<pre><code>// v7----v15----v17，大概加密过程
bool __usercall sub_401830@&lt;al&gt;(int ebx0@&lt;ebx&gt;, int a1, const char *a2)
&#123;
  int v4; // [esp+18h] [ebp-22Ch]
  signed int v5; // [esp+1Ch] [ebp-228h]
  signed int v6; // [esp+28h] [ebp-21Ch]
  unsigned int v7; // [esp+30h] [ebp-214h]
  char v8; // [esp+36h] [ebp-20Eh]
  char v9; // [esp+37h] [ebp-20Dh]
  char v10; // [esp+38h] [ebp-20Ch]
  unsigned __int8 v11; // [esp+39h] [ebp-20Bh]
  unsigned __int8 v12; // [esp+3Ah] [ebp-20Ah]
  char v13; // [esp+3Bh] [ebp-209h]
  int v14; // [esp+3Ch] [ebp-208h]
  char v15; // [esp+40h] [ebp-204h]
  char v16; // [esp+41h] [ebp-203h]
  char v17; // [esp+140h] [ebp-104h]
  char v18; // [esp+141h] [ebp-103h]

  v5 = 0;
  v6 = 0;
  v12 = 0;
  v11 = 0;
  v17 = 0;
  memset(&amp;v18, 0, 0xFFu);
  v15 = 0;
  memset(&amp;v16, 0, 0xFFu);
  v10 = 0;
  v7 = 0;
  v4 = 0;
  while ( v7 &lt; strlen(a2) )
  &#123;
    if ( isdigit(a2[v7]) )                      // 是不是10进制，若参数c为阿拉伯数字0~9，则返回非0值，否则返回0
    &#123;
      v9 = a2[v7] - 48;//将输入的0~9字符，换为十进制的0~9
    &#125;
    else if ( isxdigit(a2[v7]) )                // 是不是16进制0123456789abcdefABCDEF，是就返回非0
    &#123;
      if ( *(_DWORD *)(*(_DWORD *)(__readfsdword(0x30u) + 24) + 12) != 2 )
        a2[v7] = 34;
      v9 = (a2[v7] | 0x20) - 87;//将输入的abcdefABCDEF，转换为十进制的10~15。
    &#125;
    else
    &#123;
      v9 = ((a2[v7] | 0x20) - 97) % 6 + 10;
    &#125;
    v10 = v9 + 16 * v10;
    if ( !((signed int)(v7 + 1) % 2) )          // 如果a[v7]中的v7是奇数就进入，这个的作用差不多就是，将输入的2个值，然后变成0~15的两个值，再通过v10 = v9 + 16 * v10;，就变成了一个值，给了*v15。例如1，a结果变换后就会变成一个值&#39;1a&#39;=26
    &#123;
      *(&amp;v15 + v4++) = v10;
      ebx0 = v4;
      v10 = 0;
    &#125;
    ++v7;
  &#125;
  while ( v6 &lt; 8 )//实际上从这里可以推测出密码长度为16。
  &#123;
    v11 += byte_416050[++v12];
    v13 = byte_416050[v12];
    v8 = byte_416050[v11];
    byte_416050[v11] = v13;
    byte_416050[v12] = v8;
    if ( *(_DWORD *)(__readfsdword(0x30u) + 104) &amp; 0x70 )// 反调试，调试时if判断改为jmp。
      v13 = v11 + v12;
    *(&amp;v17 + v6) = byte_416050[(unsigned __int8)(v8 + v13)] ^ *(&amp;v15 + v5);//通过这个来得到v15，但是byte_416050[(unsigned __int8)(v8 + v13)]需要动调来获得。
    if ( *(_DWORD *)(__readfsdword(0x30u) + 2) &amp; 0xFF )// 反调试，调试时if判断改为jmp。
    &#123;
      v11 = -83;
      v12 = 43;
    &#125;
    sub_401710((int)&amp;v17, (const char *)a1, v6++);
    v5 = v6;
    if ( v6 &gt;= (unsigned int)(&amp;v15 + strlen(&amp;v15) + 1 - &amp;v16) )
      v5 = 0;
  &#125;
  v14 = 0;
  sub_401470(ebx0, &amp;v17, &amp;v14);     // 要让v14!=0，所以if里面的条件都要满足，只不过要注意里面有一个a1[5]是反调试， 得到v17=dbappsec
  return v14 == 0xAB94;
&#125;</code></pre>
<p>现在已经知道了v17，现在通过动调来获得byte_416050[(unsigned __int8)(v8 + v13)]，从而得到，&amp;15。<br><img src="https://i.loli.net/2020/12/26/mELNeYIar94kPJG.png"><br>图片中有个错误，应该是记录ecx的值</p>
<p>开始写脚本</p>
<pre><code>#include&lt;stdio.h&gt;

int main(void)
&#123;
    int a[8]=&#123;0x2a,0xd7,0x92,0xe9,0x53,0xe2,0xc4,0xcd&#125;;//动调得到的byte_416050[(unsigned __int8)(v8 + v13)]，也就是ecx。
    int b[8]=&#123;&#39;d&#39;, &#39;b&#39;, &#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;s&#39;, &#39;e&#39;, &#39;c&#39;&#125;;
    int c[8];
    int d[16];
    int i,j,m,n;

    for(i=0;i&lt;8;i++)
    &#123;
        c[i]=b[i]^a[i];
        printf(&quot;%d &quot;,c[i]);
    &#125;
    for(i=0,j=0;i&lt;8;i++,j+=2)
    &#123;
        m=c[i]/16;
        n=c[i]%16;
        d[j]=m;
        d[j+1]=n;
    &#125;
    for(j=0;j&lt;16;j++)
    &#123;
        if(d[j]&lt;10)
        printf(&quot;%d&quot;,d[j]);
        else
        printf(&quot;%c&quot;,d[j]+87);
    &#125;
&#125; </code></pre>
<p>得到4eb5f3992391a1ae，再进行MD5加密得到flag{d2be2981b84f2a905669995873d6a36c}</p>
<h3 id="42-刮开有奖"><a href="#42-刮开有奖" class="headerlink" title="42.刮开有奖"></a>42.刮开有奖</h3><pre><code>INT_PTR __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
&#123;
  const char *v4; // esi
  const char *v5; // edi
  int v7[2]; // [esp+8h] [ebp-20030h] BYREF
  int v8; // [esp+10h] [ebp-20028h]
  int v9; // [esp+14h] [ebp-20024h]
  int v10; // [esp+18h] [ebp-20020h]
  int v11; // [esp+1Ch] [ebp-2001Ch]
  int v12; // [esp+20h] [ebp-20018h]
  int v13; // [esp+24h] [ebp-20014h]
  int v14; // [esp+28h] [ebp-20010h]
  int v15; // [esp+2Ch] [ebp-2000Ch]
  int v16; // [esp+30h] [ebp-20008h]
  CHAR String[65536]; // [esp+34h] [ebp-20004h] BYREF
  char v18[65536]; // [esp+10034h] [ebp-10004h] BYREF

  if ( a2 == 272 )
    return 1;
  if ( a2 != 273 )
    return 0;
  if ( (_WORD)a3 == 1001 )
  &#123;
    memset(String, 0, 0xFFFFu);
    GetDlgItemTextA(hDlg, 1000, String, 0xFFFF);//这里的string是flag。
    if ( strlen(String) == 8 )
    &#123;
      v7[0] = 90;
      v7[1] = 74;
      v8 = 83;
      v9 = 69;
      v10 = 67;
      v11 = 97;
      v12 = 78;
      v13 = 72;
      v14 = 51;
      v15 = 110;
      v16 = 103;//上面10个数都是v7[]
      sub_4010F0(v7, 0, 10);//对v7[]进行了处理。
      memset(v18, 0, 0xFFFFu);
      v18[0] = String[5];
      v18[2] = String[7];
      v18[1] = String[6];
      v4 = (const char *)sub_401000(v18, strlen(v18));//sub_401000是长得比较丑的base64编码。对String[5]，String[6]，String[7]3个字母编码，得到了v4。
      memset(v18, 0, 0xFFFFu);
      v18[1] = String[3];
      v18[0] = String[2];
      v18[2] = String[4];
      v5 = (const char *)sub_401000(v18, strlen(v18));对String[2]，String[3]，String[4]3个字母编码，得到了v5。
      if ( String[0] == v7[0] + 34//得到sting[0]
        &amp;&amp; String[1] == v10//得到sting[1]
        &amp;&amp; 4 * String[2] - 141 == 3 * v8
        &amp;&amp; String[3] / 4 == 2 * (v13 / 9)
        &amp;&amp; !strcmp(v4, &quot;ak1w&quot;)//通过这个来得到String[5]，String[6]，String[7]。&#39;jMp&#39;
        &amp;&amp; !strcmp(v5, &quot;V1Ax&quot;) )//通过这个来得到，String[2]，String[3]，String[4]。&#39;WP1&#39;
      &#123;
        MessageBoxA(hDlg, &quot;U g3t 1T!&quot;, &quot;@_@&quot;, 0);
      &#125;
    &#125;
    return 0;
  &#125;
  if ( (_WORD)a3 != 1 &amp;&amp; (_WORD)a3 != 2 )
    return 0;
  EndDialog(hDlg, (unsigned __int16)a3);
  return 1;
&#125;</code></pre>
<p>现在看sub_4010F0对v7[]进行了什么操作</p>
<pre><code>int __cdecl sub_4010F0(int a1, int a2, int a3)
&#123;
  int result; // eax
  int i; // esi
  int v5; // ecx
  int v6; // edx

  result = a3;
  for ( i = a2; i &lt;= a3; a2 = i )
  &#123;
    v5 = 4 * i;
    v6 = *(_DWORD *)(4 * i + a1);
    if ( a2 &lt; result &amp;&amp; i &lt; result )
    &#123;
      do
      &#123;
        if ( v6 &gt; *(_DWORD *)(a1 + 4 * result) )
        &#123;
          if ( i &gt;= result )
            break;
          ++i;
          *(_DWORD *)(v5 + a1) = *(_DWORD *)(a1 + 4 * result);
          if ( i &gt;= result )
            break;
          while ( *(_DWORD *)(a1 + 4 * i) &lt;= v6 )
          &#123;
            if ( ++i &gt;= result )
              goto LABEL_13;
          &#125;
          if ( i &gt;= result )
            break;
          v5 = 4 * i;
          *(_DWORD *)(a1 + 4 * result) = *(_DWORD *)(4 * i + a1);
        &#125;
        --result;
      &#125;
      while ( i &lt; result );
    &#125;
LABEL_13:
    *(_DWORD *)(a1 + 4 * result) = v6;
    sub_4010F0(a1, a2, i - 1);//这里还有个递归
    result = a3;
    ++i;
  &#125;
  return result;
&#125;</code></pre>
<p>由于所有值都知道，所以可以直接复制下来，得到改变后的v7[]。需要注意的是，里面出现的(_DWORD *)都删了，特别是4 *也要删除，原因是这些变量都是int型(占了4个字节)，而这部分在IDA里面看汇编代码<br><img src="https://i.loli.net/2020/12/26/K4ebXYPm32pUu8F.png"><br>开始写脚本得到v7[]</p>
<pre><code>#include&lt;stdio.h&gt;
int fun(int *a1,int a2,int a3)
&#123;
    int result; // eax
  int i; // esi
  int v5; // ecx
  int v6; // edx

  result = a3;
  for ( i = a2; i &lt;= a3; a2 = i )
  &#123;
    v5 =i;
    v6 = *( i + a1);
    if ( a2 &lt; result &amp;&amp; i &lt; result )
    &#123;
      do
      &#123;
        if ( v6 &gt; *(a1 + result) ) 
        &#123;
          if ( i &gt;= result )
            break;
          ++i;
          *(v5 + a1) = *(a1 +result);
          if ( i &gt;= result )
            break;
          while ( *(a1 + i) &lt;= v6 )
          &#123;
            if ( ++i &gt;= result )
              goto LABEL_13;
          &#125;
          if ( i &gt;= result )
            break;
          v5 = i;
          *(a1 + result) = *(i + a1);
        &#125;
        --result;
      &#125;
      while ( i &lt; result );
    &#125;
LABEL_13:
    *(a1 +result) = v6;
    fun(a1, a2, i - 1);
    result = a3;
    ++i;
  &#125;
  return result;

&#125;
int main(void)
&#123;
    int v7[11]=&#123;90,74,83,69,67,97,78,72,51,110,103&#125;;
    int i;
    fun(v7,0,10);
    for(i=0;i&lt;11;i++)
    &#123;
        printf(&quot;%d &quot;,v7[i]); 
    &#125;
 &#125; </code></pre>
<p>得到v7=51 67 69 72 74 78 83 90 97 103 110;从而得到string[0]=’U’，string[1]=’J’</p>
<p>得到flag{UJjMpWP1}</p>
<h3 id="43-ACTF新生赛2020-rome"><a href="#43-ACTF新生赛2020-rome" class="headerlink" title="43.[ACTF新生赛2020]rome"></a>43.[ACTF新生赛2020]rome</h3><p>脚本</p>
<pre><code>code=list(&#39;Qsw3sj_lz4_Ujw@l&#39;)
flag=&#39;&#39;
i=0
while(i&lt;=15):
    for k in range(0,127):
        z=k
        if(64 &lt; k &lt;= 90):
            k = (k - 51) % 26 + 65
        if(96&lt;k&lt;=122):
            k = (k - 79) % 26 + 97
        if(chr(k)==code[i]):
            flag += chr(z)
    i=i+1
print(flag)</code></pre>
<h2 id="Crypto方向"><a href="#Crypto方向" class="headerlink" title="Crypto方向"></a>Crypto方向</h2><h3 id="1-BJDCTF2020-这是base"><a href="#1-BJDCTF2020-这是base" class="headerlink" title="1.[BJDCTF2020]这是base??"></a>1.[BJDCTF2020]这是base??</h3><p>下载下来得到一个txt文件，发现是一个换表的base64编码的密文。写出脚本如下</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;malloc.h&gt; 

int main(void)
&#123;
    char str1[100]=&quot;FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKw&quot;;
    char str2[100];
    int table[]=&#123;0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,62,0,0,0,
             63,42,43,44,45,46,47,48,
             19,20,21,0,0,0,0,0,0,0,11,
             12,13,14,15,16,17,18,24,0,1,2,3,
             4,5,22,23,49,50,51,8,9,
             38,39,40,41,0,0,0,0,0,0,25,
             26,27,28,29,30,31,32,33,34,
             35,36,37,52,53,54,55,56,57,
             58,59,60,61,6,7,10
           &#125;; 

    int len1;
    int len2;
    int i,j; 

    len1=strlen(str1);
    if(strstr(str1,&quot;==&quot;))
    &#123;
        len2=(len1/4)*3-2;
    &#125;   
    else if(strstr(str1,&quot;=&quot;))
    &#123;
        len2=(len1/4)*3-1;
    &#125;
    else
    &#123;
        len2=(len1/4)*3;
    &#125;

    for(i=0,j=0;i&lt;len1-2;i+=4,j+=3)
    &#123;
        str2[j]=((table[str1[i]])&lt;&lt;2)|((table[str1[i+1]])&gt;&gt;4);
        str2[j+1]=(table[str1[i+1]]&lt;&lt;4)|((table[str1[i+2]])&gt;&gt;2);
        str2[j+2]=((table[str1[i+2]])&lt;&lt;6)|(table[str1[i+3]]);
    &#125;


//  printf(&quot;%d&quot;,len2); 
    for(i=0;i&lt;len2;i++)
    &#123;
        printf(&quot;%c&quot;,str2[i]);
    &#125;
    return 0;
 &#125; </code></pre>
<p>得到flag{D0_Y0u_kNoW_Th1s_b4se_map}</p>
<p>网上找的Python脚本如下</p>
<pre><code>import base64
dict=&#123;0: &#39;J&#39;, 1: &#39;K&#39;, 2: &#39;L&#39;, 3: &#39;M&#39;, 4: &#39;N&#39;, 5: &#39;O&#39;, 6: &#39;x&#39;, 7: &#39;y&#39;, 8: &#39;U&#39;, 9: &#39;V&#39;, 10: &#39;z&#39;, 11: &#39;A&#39;, 12: &#39;B&#39;, 13: &#39;C&#39;, 14: &#39;D&#39;, 15: &#39;E&#39;, 16: &#39;F&#39;, 17: &#39;G&#39;, 18: &#39;H&#39;, 19: &#39;7&#39;, 20: &#39;8&#39;, 21: &#39;9&#39;, 22: &#39;P&#39;, 23: &#39;Q&#39;, 24: &#39;I&#39;, 25: &#39;a&#39;, 26: &#39;b&#39;, 27: &#39;c&#39;, 28: &#39;d&#39;, 29: &#39;e&#39;, 30: &#39;f&#39;, 31: &#39;g&#39;, 32: &#39;h&#39;,33: &#39;i&#39;, 34: &#39;j&#39;, 35: &#39;k&#39;, 36: &#39;l&#39;, 37: &#39;m&#39;, 38: &#39;W&#39;, 39: &#39;X&#39;, 40: &#39;Y&#39;, 41: &#39;Z&#39;, 42: &#39;0&#39;, 43: &#39;1&#39;, 44: &#39;2&#39;, 45: &#39;3&#39;, 46: &#39;4&#39;, 47: &#39;5&#39;, 48: &#39;6&#39;, 49: &#39;R&#39;, 50: &#39;S&#39;, 51: &#39;T&#39;, 52: &#39;n&#39;, 53: &#39;o&#39;, 54: &#39;p&#39;, 55: &#39;q&#39;, 56: &#39;r&#39;, 57: &#39;s&#39;, 58: &#39;t&#39;, 59: &#39;u&#39;, 60: &#39;v&#39;, 61: &#39;w&#39;, 62: &#39;+&#39;, 63: &#39;/&#39;, 64: &#39;=&#39;&#125;
base64_list = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;,&#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,&#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;,&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;+&#39;, &#39;/&#39;]
cipher=&#39;FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKw&#39;
res=&#39;&#39;
for i in range(len(cipher)):
    for j in range(64):
        if(dict[j]==cipher[i]):
            res+=base64_list[j]
flag=base64.b64decode(res)
print(flag)</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">The_Itach1</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2020/12/02/buuctf%E7%9A%84wp/">http://example.com/2020/12/02/buuctf%E7%9A%84wp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/12/02/GBH9cj7JztSasMh.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/08/%E6%A0%88%E6%BA%A2%E5%87%BA/"><img class="prev-cover" src="https://i.loli.net/2020/12/08/HBtf36VNDlrLqQU.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">栈溢出</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/30/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://i.loli.net/2020/11/30/dSi6rUhR2nE1MlY.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">学习汇编的一些记录</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/5.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">The_Itach1</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">44</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#buuCTF%E7%9A%84wp"><span class="toc-number">1.</span> <span class="toc-text">buuCTF的wp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#re%E6%96%B9%E5%90%91"><span class="toc-number">1.1.</span> <span class="toc-text">re方向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-easyre"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.easyre</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-reverse1"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.reverse1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-reverse2"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.reverse2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E6%B6%B5%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.内涵的软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90"><span class="toc-number">1.1.5.</span> <span class="toc-text">5.新年快乐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-BJDCTF-2nd-guessgame"><span class="toc-number">1.1.6.</span> <span class="toc-text">6.[BJDCTF 2nd]guessgame</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-helloword"><span class="toc-number">1.1.7.</span> <span class="toc-text">7.helloword</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-xor"><span class="toc-number">1.1.8.</span> <span class="toc-text">8.xor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-reverse3"><span class="toc-number">1.1.9.</span> <span class="toc-text">9.reverse3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag"><span class="toc-number">1.1.10.</span> <span class="toc-text">10.不一样的flag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-SimpleRev"><span class="toc-number">1.1.11.</span> <span class="toc-text">11.SimpleRev</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-BJDCTF-2nd-8086"><span class="toc-number">1.1.12.</span> <span class="toc-text">12.[BJDCTF 2nd]8086</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-GKCTF2020-Check-1n"><span class="toc-number">1.1.13.</span> <span class="toc-text">13.[GKCTF2020]Check_1n</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-findit"><span class="toc-number">1.1.14.</span> <span class="toc-text">14.findit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-GXYCTF2019-luck-guy"><span class="toc-number">1.1.15.</span> <span class="toc-text">15.[GXYCTF2019]luck_guy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E7%AE%80%E5%8D%95%E6%B3%A8%E5%86%8C%E5%99%A8"><span class="toc-number">1.1.16.</span> <span class="toc-text">16.简单注册器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-GWCTF-2019-pyre"><span class="toc-number">1.1.17.</span> <span class="toc-text">17.[GWCTF 2019]pyre</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-rsa"><span class="toc-number">1.1.18.</span> <span class="toc-text">18.rsa</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-JustRE"><span class="toc-number">1.1.19.</span> <span class="toc-text">19.JustRE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-easyRE"><span class="toc-number">1.1.20.</span> <span class="toc-text">20.[2019红帽杯]easyRE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020-easyre"><span class="toc-number">1.1.21.</span> <span class="toc-text">21.[ACTF新生赛2020]easyre</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-SUCTF2019-SignIn"><span class="toc-number">1.1.22.</span> <span class="toc-text">22.[SUCTF2019]SignIn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-Youngter-drive"><span class="toc-number">1.1.23.</span> <span class="toc-text">23.Youngter-drive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-GUET-CTF2019-re"><span class="toc-number">1.1.24.</span> <span class="toc-text">24.[GUET-CTF2019]re</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-FlareOn4-login"><span class="toc-number">1.1.25.</span> <span class="toc-text">25.[FlareOn4]login</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020-usualCrypt"><span class="toc-number">1.1.26.</span> <span class="toc-text">26.[ACTF新生赛2020]usualCrypt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-GWCTF-2019-xxor"><span class="toc-number">1.1.27.</span> <span class="toc-text">27.[GWCTF 2019]xxor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-HDCTF2019-Maze"><span class="toc-number">1.1.28.</span> <span class="toc-text">28.[HDCTF2019]Maze</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-WUSTCTF2020-level1"><span class="toc-number">1.1.29.</span> <span class="toc-text">29.[WUSTCTF2020]level1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-WUSTCTF2020-level2"><span class="toc-number">1.1.30.</span> <span class="toc-text">30.[WUSTCTF2020]level2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-FlareOn4-IgniteMe"><span class="toc-number">1.1.31.</span> <span class="toc-text">31.[FlareOn4]IgniteMe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-MRCTF2020-Xor"><span class="toc-number">1.1.32.</span> <span class="toc-text">32.[MRCTF2020]Xor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-GKCTF2020-BabyDriver"><span class="toc-number">1.1.33.</span> <span class="toc-text">33.[GKCTF2020]BabyDriver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-MRCTF2020-hello-world-go"><span class="toc-number">1.1.34.</span> <span class="toc-text">34.[MRCTF2020]hello_world_go</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-WUSTCTF2020-level3"><span class="toc-number">1.1.35.</span> <span class="toc-text">35.[WUSTCTF2020]level3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-FlareOn6-Overlong"><span class="toc-number">1.1.36.</span> <span class="toc-text">36.[FlareOn6]Overlong</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-WUSTCTF2020-Cr0ssfun"><span class="toc-number">1.1.37.</span> <span class="toc-text">37.[WUSTCTF2020]Cr0ssfun</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020-Oruga"><span class="toc-number">1.1.38.</span> <span class="toc-text">38.[ACTF新生赛2020]Oruga</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-MRCTF2020-Transform"><span class="toc-number">1.1.39.</span> <span class="toc-text">39.[MRCTF2020]Transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-Java%E9%80%86%E5%90%91%E8%A7%A3%E5%AF%86"><span class="toc-number">1.1.40.</span> <span class="toc-text">40.Java逆向解密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-crackMe"><span class="toc-number">1.1.41.</span> <span class="toc-text">41.crackMe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96"><span class="toc-number">1.1.42.</span> <span class="toc-text">42.刮开有奖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020-rome"><span class="toc-number">1.1.43.</span> <span class="toc-text">43.[ACTF新生赛2020]rome</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Crypto%E6%96%B9%E5%90%91"><span class="toc-number">1.2.</span> <span class="toc-text">Crypto方向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BJDCTF2020-%E8%BF%99%E6%98%AFbase"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.[BJDCTF2020]这是base??</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/02/%E7%AE%80%E5%8D%95%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/" title="Simple software cracking"><img src="https://i.loli.net/2021/12/02/gaPGbVDE1NFzupY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Simple software cracking"/></a><div class="content"><a class="title" href="/2021/12/02/%E7%AE%80%E5%8D%95%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/" title="Simple software cracking">Simple software cracking</a><time datetime="2021-12-02T07:03:18.230Z" title="Created 2021-12-02 15:03:18">2021-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/30/%E5%AE%89%E6%B4%B5%E7%BA%BF%E4%B8%8Are%E5%87%BA%E9%A2%98%E6%80%BB%E7%BB%93/" title="安洵杯线上re出题总结"><img src="https://i.loli.net/2021/12/01/cVfjCn3qUIOhkXv.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安洵杯线上re出题总结"/></a><div class="content"><a class="title" href="/2021/11/30/%E5%AE%89%E6%B4%B5%E7%BA%BF%E4%B8%8Are%E5%87%BA%E9%A2%98%E6%80%BB%E7%BB%93/" title="安洵杯线上re出题总结">安洵杯线上re出题总结</a><time datetime="2021-11-30T10:38:45.000Z" title="Created 2021-11-30 18:38:45">2021-11-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/16/2021%20Geek%20and%20HECTF%20re/" title="2021 Geek and HECTF re wp"><img src="https://i.loli.net/2021/11/17/NySwsFh832pcvlk.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021 Geek and HECTF re wp"/></a><div class="content"><a class="title" href="/2021/11/16/2021%20Geek%20and%20HECTF%20re/" title="2021 Geek and HECTF re wp">2021 Geek and HECTF re wp</a><time datetime="2021-11-16T10:38:45.000Z" title="Created 2021-11-16 18:38:45">2021-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/10/python%20spider%20learning/" title="python spider learning"><img src="https://i.loli.net/2021/11/17/9MDnit6mqrLlGQK.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python spider learning"/></a><div class="content"><a class="title" href="/2021/11/10/python%20spider%20learning/" title="python spider learning">python spider learning</a><time datetime="2021-11-10T10:38:45.000Z" title="Created 2021-11-10 18:38:45">2021-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF%20re%20wp/" title="东华杯 re wp"><img src="https://i.loli.net/2021/11/01/rha9bAwGidmPxlM.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="东华杯 re wp"/></a><div class="content"><a class="title" href="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF%20re%20wp/" title="东华杯 re wp">东华杯 re wp</a><time datetime="2021-11-01T14:07:15.789Z" title="Created 2021-11-01 22:07:15">2021-11-01</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/12/02/GBH9cj7JztSasMh.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By The_Itach1</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">木叶飞舞之处，火亦生生不息</div><div class="icp"><a><span></span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>